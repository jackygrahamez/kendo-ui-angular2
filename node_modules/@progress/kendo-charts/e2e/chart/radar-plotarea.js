import 'core-js/es6';
import { $ } from 'e2e-utils'

import { Box } from '../../src/core';
import RadarPlotArea from '../../src/chart/plotarea/radar-plotarea';

import { deepExtend } from '../../src/common';

import { ok, equal, close } from '../../test/test-helpers';

import { clickChart, hoverChart, createChart, destroyChart, getChartDomElement }  from '../test-helpers';

let plotArea, categoryAxis, valueAxis, chartSeries;

function createPlotArea(series, options) {
    plotArea = new RadarPlotArea(series, options);

    categoryAxis = plotArea.categoryAxis;
    valueAxis = plotArea.valueAxis;

    chartSeries = plotArea.charts[0];
}

// ------------------------------------------------------------
describe('Radar Plot Area / Axes', () => {
    beforeEach(() => {
        createPlotArea([{ type: "radarLine", data: [] }]);
    });

    it("roundToMajorUnit is set to false", () => {
        equal(valueAxis.options.roundToMajorUnit, false);
    });

    it("value axis grid lines are set to 'arc' for radarColumn series", () => {
        createPlotArea([{ type: "radarColumn", data: [] }]);
        equal(valueAxis.options.majorGridLines.type, "arc");
        equal(valueAxis.options.minorGridLines.type, "arc");
    });

    it("roundToMajorUnit is set to false for radarColumn series", () => {
        createPlotArea([{ type: "radarColumn", data: [] }]);
        equal(valueAxis.options.roundToMajorUnit, false);
    });

    it("value axis is centered", () => {
        createPlotArea([{ type: "radarColumn", data: [] }]);
        plotArea.reflow(new Box(0, 0, 100, 200));

        const slot = valueAxis.getSlot(0, 0);
        equal([slot.x1, slot.y1], [50, 100]);
    });

    it("reversed value axis is centered", () => {
        createPlotArea([{ type: "radarColumn", data: [100] }], { valueAxis: { reverse: true } });
        plotArea.reflow(new Box(0, 0, 100, 200));

        const slot = valueAxis.getSlot(100, 100);
        equal([slot.x1, slot.y1], [50, 100]);
    });
});

// ------------------------------------------------------------
describe('Radar Plot Area / Legend', () => {

    it("adds series legend items", () => {
        createPlotArea([{ type: "radarColumn", data: [], name: "Foo" }]);

        equal(plotArea.options.legend.items.length, 1);
    });
});


// ------------------------------------------------------------
describe('Radar Plot Area / Configuration', () => {

    it("default axisBox padding is 15% of smallest dimension", () => {
        createPlotArea([{ type: "radarColumn", data: [] }]);
        plotArea.reflow(new Box(0, 0, 100, 200));

        equal(plotArea.axisBox.width(), 70);
        equal(plotArea.axisBox.height(), 170);
    });

    it("default axisBox padding can be overriden", () => {
        createPlotArea([{ type: "radarColumn", data: [] }], {
            plotArea: { padding: 10 }
        });
        plotArea.reflow(new Box(0, 0, 100, 200));

        equal(plotArea.axisBox.width(), 80);
        equal(plotArea.axisBox.height(), 180);
    });

    it("default axisBox padding can be overriden (partial)", () => {
        createPlotArea([{ type: "radarColumn", data: [] }], {
            plotArea: { padding: { top: 10 } }
        });
        plotArea.reflow(new Box(0, 0, 100, 200));

        equal(plotArea.axisBox.width(), 70);
        equal(plotArea.axisBox.height(), 175);
    });
});

// ------------------------------------------------------------
describe('Radar Plot Area / Charts', () => {

    it("first series gap setting is applied to radarColumn charts", () => {
        createPlotArea([{ type: "radarColumn", data: [], gap: 2 }]);

        equal(plotArea.charts[0].options.gap, 2);
    });

    it("first series spacing setting is applied to radarColumn charts", () => {
        createPlotArea([{ type: "radarColumn", data: [], spacing: 2 }]);

        equal(plotArea.charts[0].options.spacing, 2);
    });
});

function assertStackedSeries(seriesType) {
    // ------------------------------------------------------------
    describe('Radar Plot Area / Stacked ' + seriesType + ' /', () => {

        it("sets isStacked when first series is stacked", () => {
            createPlotArea([{
                type: seriesType, data: [], stack: true
            }, {
                type: seriesType, data: []
            }]);

            ok(chartSeries.options.isStacked);
        });

        it("does not set isStacked when first and only series is stacked", () => {
            createPlotArea([{
                type: seriesType, data: [], stack: true
            }]);

            ok(!chartSeries.options.isStacked);
        });

        it("sets isStacked and isStacked100 when first series is 100% stacked", () => {
            createPlotArea([{
                type: seriesType, data: [], stack: { type: "100%" }
            }, {
                type: seriesType, data: []
            }]);

            ok(chartSeries.options.isStacked);
            ok(chartSeries.options.isStacked100);
        });

        it("does not set isStacked and isStacked100 when only series is 100% stacked", () => {
            createPlotArea([{
                type: seriesType, data: [], stack: { type: "100%" }
            }]);

            ok(!chartSeries.options.isStacked);
            ok(!chartSeries.options.isStacked100);
        });
    });
}

assertStackedSeries("radarColumn");
assertStackedSeries("radarLine");
assertStackedSeries("radarArea");

function assertStacked100(seriesType) {
    const series = [{
        type: seriesType,
        stack: { type: "100%" },
        data: [1, 2],
        labels: { }
    }];

    series.push(series[0]);

    // ------------------------------------------------------------
    describe('Radar Plot Area / 100% Stacked ' + seriesType + ' /', () => {

        it("sets value axis roundToMajorUnit to false", () => {
            createPlotArea(series);
            ok(!plotArea.valueAxis.options.roundToMajorUnit);
        });

        it("roundToMajorUnit can be overriden", () => {
            createPlotArea(series, { valueAxis: { roundToMajorUnit: false } });
            ok(!plotArea.valueAxis.options.roundToMajorUnit);
        });

        it("default value axis label format is set to P0", () => {
            createPlotArea(series);
            equal(plotArea.valueAxis.options.labels.format, "P0");
        });

        it("default value axis label format can be overriden", () => {
            createPlotArea(series, { valueAxis: { labels: { format: "N" } } });
            equal(plotArea.valueAxis.options.labels.format, "N");
        });
    });
}

assertStacked100("radarColumn");
assertStacked100("radarLine");
assertStacked100("radarArea");

(function() {
    let chart, point, pointElement, plotArea, plotAreaElement;

    const TOLERANCE = 5;

    function createRadarChart(options) {
        chart = createChart(deepExtend({
            series: [{
                type: "radarLine",
                data: [1, 2, 3],
                markers: { visible: true }
            }],
            categoryAxis: {
                categories: ["A", "B", "C"]
            },
            chartArea: {
                width: 600,
                height: 400
            }
        }, options));

        $("#container").css({ position: "absolute", top: "200px", left: "8px" });

        plotArea = chart._model.children[1];
        plotAreaElement = getChartDomElement(plotArea);
        point = plotArea.charts[0].points[0];
        pointElement = getChartDomElement(point.marker);
    }

    function radarPlotAreaEventsTests(eventName, triggerEvent) {
        const eventOptions = {};

        // ------------------------------------------------------------
        describe("Radar Plot Area / Events / " + eventName, () => {
            afterEach(() => {
                destroyChart(chart);
            });

            it("point event bubbles to plot area", () => {
                eventOptions[eventName] = function() { ok(true); };
                createRadarChart(eventOptions);

                triggerEvent(chart, pointElement, 300, 300);
            });

            it("fires on plot area directly", () => {
                eventOptions[eventName] = function() { ok(true); };
                createRadarChart(eventOptions);

                triggerEvent(chart, plotAreaElement, 300, 300);
            });

            it("does not fire outside of axis range", 0, () => {
                eventOptions[eventName] = function() { ok(false); };
                createRadarChart(eventOptions);

                triggerEvent(chart, plotAreaElement, 300, 580);
            });

            it("does not fire on axes", 0, () => {
                eventOptions[eventName] = function() { ok(false); };
                createRadarChart(eventOptions);

                triggerEvent(chart, plotAreaElement, 3000, 0);
            });

            it("event arguments contain value", 1, () => {
                eventOptions[eventName] = function(e) { close(e.value, 0.4, TOLERANCE); };
                createRadarChart(eventOptions);

                triggerEvent(chart, plotAreaElement, 300, 400);
            });

            it("event arguments contain category", 1, () => {
                eventOptions[eventName] = function(e) { equal(e.category, "A"); };
                createRadarChart(eventOptions);

                triggerEvent(chart, plotAreaElement, 300, 300);
            });

            it("event arguments contain empty category", 1, () => {
                eventOptions[eventName] = function(e) { equal(e.category, ""); };
                createRadarChart(deepExtend({
                    categoryAxis: {
                        categories: ["A"]
                    }                    
                }, eventOptions));

                triggerEvent(chart, plotAreaElement, 300, 400);
            });

            it("event arguments contain date category", 1, () => {                
                const date = new Date("2012/09/15");
                eventOptions[eventName] = function(e) { equal(e.category.toString(), date.toString()); };
                
                createRadarChart(deepExtend({
                    categoryAxis: {
                        categories: [date]
                    }                    
                }, eventOptions));

                triggerEvent(chart, plotAreaElement, 300, 300);
            });
        });
    }

    radarPlotAreaEventsTests("plotAreaClick", clickChart);
    radarPlotAreaEventsTests("plotAreaHover", hoverChart);
    
})();
