export class Matrix {

    a: number;
    b: number;
    c: number;
    d: number;
    e: number;
    f: number;

    constructor(a?: number, b?: number, c?: number, d?: number, e?: number, f?: number);

    static rotate(angle: number, x: number, y: number): Matrix;
    static scale(scaleX: number, scaleY: number): Matrix;
    static translate(x: number, y: number): Matrix;
    static unit(): Matrix;

    clone(): Matrix;
    equals(other: Matrix): boolean;
    round(digits: number): Matrix;
    multiplyCopy(matrix: Matrix): Matrix;
    toArray(digits: number): any;
    toString(digits: number, separator: string): string;
}

export class Transformation {

    constructor(matrix?: Matrix);

    clone(): Transformation;
    equals(other: Transformation): boolean;
    matrix(): Matrix;
    multiply(transformation: Transformation): Transformation;
    rotate(angle: number, center: any): Transformation;
    rotate(angle: number, center: Point): Transformation;
    scale(scaleX: number, scaleY: number): Transformation;
    translate(x: number, y: number): Transformation;

}

export class Point {

    x: number;
    y: number;

    constructor(x: number, y: number);

    static create(x: number, y: number): Point;
    static create(x: any, y: number): Point;
    static create(x: Point, y: number): Point;
    static min(): Point;
    static max(): Point;
    static minPoint(): Point;
    static maxPoint(): Point;

    clone(): Point;
    distanceTo(point: Point): number;
    equals(other: Point): boolean;
    getX(): number;
    getY(): number;
    move(x: number, y: number): Point;
    rotate(angle: number, center: Point): Point;
    rotate(angle: number, center: any): Point;
    round(digits: number): Point;
    scale(scaleX: number, scaleY: number): Point;
    scaleCopy(scaleX: number, scaleY: number): Point;
    setX(value: number): Point;
    setY(value: number): Point;
    toArray(digits: number): any;
    toString(digits: number, separator: string): string;
    transform(tansformation: Transformation): Point;
    transformCopy(tansformation: Transformation): Point;
    translate(dx: number, dy: number): Point;
    translateWith(vector: Point): Point;
    translateWith(vector: any): Point;

}

export class Size {

    width: number;
    height: number;

    constructor(width?: number, height?: number);


    static create(width: number, height: number): Size;
    static create(width: any, height: number): Size;
    static create(width: Size, height: number): Size;

    clone(): Size;
    equals(other: Size): boolean;
    getWidth(): number;
    getHeight(): number;
    setWidth(value: number): Size;
    setHeight(value: number): Size;

}


export class Rect {

    origin: Point;
    size: Size;


    constructor(origin: Point|any, size: Size|any);

    static fromPoints(pointA: Point, pointB: Point): Rect;
    static union(rectA: Rect, rectB: Rect): Rect;

    bbox(matrix: Matrix): Rect;
    bottomLeft(): Point;
    bottomRight(): Point;
    center(): Point;
    clone(): Rect;
    equals(other: Rect): boolean;
    getOrigin(): Point;
    getSize(): Size;
    height(): number;
    setOrigin(value: Point): Rect;
    setOrigin(value: any): Rect;
    setSize(value: Size): Rect;
    setSize(value: any): Rect;
    topLeft(): Point;
    topRight(): Point;
    width(): number;

}

export class Circle {

    center: Point;
    radius: number;

    constructor(center: any|Point, radius: number);

    bbox(matrix: Matrix): Rect;
    clone(): Circle;
    equals(other: Circle): boolean;
    getCenter(): Point;
    getRadius(): number;
    pointAt(angle: number): Point;
    setCenter(value: Point): Point;
    setCenter(value: any): Point;
    setRadius(value: number): Circle;

}

export interface ArcOptions {
    anticlockwise?: boolean;
    startAngle?: number;
    endAngle?: number;
    radiusX?: number;
    radiusY?: number;
}

export class Arc {

    anticlockwise: boolean;
    center: Point;
    endAngle: number;
    radiusX: number;
    radiusY: number;
    startAngle: number;

    constructor(center: any|Point, options?: ArcOptions);

    bbox(matrix: Matrix): Rect;
    getAnticlockwise(): boolean;
    getCenter(): Point;
    getEndAngle(): number;
    getRadiusX(): number;
    getRadiusY(): number;
    getStartAngle(): number;
    pointAt(angle: number): Point;
    setAnticlockwise(value: boolean): Arc;
    setCenter(value: Point): Arc;
    setEndAngle(value: number): Arc;
    setRadiusX(value: number): Arc;
    setRadiusY(value: number): Arc;
    setStartAngle(value: number): Arc;

}

export class Segment {

    constructor(anchor: Point, controlIn?: Point, controlOut?: Point);

    anchor(): Point;
    anchor(value: Point): void;
    controlIn(): Point;
    controlIn(value: Point): void;
    controlOut(): Point;
    controlOut(value: Point): void;

}
