import { drawing as draw } from '@progress/kendo-drawing';

import { deepExtend, map } from '../../src/common';
import { RootElement, Box } from '../../src/core';

import ScatterChart from '../../src/chart/scatter-charts/scatter-chart';
import ClipAnimation from '../../src/chart/animations/clip-animation';

import { ok, equal, createSpy, sameLinePath, sameBox, each } from '../../test/test-helpers';
import { createChart, destroyChart }  from '../test-helpers';
import '../../test/intl';

const chartBox = new Box(0, 0, 800, 600);
const TOLERANCE = 1;
let plotArea, root, scatterChart;

function setupScatterChart(plotArea, options, rootOptions) {
    scatterChart = new ScatterChart(plotArea, options);

    root = new RootElement(rootOptions);
    root.append(scatterChart);

    root.reflow();
    root.renderVisual();
}

(function() {
    const series = { data: [[1, 1], [2, 2]], labels: {}, type: "scatter" };
    const sparseSeries = {
        data: [
            [1, 1], [2, 2], undefined, [2, 2], [null, 1], [1, null]
        ],
        labels: {},
        type: "scatter"
    };
    const VALUE_AXIS_MAX = 2;
    const CATEGORY_AXIS_Y = 2;

    function PlotAreaStub() { }

    deepExtend(PlotAreaStub.prototype, {
        axisX: {
            getSlot: function(categoryIndex) {
                return new Box(categoryIndex, CATEGORY_AXIS_Y,
                categoryIndex + 1, CATEGORY_AXIS_Y);
            }
        },
        axisY: {
            getSlot: function(value = 0) {
                const valueY = VALUE_AXIS_MAX - value;
                const slotTop = Math.min(CATEGORY_AXIS_Y, valueY);
                const slotBottom = Math.max(CATEGORY_AXIS_Y, valueY);

                return new Box(0, slotTop, 0, slotBottom);
            },
            options: {}
        },
        namedXAxes: {},
        namedYAxes: {}
    });

    // ------------------------------------------------------------
    describe('Scatter Chart / Series', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupScatterChart(plotArea, { series: [ series ] });
        });

        it("Creates points for scatterChart data points", () => {
            equal(scatterChart.points.length, series.data.length);
        });

        it("Reports minimum value for primary X axis", () => {
            equal(scatterChart.xAxisRanges[undefined].min, series.data[0][0]);
        });

        it("Reports minimum value for primary Y axis", () => {
            equal(scatterChart.yAxisRanges[undefined].min, series.data[0][1]);
        });

        it("Reports maximum value for primary X axis", () => {
            equal(scatterChart.xAxisRanges[undefined].max, series.data[1][0]);
        });

        it("Reports maximum value for primary Y axis", () => {
            equal(scatterChart.yAxisRanges[undefined].max, series.data[1][1]);
        });

        it("points have set width", () => {
            each(scatterChart.points, function() {
                equal(this.box.width(), 1);
            });
        });

        it("points have set height according to value", () => {
            const pointHeights = map(scatterChart.points, function(point) {
                return point.box.height();
            });

            equal(pointHeights, [1, 2]);
        });

        it("sets point owner", () => {
            ok(scatterChart.points[0].owner === scatterChart);
        });

        it("sets point series", () => {
            ok(scatterChart.points[0].series === series);
        });

        it("sets point series index", () => {
            ok(scatterChart.points[0].seriesIx === 0);
        });

        it("sets point dataItem", () => {
            equal(typeof scatterChart.points[0].dataItem, "object");
        });

        it("removes the series points if the visible is set to false", () => {
            const chart = createChart({
                seriesDefaults: {
                    type: "scatterLine"
                },
                series: [{
                    data: [[1,2]],
                    visible: false
                },{
                    data: [[1,2]]
                }]
            });

            const points = chart._plotArea.charts[0].points;
            ok(points.length === 1);

            destroyChart(chart);
        });

        it("renders empty scatter line series", 0, () => {
            setupScatterChart(plotArea, { series: [ { data: [] } ] });
        });

        it("renders empty and non-empty scatter line series", 0, () => {
            setupScatterChart(plotArea, { series: [ { data: [] }, series ] });
        });
    });

    // ------------------------------------------------------------
    describe('Scatter Chart / Multiple Axes', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            plotArea.namedXAxes.secondary = plotArea.axisX;
            plotArea.namedYAxes.secondary = plotArea.axisY;

            setupScatterChart(plotArea, {
                series: [
                    { type: "scatter", data: [[1, 10], [2, 20]] },
                    { type: "scatter", xAxis: "secondary", yAxis: "secondary", data: [[3, 30], [4, 40]] }
                ]
            });
        });

        it("Reports minimum value for primary X axis", () => {
            equal(scatterChart.xAxisRanges[undefined].min, 1);
        });

        it("Reports minimum value for primary Y axis", () => {
            equal(scatterChart.yAxisRanges[undefined].min, 10);
        });

        it("Reports maximum value for primary X axis", () => {
            equal(scatterChart.xAxisRanges[undefined].max, 2);
        });

        it("Reports maximum value for primary Y axis", () => {
            equal(scatterChart.yAxisRanges[undefined].max, 20);
        });

        it("Reports minimum value for secondary X axis", () => {
            equal(scatterChart.xAxisRanges.secondary.min, 3);
        });

        it("Reports minimum value for secondary Y axis", () => {
            equal(scatterChart.yAxisRanges.secondary.min, 30);
        });

        it("Reports maximum value for secondary X axis", () => {
            equal(scatterChart.xAxisRanges.secondary.max, 4);
        });

        it("Reports maximum value for secondary Y axis", () => {
            equal(scatterChart.yAxisRanges.secondary.max, 40);
        });

        it("Throws error when unable to locate X axis", () => {
            expect(function() {
                setupScatterChart(plotArea, {
                    series: [
                        { data: [[1, 10], [2, 20]], xAxis: "b" }
                    ]
                });
            }).toThrowError(/Unable to locate X axis with name b/);
        });

        it("Throws error when unable to locate Y axis", () => {
            expect(function() {
                setupScatterChart(plotArea, {
                    series: [
                        { data: [[1, 10], [2, 20]], yAxis: "b" }
                    ]
                });
            }).toThrowError(/Unable to locate Y axis with name b/);
        });
    });

    // ------------------------------------------------------------
    describe('Scatter Chart / Missing values', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupScatterChart(plotArea, {
                series: [ sparseSeries ]
            });
        });

        it("Reports minimum value for primary X axis", () => {
            equal(scatterChart.xAxisRanges[undefined].min, 1);
        });

        it("Reports minimum value for primary Y axis", () => {
            equal(scatterChart.yAxisRanges[undefined].min, 1);
        });

        it("Reports maximum value for primary X axis", () => {
            equal(scatterChart.xAxisRanges[undefined].max, 2);
        });

        it("Reports maximum value for primary Y axis", () => {
            equal(scatterChart.yAxisRanges[undefined].max, 2);
        });

        it("omits null points by default", () => {
            equal(scatterChart.points[2], undefined);
        });

        it("omits null points when interpolating", () => {
            setupScatterChart(plotArea, {
                series: [
                    deepExtend({ missingValues: "interpolate" }, sparseSeries)
                ]
            });

            equal(scatterChart.points[2], undefined);
        });

        it("point with missing X value is omitted", () => {
            equal(scatterChart.points[5], undefined);
        });

        it("point with missing Y value is omitted", () => {
            equal(scatterChart.points[6], undefined);
        });
    });

    // ------------------------------------------------------------
    describe('Scatter Chart / Labels', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
        });

        it("applies full label format", () => {
            setupScatterChart(plotArea, {
                series: [{
                    data: [[1, 10], [2, 20]],
                    labels: { visible: true, format: "{0:C} {1:C}" },
                    type: "scatter"
                }]
            });

            const label = scatterChart.points[0].label;
            const text = label.visual.children[0];
            equal(text.content(), "$1.00 $10.00");
        });
    });

})();

(function() {
    const MARGIN = 5;
    const PADDING = 5;
    const BORDER = 5;
    let scatterChart, linePoint, scatterPoint;

    function PlotAreaStub() { }

    deepExtend(PlotAreaStub.prototype, {
        axisX: {
            getSlot: function(value) {
                return new Box();
            }
        },
        axisY: {
            getSlot: function(categoryIndex) {
                return new Box();
            }
        }
    });

    function createScatterChart(options) {
        plotArea = new PlotAreaStub();
        scatterChart = new ScatterChart(plotArea, {
            series: [deepExtend({
                data: [[0, 0], [1, 1]],
                type: "scatter",
                color: "#f00",
                markers: {
                    visible: false,
                    size: 10,
                    type: "triangle",
                    border: {
                        width: BORDER
                    }
                },
                labels: {
                    visible: false,
                    color: "labels-color",
                    background: "labels-background",
                    border: {
                        color: "labels-border",
                        width: BORDER
                    },
                    margin: MARGIN,
                    padding: PADDING
                },
                opacity: 0.5,
                dashType: "dot"
            }, options)]
        });
        scatterPoint = scatterChart.points[0];
    }

    // ------------------------------------------------------------
    describe('Scatter Chart / Configuration', () => {
        beforeEach(() => {
            createScatterChart();
        });

        it("applies visible to point markers", () => {
            equal(scatterPoint.options.markers.visible, false);
        });

        it("applies series color to point markers border", () => {
            createScatterChart({ markers: { visible: true } });
            scatterChart.reflow(chartBox);
            equal(scatterPoint.marker.options.border.color, "#f00");
        });

        it("applies series opacity color to point markers", () => {
            equal(scatterPoint.options.markers.opacity, 0.5);
        });

        it("applies size to point markers", () => {
            equal(scatterPoint.options.markers.size, 10);
        });

        it("applies type to point markers", () => {
            equal(scatterPoint.options.markers.type, "triangle");
        });

        it("applies border color to point markers", () => {
            createScatterChart({ markers: { border: { color: "marker-border" } } });
            equal(scatterPoint.options.markers.border.color, "marker-border");
        });

        it("applies border width to point markers.", () => {
            equal(scatterPoint.options.markers.border.width, BORDER);
        });

        it("applies visible to point labels", () => {
            equal(scatterPoint.options.labels.visible, false);
        });

        it("applies color to point labels", () => {
            equal(scatterPoint.options.labels.color, "labels-color");
        });

        it("applies background to point labels", () => {
            equal(scatterPoint.options.labels.background, "labels-background");
        });

        it("applies border color to point labels", () => {
            equal(scatterPoint.options.labels.border.color, "labels-border");
        });

        it("applies border width to point labels", () => {
            equal(scatterPoint.options.labels.border.width, BORDER);
        });

        it("applies padding to point labels", () => {
            equal(scatterPoint.options.labels.padding, PADDING);
        });

        it("applies margin to point labels", () => {
            equal(scatterPoint.options.labels.margin, MARGIN);
        });

        it("applies margin to point labels", () => {
            equal(scatterPoint.options.dashType, "dot");
        });

        it("applies color function", () => {
            createScatterChart({
                color: function(point) { return "#f00" }
            });

            equal(scatterPoint.color, "#f00");
        });

        it("applies color function for each point", 2, () => {
            createScatterChart({
                color: function() { ok(true); }
            });
        });

        it("color fn argument contains value", 1, () => {
            createScatterChart({
                data: [[1, 1]],
                color: function(point) {
                    equal(point.value, { x: 1, y: 1});
                }
            });
        });

        it("color fn argument contains series", 1, () => {
            createScatterChart({
                name: "series 1",
                data: [[1, 1]],
                color: function(point) { equal(point.series.name, "series 1"); }
            });
        });

        it("color fn argument contains dataItem", 1, () => {
            createScatterChart({
                data: [[1, 1]],
                color: function(point) { equal(point.dataItem[0], 1); }
            });
        });
    });

})();

(function() {
    const data = [{
        xValue: 3,
        yValue: 1
    }, {
        xValue: 2,
        yValue: 2
    }, {
        xValue: 2,
        yValue: 2
    }];
    let points, legend, chart;

    // ------------------------------------------------------------
    describe('Scatter Chart / Integration', () => {
        beforeEach(() => {
            chart = createChart({
                series: [{
                    data: data,
                    name: "A",
                    type: "scatter",
                    xField: "xValue",
                    yField: "yValue",
                    test: "test"
                }],
                legend: {
                    labels: {
                        template: "#= text #-#= series.test #"
                    }
                }
            });

            points = chart._plotArea.charts[0].points;
            legend = chart._model.children[0];
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("gets data from x and y field", () => {
            equal(points.length, 3);
        });

        it("legend labels template", () => {
            equal(legend.options.items[0].text, "A-test");
        });

    });

})();

(function() {
    let note, chart;

    describe('Scatter Chart / Note', () => {
        beforeEach(() => {
            chart = createChart({
                series: [{
                    name: "Value",
                    type: "scatter",
                    data: [{ x: 1, y: 10, noteText: "A" }]
                }]
            });

            note = chart._plotArea.charts[0].points[0].note;
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("should have text", () => {
            equal(note.text, "A");
        });
    });

    describe('Scatter Chart / Note Template', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        function createNote(options) {
            chart = createChart({
                series: [{
                    name: "Value",
                    type: "scatter",
                    data: [{ x: 1, y: 10, noteText: "A", test: "test" }],
                    notes: deepExtend({}, options),
                    name: "name"
                }]
            });

            note = chart._plotArea.charts[0].points[0].note;
        }

        it("dataItem", () => {
            createNote({
                label: {
                    template: "#= dataItem.test #"
                }
            });

            equal(note.label.content, "test");
        });

        it("value", () => {
            createNote({
                label: {
                    template: "x: #= value.x # y: #= value.y #"
                }
            });

            equal(note.label.content, "x: 1 y: 10");
        });

        it("series", () => {
            createNote({
                label: {
                    template: "#= series.name #"
                }
            });

            equal(note.label.content, "name");
        });
    });
})();

(function() {

    function PlotAreaStub() { }

    deepExtend(PlotAreaStub.prototype, {
        axisX: {
            getSlot: function(value) {
                return new Box();
            }
        },
        axisY: {
            getSlot: function(categoryIndex) {
                return new Box();
            }
        }
    });

    function createChart(options) {
        setupScatterChart(new PlotAreaStub(), options || {
            series: [{
                type: "scatter",
                data: [[1, 1]]
            }]
        });
    }

    describe('Scatter Chart / Rendering', () => {
        beforeEach(() => {
            createChart();
        });

        it("creates visual", () => {
            ok(scatterChart.visual);
        });

        it("creates clip animation", () => {
            ok(scatterChart.animation);
            ok(scatterChart.animation instanceof ClipAnimation);
            sameBox(scatterChart.animation.options.box, root.box);
            sameLinePath(scatterChart.animation.element, draw.Path.fromRect(root.box.toRect()));
        });

        it("does not create clip animation if transitions are disabled", () => {
            setupScatterChart(new PlotAreaStub(), { series: [{
                    type: "scatter",
                    data: [[1, 1]]
                }]}, {
                transitions: false
            });

            ok(!scatterChart.animation);
            ok(!scatterChart.visual.clip());
        });

        it("does not set clip on points markers by default", () => {
            const points = scatterChart.points;
            for (let idx = 0; idx < points.length; idx++) {
                ok(!points[idx].marker.visual.clip());
            }
        });

        it("sets animation clip path to points markers with zIndex", () => {
            createChart({
                series: [{
                    type: "scatter",
                    data: [[0, 1]]
                }, {
                    type: "scatter",
                    data: [[1, 2], null],
                    zIndex: 1
                }]
            });
            const clip = scatterChart.seriesPoints[1][0].marker.visual.clip();
            ok(clip);
            ok(clip === scatterChart.animation.element);
            ok(!scatterChart.seriesPoints[0][0].marker.visual.clip());
        });
    });

})();

// ------------------------------------------------------------

(function() {
    describe('Scatter Chart / Values exceeding axis min or max options ', () => {

        it("values are not limited", 2, () => {
            const plotArea = {
                axisX: {
                    getSlot: function(a,b,limit) {
                        ok(!limit);
                        return new Box();
                    }
                },
                axisY: {
                    getSlot: function(a,b, limit) {
                        ok(!limit);
                        return new Box();
                    }
                }
            };

            setupScatterChart(plotArea, { series: [ {data: [[1, 2]], type: "scatter"} ] });
        });
    });
})();
