module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(151);


/***/ },

/***/ 104:
/***/ function(module, exports) {

	module.exports = require("../mixins/observers-mixin");

/***/ },

/***/ 151:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _defineAccessors = __webpack_require__(152);

	var _defineAccessors2 = _interopRequireDefault(_defineAccessors);

	var _observersMixin = __webpack_require__(104);

	var _observersMixin2 = _interopRequireDefault(_observersMixin);

	var _round = __webpack_require__(153);

	var _round2 = _interopRequireDefault(_round);

	var _rad = __webpack_require__(154);

	var _rad2 = _interopRequireDefault(_rad);

	var _deg = __webpack_require__(155);

	var _deg2 = _interopRequireDefault(_deg);

	var _closeOrLess = __webpack_require__(156);

	var _closeOrLess2 = _interopRequireDefault(_closeOrLess);

	var _lineIntersection = __webpack_require__(157);

	var _lineIntersection2 = _interopRequireDefault(_lineIntersection);

	var _ellipseExtremeAngles = __webpack_require__(158);

	var _ellipseExtremeAngles2 = _interopRequireDefault(_ellipseExtremeAngles);

	var _constants = __webpack_require__(159);

	var _point = __webpack_require__(160);

	var _point2 = _interopRequireDefault(_point);

	var _rect = __webpack_require__(161);

	var _rect2 = _interopRequireDefault(_rect);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var MAX_INTERVAL = 45;
	var pow = Math.pow;

	var Arc = function () {
	    function Arc() {
	        var center = arguments.length <= 0 || arguments[0] === undefined ? new _point2.default() : arguments[0];
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        _classCallCheck(this, Arc);

	        this.setCenter(center);

	        this.radiusX = options.radiusX;
	        this.radiusY = options.radiusY || options.radiusX;
	        this.startAngle = options.startAngle;
	        this.endAngle = options.endAngle;
	        this.anticlockwise = options.anticlockwise || false;
	    }

	    _createClass(Arc, [{
	        key: 'clone',
	        value: function clone() {
	            return new Arc(this.center, {
	                radiusX: this.radiusX,
	                radiusY: this.radiusY,
	                startAngle: this.startAngle,
	                endAngle: this.endAngle,
	                anticlockwise: this.anticlockwise
	            });
	        }
	    }, {
	        key: 'setCenter',
	        value: function setCenter(value) {
	            this._observerField("center", _point2.default.create(value));
	            this.geometryChange();
	            return this;
	        }
	    }, {
	        key: 'getCenter',
	        value: function getCenter() {
	            return this.center;
	        }
	    }, {
	        key: 'pointAt',
	        value: function pointAt(angle) {
	            var center = this.center;
	            var radian = (0, _rad2.default)(angle);

	            return new _point2.default(center.x + this.radiusX * Math.cos(radian), center.y + this.radiusY * Math.sin(radian));
	        }
	    }, {
	        key: 'curvePoints',
	        value: function curvePoints() {
	            var startAngle = this.startAngle;
	            var dir = this.anticlockwise ? -1 : 1;
	            var curvePoints = [this.pointAt(startAngle)];
	            var interval = this._arcInterval();
	            var intervalAngle = interval.endAngle - interval.startAngle;
	            var subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);
	            var subIntervalAngle = intervalAngle / subIntervalsCount;
	            var currentAngle = startAngle;

	            for (var i = 1; i <= subIntervalsCount; i++) {
	                var nextAngle = currentAngle + dir * subIntervalAngle;
	                var points = this._intervalCurvePoints(currentAngle, nextAngle);

	                curvePoints.push(points.cp1, points.cp2, points.p2);
	                currentAngle = nextAngle;
	            }

	            return curvePoints;
	        }
	    }, {
	        key: 'bbox',
	        value: function bbox(matrix) {
	            var interval = this._arcInterval();
	            var startAngle = interval.startAngle;
	            var endAngle = interval.endAngle;
	            var extremeAngles = (0, _ellipseExtremeAngles2.default)(this.center, this.radiusX, this.radiusY, matrix);
	            var extremeX = (0, _deg2.default)(extremeAngles.x);
	            var extremeY = (0, _deg2.default)(extremeAngles.y);
	            var endPoint = this.pointAt(endAngle).transformCopy(matrix);
	            var currentAngleX = bboxStartAngle(extremeX, startAngle);
	            var currentAngleY = bboxStartAngle(extremeY, startAngle);
	            var currentPoint = this.pointAt(startAngle).transformCopy(matrix);
	            var minPoint = _point2.default.min(currentPoint, endPoint);
	            var maxPoint = _point2.default.max(currentPoint, endPoint);

	            while (currentAngleX < endAngle || currentAngleY < endAngle) {
	                var currentPointX = void 0;
	                if (currentAngleX < endAngle) {
	                    currentPointX = this.pointAt(currentAngleX).transformCopy(matrix);
	                    currentAngleX += 90;
	                }

	                var currentPointY = void 0;
	                if (currentAngleY < endAngle) {
	                    currentPointY = this.pointAt(currentAngleY).transformCopy(matrix);
	                    currentAngleY += 90;
	                }

	                currentPoint = new _point2.default(currentPointX.x, currentPointY.y);
	                minPoint = _point2.default.min(minPoint, currentPoint);
	                maxPoint = _point2.default.max(maxPoint, currentPoint);
	            }

	            return _rect2.default.fromPoints(minPoint, maxPoint);
	        }
	    }, {
	        key: '_arcInterval',
	        value: function _arcInterval() {
	            var startAngle = this.startAngle;
	            var endAngle = this.endAngle;
	            var anticlockwise = this.anticlockwise;


	            if (anticlockwise) {
	                var oldStart = startAngle;
	                startAngle = endAngle;
	                endAngle = oldStart;
	            }

	            if (startAngle > endAngle || anticlockwise && startAngle === endAngle) {
	                endAngle += 360;
	            }

	            return {
	                startAngle: startAngle,
	                endAngle: endAngle
	            };
	        }
	    }, {
	        key: '_intervalCurvePoints',
	        value: function _intervalCurvePoints(startAngle, endAngle) {
	            var p1 = this.pointAt(startAngle);
	            var p2 = this.pointAt(endAngle);
	            var p1Derivative = this._derivativeAt(startAngle);
	            var p2Derivative = this._derivativeAt(endAngle);
	            var t = ((0, _rad2.default)(endAngle) - (0, _rad2.default)(startAngle)) / 3;
	            var cp1 = new _point2.default(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);
	            var cp2 = new _point2.default(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);

	            return {
	                p1: p1,
	                cp1: cp1,
	                cp2: cp2,
	                p2: p2
	            };
	        }
	    }, {
	        key: '_derivativeAt',
	        value: function _derivativeAt(angle) {
	            var radian = (0, _rad2.default)(angle);

	            return new _point2.default(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));
	        }
	    }, {
	        key: 'containsPoint',
	        value: function containsPoint(point) {
	            var interval = this._arcInterval();
	            var intervalAngle = interval.endAngle - interval.startAngle;
	            var center = this.center;
	            var radiusX = this.radiusX;
	            var radiusY = this.radiusY;

	            var distance = center.distanceTo(point);
	            var angleRad = Math.atan2(point.y - center.y, point.x - center.x);
	            var pointRadius = radiusX * radiusY / Math.sqrt(pow(radiusX, 2) * pow(Math.sin(angleRad), 2) + pow(radiusY, 2) * pow(Math.cos(angleRad), 2));
	            var startPoint = this.pointAt(this.startAngle).round(_constants.PRECISION);
	            var endPoint = this.pointAt(this.endAngle).round(_constants.PRECISION);
	            var intersection = (0, _lineIntersection2.default)(center, point.round(_constants.PRECISION), startPoint, endPoint);
	            var containsPoint = void 0;

	            if (intervalAngle < 180) {
	                containsPoint = intersection && (0, _closeOrLess2.default)(center.distanceTo(intersection), distance) && (0, _closeOrLess2.default)(distance, pointRadius);
	            } else {
	                var angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);
	                if (angle !== 360) {
	                    angle = (360 + angle) % 360;
	                }

	                var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;
	                containsPoint = inAngleRange && (0, _closeOrLess2.default)(distance, pointRadius) || !inAngleRange && (!intersection || intersection.equals(point));
	            }
	            return containsPoint;
	        }
	    }, {
	        key: '_isOnPath',
	        value: function _isOnPath(point, width) {
	            var interval = this._arcInterval();
	            var center = this.center;
	            var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);
	            if (angle !== 360) {
	                angle = (360 + angle) % 360;
	            }

	            var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;

	            return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;
	        }
	    }], [{
	        key: 'fromPoints',
	        value: function fromPoints(start, end, rx, ry, largeArc, swipe) {
	            var arcParameters = normalizeArcParameters({
	                x1: start.x,
	                y1: start.y,
	                x2: end.x,
	                y2: end.y,
	                rx: rx,
	                ry: ry,
	                largeArc: largeArc,
	                swipe: swipe
	            });

	            return new Arc(arcParameters.center, {
	                startAngle: arcParameters.startAngle,
	                endAngle: arcParameters.endAngle,
	                radiusX: rx,
	                radiusY: ry,
	                anticlockwise: swipe === 0
	            });
	        }
	    }]);

	    return Arc;
	}();

	(0, _defineAccessors2.default)(Arc.prototype, ["radiusX", "radiusY", "startAngle", "endAngle", "anticlockwise"]);
	_observersMixin2.default.extend(Arc.prototype);

	function elipseAngle(start, end, swipe) {
	    var endAngle = end;

	    if (start > endAngle) {
	        endAngle += 360;
	    }

	    var alpha = Math.abs(endAngle - start);
	    if (!swipe) {
	        alpha = 360 - alpha;
	    }

	    return alpha;
	}

	function calculateAngle(cx, cy, rx, ry, x, y) {
	    var cos = (0, _round2.default)((x - cx) / rx, 3);
	    var sin = (0, _round2.default)((y - cy) / ry, 3);

	    return (0, _round2.default)((0, _deg2.default)(Math.atan2(sin, cos)));
	}

	function normalizeArcParameters(parameters) {
	    var x1 = parameters.x1;
	    var y1 = parameters.y1;
	    var x2 = parameters.x2;
	    var y2 = parameters.y2;
	    var rx = parameters.rx;
	    var ry = parameters.ry;
	    var largeArc = parameters.largeArc;
	    var swipe = parameters.swipe;

	    var cx = void 0,
	        cy = void 0;
	    var cx1 = void 0,
	        cy1 = void 0;
	    var a = void 0,
	        b = void 0,
	        c = void 0,
	        sqrt = void 0;

	    if (y1 !== y2) {
	        var x21 = x2 - x1;
	        var y21 = y2 - y1;
	        var rx2 = pow(rx, 2),
	            ry2 = pow(ry, 2);
	        var k = (ry2 * x21 * (x1 + x2) + rx2 * y21 * (y1 + y2)) / (2 * rx2 * y21);
	        var yk2 = k - y2;
	        var l = -(x21 * ry2) / (rx2 * y21);

	        a = 1 / rx2 + pow(l, 2) / ry2;
	        b = 2 * (l * yk2 / ry2 - x2 / rx2);
	        c = pow(x2, 2) / rx2 + pow(yk2, 2) / ry2 - 1;
	        sqrt = Math.sqrt(pow(b, 2) - 4 * a * c);

	        cx = (-b - sqrt) / (2 * a);
	        cy = k + l * cx;
	        cx1 = (-b + sqrt) / (2 * a);
	        cy1 = k + l * cx1;
	    } else if (x1 !== x2) {
	        b = -2 * y2;
	        c = pow((x2 - x1) * ry / (2 * rx), 2) + pow(y2, 2) - pow(ry, 2);
	        sqrt = Math.sqrt(pow(b, 2) - 4 * c);

	        cx = cx1 = (x1 + x2) / 2;
	        cy = (-b - sqrt) / 2;
	        cy1 = (-b + sqrt) / 2;
	    } else {
	        return false;
	    }

	    var start = calculateAngle(cx, cy, rx, ry, x1, y1);
	    var end = calculateAngle(cx, cy, rx, ry, x2, y2);
	    var alpha = elipseAngle(start, end, swipe);

	    if (largeArc && alpha <= 180 || !largeArc && alpha > 180) {
	        cx = cx1;cy = cy1;
	        start = calculateAngle(cx, cy, rx, ry, x1, y1);
	        end = calculateAngle(cx, cy, rx, ry, x2, y2);
	    }

	    return {
	        center: new _point2.default(cx, cy),
	        startAngle: start,
	        endAngle: end
	    };
	}

	function bboxStartAngle(angle, start) {
	    var startAngle = angle;

	    while (startAngle < start) {
	        startAngle += 90;
	    }

	    return startAngle;
	}

	exports.default = Arc;

/***/ },

/***/ 152:
/***/ function(module, exports) {

	module.exports = require("../accessors/define-accessors");

/***/ },

/***/ 153:
/***/ function(module, exports) {

	module.exports = require("../common/round");

/***/ },

/***/ 154:
/***/ function(module, exports) {

	module.exports = require("./math/rad");

/***/ },

/***/ 155:
/***/ function(module, exports) {

	module.exports = require("./math/deg");

/***/ },

/***/ 156:
/***/ function(module, exports) {

	module.exports = require("./math/close-or-less");

/***/ },

/***/ 157:
/***/ function(module, exports) {

	module.exports = require("./math/line-intersection");

/***/ },

/***/ 158:
/***/ function(module, exports) {

	module.exports = require("./math/ellipse-extreme-angles");

/***/ },

/***/ 159:
/***/ function(module, exports) {

	module.exports = require("./constants");

/***/ },

/***/ 160:
/***/ function(module, exports) {

	module.exports = require("./point");

/***/ },

/***/ 161:
/***/ function(module, exports) {

	module.exports = require("./rect");

/***/ }

/******/ });