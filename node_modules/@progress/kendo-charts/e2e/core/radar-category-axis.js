import 'core-js/es6';
import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';

import { ShapeBuilder, Box, Point } from '../../src/core';
import RadarCategoryAxis from '../../src/core/radar-category-axis';

import { deepExtend, map, last, rad } from '../../src/common';

import { ok, equal, close, sameLinePath, closeTextPosition, equalTexts, closePaths } from '../../test/test-helpers';

import { clickChart, createChart, destroyChart, getChartDomElement }  from '../test-helpers';

import '../../test/text-measure';
import '../../test/intl';

const chartBox = new Box(100, 100, 500, 500);
const center = new Point(300, 300);
const TOLERANCE = 4;
let axis, altAxis, plotBands, gridLines;

function createAxis(options) {
    altAxis = {
        options: { visible: true },
        lineBox: function() { return new Box(300, 100, 300, 300); }
    };

    axis = new RadarCategoryAxis(
        deepExtend({
            categories: ["Foo", "Bar", "Baz"]
        }, options)
    );
    axis.reflow(chartBox);
    axis.plotArea = {
        options: {},
        valueAxis: altAxis
    };

    axis.renderVisual();
}

function getAxisTextBoxes() {
    return map(axis.labels, function(item) {
        return item.visual;
    });
}

function getAxisTexts() {
    return map(getAxisTextBoxes(), function(item) {
        return last(item.children);
    });
}

// ------------------------------------------------------------
describe('Radar Category Axis / Rendering', () => {
    beforeEach(() => {
        createAxis();
    });

    it("line box equals box", () => {
        equal(axis.lineBox(), axis.box);
    });

    it("creates labels", 1, () => {
        equalTexts(getAxisTexts(), ["Foo", "Bar", "Baz"]);
    });

    it("creates labels with full format", 1, () => {
        createAxis({ categories: [1, 2], labels: { format: "{0:C}"} });

        equalTexts(getAxisTexts(), ["$1.00", "$2.00"]);
    });

    it("creates labels with simple format", 1, () => {
        createAxis({ categories: [1, 2], labels: { format: "C"} });

        equalTexts(getAxisTexts(), ["$1.00", "$2.00"]);
    });

    it("labels can be hidden", () => {
        createAxis({
            labels: {
                visible: false
            }
        });

        equal(axis.labels.length, 0);
    });

    it("labels have set template", 1, () => {
        createAxis({
            labels: {
                template: "|${ data.value }|"
            }
        });

        equal(getAxisTexts()[0].content(), "|Foo|");
    });

    it("labels have set color", 1, () => {
        createAxis({
            labels: {
                color: "#f00"
            }
        });

        equal(getAxisTexts()[0].options.fill.color, "#f00");
    });

    it("labels have set background", 1, () => {
        createAxis({
            labels: {
                background: "#f0f"
            }
        });

        equal(getAxisTextBoxes()[0].children[0].options.fill.color, "#f0f");
    });

    it("labels have set zIndex", 1, () => {
        createAxis({
            zIndex: 2
        });

        equal(getAxisTextBoxes()[0].options.zIndex, 2);
    });

    it("labels are distributed around axis (justified)", () => {
        closeTextPosition("", getAxisTexts(), [[289.5, 75], [482.535, 410], [92.795, 410]], TOLERANCE);
    });

    it("labels are distributed around axis (non-justified)", () => {
        createAxis({ justified: false });
        closeTextPosition("", getAxisTexts(), [[483, 175], [290.5, 510], [92.795, 175]], TOLERANCE);
    });

    it("applies skip when distributing labels", () => {
        createAxis({
            labels: {
                skip: 1
            }
        });
        closeTextPosition("", getAxisTexts(),  [[482.535, 410], [92.795, 410]], TOLERANCE);
    });

    it("applies step when distributing labels", () => {
        createAxis({
            labels: {
                step: 2
            }
        });
        closeTextPosition("", getAxisTexts(), [[289.5, 75], [92.795, 410]], TOLERANCE);
    });

    it("labels margin is applied", () => {
        createAxis({ labels: { margin: 5 } });

        closeTextPosition("", getAxisTexts(), [[289.5, 80], [478, 405], [97.795, 405]], TOLERANCE);
    });

    it("labels are distributed in reverse (justified)", () => {
        createAxis({ reverse: true });

        closeTextPosition("", getAxisTexts(), [[289.5, 75], [92.795, 410], [482.535, 410]], TOLERANCE);
    });

    it("labels are distributed in reverse (non-justified)", () => {
        createAxis({ justified: false, reverse: true });

        closeTextPosition("", getAxisTexts(), [[96, 175], [290.5, 510], [483, 175]], TOLERANCE);
    });
});

// ------------------------------------------------------------
describe('Radar Category Axis / Intervals', () => {
    beforeEach(() => {
        createAxis();
    });

    it("major intervals in normal order", () => {
        equal(axis.majorIntervals(), [ 0, 120, 240 ]);
    });

    it("major intervals in reverse order", () => {
        createAxis({ reverse: true });
        equal(axis.majorIntervals(), [ 0, 240, 120 ]);
    });

    it("minor intervals in normal order", () => {
        equal(axis.minorIntervals(), [ 0, 60, 120, 180, 240, 300 ]);
    });

    it("minor intervals in reverse order", () => {
        createAxis({ reverse: true });
        equal(axis.minorIntervals(), [ 0, 300, 240, 180, 120, 60 ]);
    });
});

// ------------------------------------------------------------
describe('Radar Category Axis / Slots', () => {
    let slot;

    beforeEach(() => {
        createAxis();
        slot = axis.getSlot(0);
    });

    it("slot center matches box center", () => {
        equal(slot.center.x, 300);
        equal(slot.center.y, 300);
    });

    it("slot inner radius is 0", () => {
        equal(slot.innerRadius, 0);
    });

    it("slot radius is half box height", () => {
        equal(slot.radius, 200);
    });

    it("slot angle for first category (justified)", () => {
        equal(slot.startAngle, 30);
        equal(slot.angle, 120);
    });

    it("slot angle for first category (non-justified)", () => {
        createAxis({ justified: false });

        slot = axis.getSlot(0);
        equal(slot.startAngle, 90);
        equal(slot.angle, 120);
    });

    it("slot for first category in reverse (justified)", () => {
        createAxis({ reverse: true });

        slot = axis.getSlot(0);
        equal(slot.startAngle, 30);
        equal(slot.angle, 120);
    });

    it("slot for first category in reverse (non-justified)", () => {
        createAxis({ reverse: true, justified: false });

        slot = axis.getSlot(0);
        equal(slot.startAngle, 330);
        equal(slot.angle, 120);
    });

    it("slot angle for second category (justified)", () => {
        slot = axis.getSlot(1);
        equal(slot.startAngle, 150);
        equal(slot.angle, 120);
    });

    it("slot angle for second category (non-justified)", () => {
        createAxis({ justified: false });

        slot = axis.getSlot(1);
        equal(slot.startAngle, 210);
        equal(slot.angle, 120);
    });

    it("slot for second category in reverse (justified)", () => {
        createAxis({ reverse: true });

        slot = axis.getSlot(1);
        equal(slot.startAngle, 270);
        equal(slot.angle, 120);
    });

    it("slot for second category in reverse (non-justified)", () => {
        createAxis({ reverse: true, justified: false });

        slot = axis.getSlot(1);
        equal(slot.startAngle, 210);
        equal(slot.angle, 120);
    });

    it("slot angle for last category (justified)", () => {
        slot = axis.getSlot(2);
        equal(slot.startAngle, 270);
        equal(slot.angle, 120);
    });

    it("slot angle for last category (non-justified)", () => {
        createAxis({ justified: false });

        slot = axis.getSlot(2);
        equal(slot.startAngle, 330);
        equal(slot.angle, 120);
    });

    it("slot for last category in reverse (justified)", () => {
        createAxis({ reverse: true });

        slot = axis.getSlot(2);
        equal(slot.startAngle, 150);
        equal(slot.angle, 120);
    });

    it("slot for last category in reverse (non-justified)", () => {
        createAxis({ reverse: true, justified: false });

        slot = axis.getSlot(2);
        equal(slot.startAngle, 90);
        equal(slot.angle, 120);
    });

    it("slot for two categories (justified)", () => {
        slot = axis.getSlot(0, 1);
        equal(slot.startAngle, 30);
        equal(slot.angle, 240);
    });

    it("slot for two categories (non-justified)", () => {
        createAxis({ justified: false });

        slot = axis.getSlot(0, 1);
        equal(slot.startAngle, 90);
        equal(slot.angle, 240);
    });

    it("assumes 1 category when no categories are defined (justified)", () => {
        createAxis({ categories: [] });

        slot = axis.getSlot(0);
        equal(slot.startAngle, 270);
        equal(slot.angle, 360);
    })

    it("assumes 1 category when no categories are defined (non-justified)", () => {
        createAxis({ categories: [], justified: false });

        slot = axis.getSlot(0);
        equal(slot.startAngle, 90);
        equal(slot.angle, 360);
    });

    it("reports range minimum of 0", () => {
        equal(axis.range().min, 0);
    });

    it("reports range maximum equal to category count", () => {
        equal(axis.range().max, 3);
    });

    it("from value can't be lower than 0", () => {
        slot = axis.getSlot(-1);
        equal(slot.startAngle, 30);
    });

    it("caps from value to categories count", () => {
        slot = axis.getSlot(1000);
        equal(slot.startAngle, 270);
    });

    it("to value equals from value when not set", () => {
        slot = axis.getSlot(1000);
        equal(slot.angle, 120);
    });

    it("to value equals from value when smaller", () => {
        slot = axis.getSlot(2, 1);
        equal(slot.startAngle, 270);
    });
});

// ------------------------------------------------------------
describe('Radar Category Axis / slot', () => {
    let slot, ring;

    beforeEach(() => {
        createAxis();
        slot = axis.slot(1, 2);
        ring = axis.getSlot(1, 2);
    });

    it("returns geom Arc", () => {
        ok(slot instanceof geom.Arc);
    });

    it("arc has same center and radius as the slot center and radius", () => {
        equal(slot.radiusX, ring.radius);
        equal(slot.radiusY, ring.radius);
        equal(slot.center.x, ring.center.x);
        equal(slot.center.y, ring.center.y);
    });

    it("arc start angle is equal to the slot start angle plus 180", () => {
        equal(slot.startAngle, ring.startAngle + 180);
    });

    it("arc end angle is equal to the slot start angle plus the slot angle plus 180", () => {
        equal(slot.endAngle, ring.startAngle + ring.angle + 180);
    });

});

// ------------------------------------------------------------
describe('Radar CategoryAxis / getCategory ', () => {
    beforeEach(() => {
        createAxis();
    });

    it("returns null for coordinates outside of circle", () => {
        equal(axis.getCategory(new Point(0, 0)), null);
    });

    it("returns first category for innermost point", () => {
        equal(axis.getCategory(new Point(300, 299)), "Foo");
    });

    it("returns second category for innermost point", () => {
        equal(axis.getCategory(new Point(301, 300)), "Bar");
    });

    it("returns third category for innermost point", () => {
        equal(axis.getCategory(new Point(299, 300)), "Baz");
    });
});

// ------------------------------------------------------------
describe('Radar CategoryAxis / getCategory / Reverse', () => {
    beforeEach(() => {
        createAxis({ reverse: true });
    });

    it("returns first category for innermost point", () => {
        equal(axis.getCategory(new Point(300, 299)), "Foo");
    });

    it("returns second category for innermost point", () => {
        equal(axis.getCategory(new Point(299, 300)), "Bar");
    });

    it("returns third category for innermost point", () => {
        equal(axis.getCategory(new Point(301, 300)), "Baz");
    });
});

// ------------------------------------------------------------

function setupGridLines(altAxis, axisOptions) {
    createAxis(axisOptions);
    gridLines = axis.createGridLines(altAxis);
}

describe('Radar Category Axis / Grid lines', () => {
    beforeEach(() => {
        setupGridLines(altAxis);
    });

    it("renders major grid lines by default", () => {
        equal(gridLines.length, 2);
    });

    it("major grid lines extend from axis center", () => {
        const anchor = gridLines[0].segments[0].anchor();
        equal(anchor.x, 300);
        equal(anchor.y, 300);
    });

    it("major grid lines extend to value axis end", () => {
        const anchor = gridLines[0].segments[1].anchor();
        close(anchor.x, 473, TOLERANCE);
        close(anchor.y, 400, TOLERANCE);
    });

    it("renders 90 degree grid line when value axis is not visible", () => {
        setupGridLines({
            options: { visible: false },
            lineBox: altAxis.lineBox
        });

        const anchor = gridLines[0].segments[1].anchor();
        close(anchor.x, 300, 0.1);
        close(anchor.y, 100, 0.1);
    });

    it("applies major grid line color", () => {
        setupGridLines(altAxis, { majorGridLines: { color: "red" } });

        equal(gridLines[0].options.stroke.color, "red");
    });

    it("applies major grid line width", () => {
        setupGridLines(altAxis, { majorGridLines: { width: 2 } });

        equal(gridLines[0].options.stroke.width, 2);
    });

    it("applies major grid line skip and step", () => {
        setupGridLines(altAxis, {
            categories: ["A", "B", "C", "D", "E"],
            majorGridLines: {
                skip: 2,
                step: 2
            }
        });

        equal(gridLines.length, 2);
        sameLinePath(gridLines[0], draw.Path.fromPoints([[300, 300], [418,  462]]), TOLERANCE);
        sameLinePath(gridLines[1], draw.Path.fromPoints([[300, 300], [110,  238]]), TOLERANCE);
    });

    it("renders minor grid lines", () => {
        setupGridLines(altAxis, {
            majorGridLines: {
                visible: false
            },
            minorGridLines: {
                visible: true
            }
        });

        equal(gridLines.length, 5);
    });

    it("renders minor grid lines to the alt axis if the alt axis type is line", () => {
        setupGridLines(deepExtend({
            options: {
                type: "line"
            }
        }, altAxis), {
            majorGridLines: {
                visible: false
            },
            minorGridLines: {
                visible: true
            }
        });
        const radius = 200;
        const minorAngle = 360 / (3 * 2);
        const minorRadius = Math.cos(rad(minorAngle)) * radius;

        for (let idx = 0; idx < 5; idx++) {
            const gridLine = gridLines[idx];
            const distance = gridLine.segments[0].anchor().distanceTo(gridLine.segments[1].anchor());
            if (idx % 2 !== 0) {
                close(distance, radius, 0.1);
            } else {
                close(distance, minorRadius, 0.1);
            }
        }
    });

    it("applies minor grid line color", () => {
        setupGridLines(altAxis, {
            majorGridLines: {
                visible: false
            },
            minorGridLines: {
                visible: true,
                color: "red"
            }
        });

        equal(gridLines[0].options.stroke.color, "red");
    });

    it("applies minor grid line width", () => {
        setupGridLines(altAxis, {
            majorGridLines: {
                visible: false
            },
            minorGridLines: {
                visible: true,
                width: 4
            }
        });

        equal(gridLines[0].options.stroke.width, 4);
    });

    it("applies minor grid lines skip and step", () => {
        setupGridLines(altAxis, {
            majorGridLines: {
                visible: false
            },
            minorGridLines: {
                visible: true,
                skip: 1,
                step: 2
            }
        });

        equal(gridLines.length, 3);
        sameLinePath(gridLines[0], draw.Path.fromPoints([[300, 300], [387,  250]]), TOLERANCE);
        sameLinePath(gridLines[1], draw.Path.fromPoints([[300, 300], [300,  400]]), TOLERANCE);
        sameLinePath(gridLines[2], draw.Path.fromPoints([[300, 300], [213,  250]]), TOLERANCE);
    });
});

// ------------------------------------------------------------
describe('Radar Category Axis / Grid lines / startAngle', () => {
    beforeEach(() => {
        setupGridLines(altAxis, { categories: ["A", "B", "C", "D"], startAngle: 80 });
    });

    it("major grid lines are offset with start angle", () => {
        const ref = Point.onCircle(center, 80, 200);
        const end = gridLines[0].segments[1].anchor();

        close(end.x, ref.x, 0.1);
        close(end.y, ref.y, 0.1);
    });

    it("renders 90 degree grid line as it no longer overlaps the value axis", () => {
        setupGridLines(altAxis, { categories: ["A", "B", "C", "D"], startAngle: 10 });

        equal(gridLines.length, 4);
    });
});

// ------------------------------------------------------------
describe('Radar Category Axis / Plot Bands', () => {
    beforeEach(() => {
        createAxis({
            plotBands: [{
                from: 0,
                to: 1,
                opacity: 0.5,
                color: "red"
            }, {
                from: 1.25,
                to: 1.75
            }, {
                from: 1.25,
                to: 2
            }, {
                from: 1,
                to: 1.75
            }, {
                from: 1,
                to: 2.5
            }]
        });
        plotBands = axis._plotbandGroup.children;
    });

    it("renders sectors", () => {
        equal(plotBands.length, 5);
    });

    it("renders sector with correct angles", () => {
        closePaths(plotBands[0], ShapeBuilder.current.createRing({
            startAngle: 30,
            angle: 120,
            radius: 200,
            center: {
                x: 300,
                y: 300
            }
        }));
    });

    it("renders sector with correct angles for partial slot (from & to)", () => {
        closePaths(plotBands[1], ShapeBuilder.current.createRing({
            startAngle: 180,
            angle: 60,
            radius: 200,
            center: {
                x: 300,
                y: 300
            }
        }));
    });

    it("renders sector with correct angles for partial slot (from)", () => {
        closePaths(plotBands[2], ShapeBuilder.current.createRing({
            startAngle: 180,
            angle: 90,
            radius: 200,
            center: {
                x: 300,
                y: 300
            }
        }));
    });

    it("renders sector with correct angles for partial slot (to)", () => {
        closePaths(plotBands[3], ShapeBuilder.current.createRing({
            startAngle: 150,
            angle: 90,
            radius: 200,
            center: {
                x: 300,
                y: 300
            }
        }));
    });

    it("renders sector with correct angles for long partial slot (to)", () => {
        closePaths(plotBands[4], ShapeBuilder.current.createRing({
            startAngle: 150,
            angle: 180,
            radius: 200,
            center: {
                x: 300,
                y: 300
            }
        }));
    });

    it("renders color", () => {
        equal(plotBands[0].options.fill.color, "red");
    });

    it("renders opacity", () => {
        equal(plotBands[0].options.fill.opacity, 0.5);
    });

    it("renders z index", () => {
        equal(axis._plotbandGroup.options.zIndex, -1);
    });
});

(function() {
    let chart, label, plotArea;

    function axisLabelClick(clickHandler, options) {
        chart = createChart(deepExtend({            
            series: [{
                type: "radarColumn",
                field: "value",
                categoryField: "category",
                data: [{
                    value: 1,
                    category: "A"
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 3,
                    category: "C"
                }]
            }],
            categoryAxis: {
                name: "Axis A"
            },
            axisLabelClick: clickHandler
        }, options));

        plotArea = chart._model.children[1];
        label = getChartDomElement(plotArea.categoryAxis.labels[1]);
        clickChart(chart, label);
    }

    // ------------------------------------------------------------
    describe('Radar Category Axis / Events / axisLabelClick', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when clicking axis labels", 1, () => {
            axisLabelClick(function() { ok(true); });
        });

        it("event arguments contain axis options", 1, () => {
            axisLabelClick(function(e) {
                equal(e.axis.type, "category");
            });
        });

        it("event arguments contain DOM element", 1, () => {
            axisLabelClick(function(e) {
                ok(e.element === label);
            });
        });

        it("event arguments contain category index", 1, () => {
            axisLabelClick(function(e) {
                equal(e.index, 1);
            });
        });

        it("category index is correct when step is defined", 1, () => {
            axisLabelClick(function(e) {
                equal(e.index, 2);
            }, {
                categoryAxis: {
                    labels: {
                        step: 2
                    }
                }
            });
        });

        it("event arguments contain category name as text", 1, () => {
            axisLabelClick(function(e) {
                equal(e.text, "B");
            });
        });

        it("event arguments contain category name as value", 1, () => {
            axisLabelClick(function(e) {
                equal(e.value, "B");
            });
        });

        it("event arguments contain category data item", 1, () => {
            axisLabelClick(function(e) {
                equal(e.dataItem.value, 2);
            });
        });
    });

})();

(function() {
    let chart, plotArea;

    function createBoundChart(options) {
        chart = createChart(deepExtend({            
            series: [{
                type: "radarColumn",
                field: "value",
                categoryField: "category",
                data: [{
                    value: 1,
                    category: "A"
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 3,
                    category: "C"
                }]
            }],
            categoryAxis: {
                name: "Axis A"
            }
        }, options));

        plotArea = chart._model.children[1];
    }

    // ------------------------------------------------------------
    describe('Radar Category Axis / Data Binding', () => {

        afterEach(() => {
            destroyChart(chart);
        });

        it("categories are data bound", () => {
            createBoundChart();
            equal(plotArea.categoryAxis.labels.length, 3);
        });

        it("template has access to data item", () => {
            createBoundChart({
                categoryAxis: {
                    labels: {
                        template: function(data) {
                            ok(typeof data.dataItem.value == 'number');
                        }
                    }
                }
            });
        });
    });

})();
