import 'core-js/es6';

import { RadarNumericAxis, ShapeBuilder, Box, Point } from '../../src/core';
import RadarPlotArea from '../../src/chart/plotarea/radar-plotarea';

import { deepExtend } from '../../src/common';

import { ok, equal, close, arrayClose, mapSegments, closePaths } from '../../test/test-helpers';

import { clickChart, createChart, destroyChart, getChartDomElement }  from '../test-helpers';

const chartBox = new Box(100, 100, 500, 500);
const center = new Point(300, 300);
const TOLERANCE = 1;
let axis, altAxis, gridLines, plotBands;

function createAxis(options) {
    altAxis = {
        box: chartBox,
        majorIntervals: function() {
            return [90, 210, 330];
        },
        majorAngles: function() {
            return this.majorIntervals();
        }
    };

    axis = new RadarNumericAxis(1, 3,
        deepExtend({
            min: 0,
            max: 3,
            majorUnit: 1
        }, options)
    );

    axis.reflow(new Box(300, 0, 300, 300));
    axis.plotArea = {
        options: {},
        polarAxis: altAxis
    };

    axis.renderVisual();
}

// ------------------------------------------------------------

function setupGridLines(axisOptions) {
    createAxis(axisOptions);
    gridLines = axis.createGridLines(altAxis);
}

describe('Radar Numeric Axis / Grid lines', () => {
    beforeEach(() => {
        setupGridLines();
    });

    it("renders major grid lines by default", () => {
        equal(gridLines.length, 4);
    });

    it("points are placed on alt axis intervals", () => {
        const segments = gridLines[0].segments;

        close(segments[0].anchor().x, 300, TOLERANCE);
        close(segments[0].anchor().y, 299, TOLERANCE);

        close(segments[1].anchor().x, 300, TOLERANCE);
        close(segments[1].anchor().y, 300, TOLERANCE);

        close(segments[2].anchor().x, 299, TOLERANCE);
        close(segments[2].anchor().y, 300, TOLERANCE);
    });

    it("applies major grid line color", () => {
        setupGridLines({ majorGridLines: { color: "red" } });

        equal(gridLines[0].options.stroke.color, "red");
    });

    it("applies major grid line width", () => {
        setupGridLines({ majorGridLines: { width: 2 } });

        equal(gridLines[0].options.stroke.width, 2);
    });

    it("renders minor grid lines", () => {
        setupGridLines({
            majorGridLines: {
                visible: false
            },
            minorGridLines: {
                visible: true
            }
        });

        equal(gridLines.length, 16);
    });

    it("applies minor grid line color", () => {
        setupGridLines({
            majorGridLines: {
                visible: false
            },
            minorGridLines: {
                visible: true,
                color: "red"
            }
        });

        equal(gridLines[0].options.stroke.color, "red");
    });

    it("applies minor grid line width", () => {
        setupGridLines({
            majorGridLines: {
                visible: false
            },
            minorGridLines: {
                visible: true,
                width: 4
            }
        });

        equal(gridLines[0].options.stroke.width, 4);
    });
});

// ------------------------------------------------------------
describe('Radar Numeric Axis / Grid arcs', () => {
    beforeEach(() => {
        setupGridLines({
            majorGridLines: {
                type: "arc"
            }
        });
    });

    it("renders major grid arcs", () => {
        equal(gridLines.length, 4);
    });

    it("circle center is on alt axis center", () => {
        const c = gridLines[0].geometry().center;

        close(c.x, 300, TOLERANCE);
        close(c.y, 300, TOLERANCE);
    });

    it("circle radius matches value", () => {
        close(gridLines[0].geometry().radius, 1, TOLERANCE);
        close(gridLines[1].geometry().radius, 100, TOLERANCE);
        close(gridLines[2].geometry().radius, 200, TOLERANCE);
        close(gridLines[3].geometry().radius, 300, TOLERANCE);
    });

    it("applies major grid line color", () => {
        setupGridLines({ majorGridLines: { type: "arc", color: "red" } });

        equal(gridLines[0].options.stroke.color, "red");
    });

    it("applies major grid line width", () => {
        setupGridLines({ majorGridLines: { type: "arc", width: 2 } });

        equal(gridLines[0].options.stroke.width, 2);
    });

    it("renders minor grid arcs", () => {
        setupGridLines({
            majorGridLines: {
                visible: false
            },
            minorGridLines: {
                type: "arc",
                visible: true
            }
        });

        equal(gridLines.length, 16);
    });

    it("applies minor grid line color", () => {
        setupGridLines({
            majorGridLines: { visible: false },
            minorGridLines: { visible: true, type: "arc", color: "red" }
        });

        equal(gridLines[0].options.stroke.color, "red");
    });

    it("applies minor grid line width", () => {
        setupGridLines({
            majorGridLines: { visible: false },
            minorGridLines: { visible: true, type: "arc", width: 2 }
        });

        equal(gridLines[0].options.stroke.width, 2);
    });
});

// ------------------------------------------------------------
describe('Radar Numeric Axis / Plot Bands / Polygons', () => {
    beforeEach(() => {
        createAxis({
            line: {
                visible: false
            },
            majorTicks: {
                visible: false
            },
            plotBands: [{
                from: 0,
                to: 1,
                opacity: 0.5,
                color: "red"
            }]
        });
        plotBands = axis._plotbandGroup.children;
    });

    it("renders polygon", () => {
        equal(plotBands[0].segments.length, 8);
    });

    it("polygon is closed", () => {
        equal(plotBands[0].options.closed, true);
    });

    it("polygon points are on circle", () => {
        arrayClose(mapSegments(plotBands[0].segments), [
            [300, 200], [387, 350], [212, 350], [300, 200],
            [300, 300], [300, 300], [300, 300], [300, 300]
        ], TOLERANCE);
    });

    it("renders color", () => {
        equal(plotBands[0].options.fill.color, "red");
    });

    it("renders opacity", () => {
        equal(plotBands[0].options.fill.opacity, 0.5);
    });

    it("renders z index", () => {
        equal(axis._plotbandGroup.options.zIndex, -1);
    });
});

// ------------------------------------------------------------
describe('Radar Numeric Axis / Plot Bands / Arcs', () => {
    beforeEach(() => {
        createAxis({
            majorGridLines: {
                type: "arc"
            },
            plotBands: [{
                from: 1,
                to: 2,
                opacity: 0.5,
                color: "red"
            }]
        });
        plotBands = axis._plotbandGroup.children;
    });

    it("renders ring", () => {
        equal(plotBands.length, 1);
        closePaths(plotBands[0], ShapeBuilder.current.createRing({
            angle: 360,
            startAngle: 0,
            center: {
                x: 300,
                y: 300
            },
            innerRadius: 100,
            radius: 200
        }), TOLERANCE);
    });

    it("renders color", () => {
        equal(plotBands[0].options.fill.color, "red");
    });

    it("renders opacity", () => {
        equal(plotBands[0].options.fill.opacity, 0.5);
    });

    it("renders z index", () => {
        equal(axis._plotbandGroup.options.zIndex, -1);
    });
});

// ------------------------------------------------------------
describe('Radar Numeric Axis / getValue', () => {
    beforeEach(() => {
        createAxis();
    });

    it("value for point on axis", () => {
        const p = Point.onCircle(center, 90, 100);
        close(axis.getValue(p), 1, 0.02);
    });

    it("value for point on major gridline", () => {
        const p = Point.onCircle(center, 210, 100);
        close(axis.getValue(p), 1, 0.02);
    });

    it("value for point between gridlines (middle)", () => {
        const p = Point.onCircle(center, 135, 51);
        close(axis.getValue(p), 1, 0.02);
    });

    it("value for point between gridlines (near first)", () => {
        const p = Point.onCircle(center, 110, 65);
        close(axis.getValue(p), 1, 0.02);
    });

    it("value for point between gridlines (near second)", () => {
        const p = Point.onCircle(center, 190, 65);
        close(axis.getValue(p), 1, 0.02);
    });
});

// ------------------------------------------------------------
describe('Radar Numeric Axis / getValue / Arcs', () => {
    beforeEach(() => {
        createAxis({
            majorGridLines: {
                type: "arc"
            }
        });
    });

    it("value for point on axis", () => {
        const p = Point.onCircle(center, 90, 100);
        close(axis.getValue(p), 1, 0.02);
    });

    it("value for point on gridline", () => {
        const p = Point.onCircle(center, 210, 100);
        close(axis.getValue(p), 1, 0.02);
    })

    it("value for point between gridline", () => {
        const p = Point.onCircle(center, 145, 100);
        close(axis.getValue(p), 1, 0.02);
    });
});

(function() {
    let chart, label, plotArea;

    function axisLabelClick(clickHandler, options) {
        chart = createChart(deepExtend({
            series: [{
                type: "radarColumn",
                field: "value"
            }],
            axisLabelClick: clickHandler
        }, options));

        plotArea = chart._model.children[1];
        label = getChartDomElement(plotArea.valueAxis.labels[1]);
        clickChart(chart, label);
    }

    // ------------------------------------------------------------
    describe('Radar Numeric Axis / Events / axisLabelClick', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when clicking axis labels", 1, () => {
            axisLabelClick(function() { ok(true); });
        });

        it("event arguments contain axis options", 1, () => {
            axisLabelClick(function(e) {
                equal(e.axis.type, "numeric");
            });
        });

        it("event arguments contain DOM element", 1, () => {
            axisLabelClick(function(e) {
                ok(e.element === label);
            });
        });

        it("event arguments contain index", 1, () => {
            axisLabelClick(function(e) {
                equal(e.index, 1);
            });
        });

        it("event arguments contain value", 1, () => {
            axisLabelClick(function(e) {
                equal(e.value, 0.2);
            });
        });
    });
})();
