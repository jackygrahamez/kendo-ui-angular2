import 'core-js/es6';

import { RootElement, Box } from '../../src/core';
import AreaChart from '../../src/chart/area-chart/area-chart';

import { deepExtend } from '../../src/common';

import { ok, equal, mapSegments } from '../../test/test-helpers';
    
const chartBox = new Box(0, 0, 800, 600);
const positiveSeries = { data: [1, 2], labels: {}, line: { style: "step" } };
const negativeSeries = { data: [-1, -2], labels: {}, line: { style: "step" } };
const sparseSeries = { data: [1, 2, undefined, 2], line: { style: "step" } };
const VALUE_AXIS_MAX = 2;
const CATEGORY_AXIS_Y = 2;
const TOLERANCE = 1;

let areaChart, root, pointCoordinates;

function segmentPaths() {
    return areaChart._segments[0].visual.children;
}

function getAreaPath(areaChart) {
    return segmentPaths()[0];
}

function setupStepAreaChart(plotArea, options) {
    areaChart = new AreaChart(plotArea, options);

    root = new RootElement();
    root.append(areaChart);
    root.reflow();

    root.renderVisual();
    pointCoordinates = mapSegments(getAreaPath(areaChart).segments);
}

function stubPlotArea(getCategorySlot, getValueSlot, options) {
    return new function() {
        this.categoryAxis = this.primaryCategoryAxis = {
            getSlot: getCategorySlot,
            lineBox: function() {
                return new Box(0,2,2,2);
            },
            options: {
                categories: ["A", "B"]
            }
        };

        this.valueAxis = {
            getSlot: getValueSlot,
            lineBox: function() {
                return new Box(0,0,0,2);
            },
            options: {},
            startValue: function() {
                return 0;
            }
        };

        this.namedCategoryAxes = {};
        this.namedValueAxes = {};

        this.seriesCategoryAxis = function(series) {
            return series.categoryAxis ?
                this.namedCategoryAxes[series.categoryAxis] : this.primaryCategoryAxis;
        };

        this.options = options;
    };
}



const plotArea = stubPlotArea(
    function(categoryIndex) {
        return new Box(categoryIndex, CATEGORY_AXIS_Y, categoryIndex + 1, CATEGORY_AXIS_Y);
    },
    function(value = 0) {        
        const valueY = VALUE_AXIS_MAX - value;
        const slotTop = Math.min(CATEGORY_AXIS_Y, valueY);
        const slotBottom = Math.max(CATEGORY_AXIS_Y, valueY);

        return new Box(0, slotTop, 0, slotBottom);
    }
);

// ------------------------------------------------------------
describe('Step Area Chart / Stack / Missing values', () => {
    beforeEach(() => {
        sparseSeries.line = { width: 0, style: "step" };
        setupStepAreaChart(plotArea, {
            series: [ sparseSeries, sparseSeries ],
            isStacked: true
        });
    });

    it("line is drawn between existing points when interpolating", () => {
        setupStepAreaChart(plotArea, {
            series: [
                deepExtend({ missingValues: "interpolate" }, sparseSeries)
            ],
            isStacked: true
        });

        equal(pointCoordinates, [
            [ 0, 2 ], [ 0, 1 ], [ 1, 1 ], [ 1, 1 ], [ 1, 0 ], [ 2, 0 ],
            [ 1, 0 ], [ 2, 0 ], [ 3, 0 ], [ 3, 0 ], [ 4, 0 ], [ 4, 2 ]
        ]);
    });
});

// ------------------------------------------------------------
describe("Step Area Chart / Rendering / Missing Values", () => {
    beforeEach(() => {
        sparseSeries.line = { width: 0, style: "step" };
    });

    it("area stops before missing value", () => {
        setupStepAreaChart(plotArea, {
            series: [
                deepExtend({ missingValues: "gap" }, sparseSeries)
            ]
        });

        equal(pointCoordinates, [
            [ 0, 2 ], [ 0, 1 ], [ 1, 1 ],
            [ 1, 0 ], [ 2, 0 ], [ 2, 2 ]
        ]);
    });

    it("area continues after missing value", () => {
        setupStepAreaChart(plotArea, {
            series: [{
                missingValues: "gap",
                data: [ null, 1, 2 ],
                line: { width: 0, style: "step" }
            }]
        });

        equal(pointCoordinates, [
            [ 1, 2 ], [ 1, 1 ], [ 2, 1 ],
            [ 2, 0 ], [ 3, 0 ], [ 3, 2 ]
        ]);
    });

    it("area is drawn between existing points", () => {
        setupStepAreaChart(plotArea, {
            series: [
                deepExtend({ missingValues: "interpolate" }, sparseSeries)
            ]
        });

        equal(pointCoordinates, [
            [ 0, 2 ], [ 0, 1 ], [ 1, 1 ], [ 1, 1 ],
            [ 1, 0 ], [ 2, 0 ], [ 1, 0 ], [ 2, 0 ],
            [ 3, 0 ], [ 3, 0 ], [ 4, 0 ], [ 4, 2 ]
        ]);
    });

    it("area goes to zero for missing point", () => {
        setupStepAreaChart(plotArea, {
            series: [
                deepExtend({ missingValues: "zero" }, sparseSeries)
            ]
        });

        equal(pointCoordinates, [
            [ 0, 2 ], [ 0, 1 ], [ 1, 1 ], [ 1, 0 ], [ 2, 0 ], [ 1, 0 ], [ 2, 0 ],
            [ 2, 2 ], [ 3, 2 ], [ 2, 2 ], [ 3, 2 ], [ 3, 0 ], [ 4, 0 ], [ 4, 2 ]
        ]);
    });
});
