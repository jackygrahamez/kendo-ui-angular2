module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(161);


/***/ },

/***/ 5:
/***/ function(module, exports) {

	module.exports = require("../../common/constants");

/***/ },

/***/ 13:
/***/ function(module, exports) {

	module.exports = require("../../common/is-function");

/***/ },

/***/ 23:
/***/ function(module, exports) {

	module.exports = require("@progress/kendo-drawing");

/***/ },

/***/ 25:
/***/ function(module, exports) {

	module.exports = require("../../common/set-default-options");

/***/ },

/***/ 50:
/***/ function(module, exports) {

	module.exports = require("../../common/deep-extend");

/***/ },

/***/ 52:
/***/ function(module, exports) {

	module.exports = require("../../common/limit-value");

/***/ },

/***/ 55:
/***/ function(module, exports) {

	module.exports = require("../../core");

/***/ },

/***/ 63:
/***/ function(module, exports) {

	module.exports = require("../utils/color");

/***/ },

/***/ 69:
/***/ function(module, exports) {

	module.exports = require("../../common/template");

/***/ },

/***/ 86:
/***/ function(module, exports) {

	module.exports = require("../../common/auto-format");

/***/ },

/***/ 158:
/***/ function(module, exports) {

	module.exports = require("../series-binder");

/***/ },

/***/ 161:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _kendoDrawing = __webpack_require__(23);

	var _core = __webpack_require__(55);

	var _pieChartMixin = __webpack_require__(162);

	var _pieChartMixin2 = _interopRequireDefault(_pieChartMixin);

	var _seriesBinder = __webpack_require__(158);

	var _seriesBinder2 = _interopRequireDefault(_seriesBinder);

	var _funnelSegment = __webpack_require__(163);

	var _funnelSegment2 = _interopRequireDefault(_funnelSegment);

	var _seriesTotal = __webpack_require__(164);

	var _seriesTotal2 = _interopRequireDefault(_seriesTotal);

	var _evalOptions = __webpack_require__(165);

	var _evalOptions2 = _interopRequireDefault(_evalOptions);

	var _segmentVisible = __webpack_require__(166);

	var _segmentVisible2 = _interopRequireDefault(_segmentVisible);

	var _color = __webpack_require__(63);

	var _color2 = _interopRequireDefault(_color);

	var _constants = __webpack_require__(5);

	var _deepExtend = __webpack_require__(50);

	var _deepExtend2 = _interopRequireDefault(_deepExtend);

	var _autoFormat = __webpack_require__(86);

	var _autoFormat2 = _interopRequireDefault(_autoFormat);

	var _isFunction = __webpack_require__(13);

	var _isFunction2 = _interopRequireDefault(_isFunction);

	var _template = __webpack_require__(69);

	var _template2 = _interopRequireDefault(_template);

	var _limitValue = __webpack_require__(52);

	var _limitValue2 = _interopRequireDefault(_limitValue);

	var _setDefaultOptions = __webpack_require__(25);

	var _setDefaultOptions2 = _interopRequireDefault(_setDefaultOptions);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var FunnelChart = function (_ChartElement) {
	    _inherits(FunnelChart, _ChartElement);

	    function FunnelChart(plotArea, options) {
	        _classCallCheck(this, FunnelChart);

	        var _this = _possibleConstructorReturn(this, (FunnelChart.__proto__ || Object.getPrototypeOf(FunnelChart)).call(this, options));

	        _this.plotArea = plotArea;
	        _this.points = [];
	        _this.labels = [];
	        _this.legendItems = [];
	        _this.render();
	        return _this;
	    }

	    _createClass(FunnelChart, [{
	        key: 'formatPointValue',
	        value: function formatPointValue(point, format) {
	            return (0, _autoFormat2.default)(format, point.value);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var options = this.options;
	            var _plotArea$options$ser = this.plotArea.options.seriesColors;
	            var seriesColors = _plotArea$options$ser === undefined ? [] : _plotArea$options$ser;

	            var series = options.series[0];
	            var data = series.data;

	            if (!data) {
	                return;
	            }

	            var total = (0, _seriesTotal2.default)(series);

	            for (var i = 0; i < data.length; i++) {
	                var pointData = _seriesBinder2.default.current.bindPoint(series, i);
	                var value = pointData.valueFields.value;

	                if (value === null || value === undefined) {
	                    continue;
	                }

	                var fields = pointData.fields;

	                if (!(0, _isFunction2.default)(series.color)) {
	                    series.color = fields.color || seriesColors[i % seriesColors.length];
	                }

	                var visible = (0, _segmentVisible2.default)(series, fields, i);
	                fields = (0, _deepExtend2.default)({
	                    index: i,
	                    owner: this,
	                    series: series,
	                    dataItem: data[i],
	                    percentage: Math.abs(value) / total
	                }, fields, { visible: visible });

	                var segment = this.createSegment(value, fields);
	                var label = this.createLabel(value, fields);

	                if (segment && label) {
	                    segment.append(label);
	                }
	            }
	        }
	    }, {
	        key: 'evalSegmentOptions',
	        value: function evalSegmentOptions(options, value, fields) {
	            var series = fields.series;

	            (0, _evalOptions2.default)(options, {
	                value: value,
	                series: series,
	                dataItem: fields.dataItem,
	                index: fields.index
	            }, { defaults: series._defaults, excluded: ["data", "toggle", "visual"] });
	        }
	    }, {
	        key: 'createSegment',
	        value: function createSegment(value, fields) {
	            var seriesOptions = (0, _deepExtend2.default)({}, fields.series);
	            this.evalSegmentOptions(seriesOptions, value, fields);

	            this.createLegendItem(value, seriesOptions, fields);

	            if (fields.visible !== false) {

	                var segment = new _funnelSegment2.default(value, seriesOptions, fields);
	                Object.assign(segment, fields);

	                this.append(segment);
	                this.points.push(segment);

	                return segment;
	            }
	        }
	    }, {
	        key: 'createLabel',
	        value: function createLabel(value, fields) {
	            var series = fields.series;
	            var dataItem = fields.dataItem;

	            var labels = (0, _deepExtend2.default)({}, this.options.labels, series.labels);
	            var text = value;

	            if (labels.visible) {
	                if (labels.template) {
	                    var labelTemplate = (0, _template2.default)(labels.template);
	                    text = labelTemplate({
	                        dataItem: dataItem,
	                        value: value,
	                        percentage: fields.percentage,
	                        category: fields.category,
	                        series: series
	                    });
	                } else if (labels.format) {
	                    text = (0, _autoFormat2.default)(labels.format, text);
	                }

	                if (!labels.color && labels.align === _constants.CENTER) {
	                    var brightnessValue = new _color2.default(series.color).percBrightness();
	                    if (brightnessValue > 180) {
	                        labels.color = _constants.BLACK;
	                    } else {
	                        labels.color = _constants.WHITE;
	                    }
	                }

	                this.evalSegmentOptions(labels, value, fields);
	                var textBox = new _core.TextBox(text, (0, _deepExtend2.default)({
	                    vAlign: labels.position
	                }, labels));

	                this.labels.push(textBox);

	                return textBox;
	            }
	        }
	    }, {
	        key: 'labelPadding',
	        value: function labelPadding() {
	            var labels = this.labels;
	            var padding = { left: 0, right: 0 };

	            for (var i = 0; i < labels.length; i++) {
	                var label = labels[i];
	                var align = label.options.align;
	                if (align !== _constants.CENTER) {
	                    var width = labels[i].box.width();

	                    if (align === _constants.LEFT) {
	                        padding.left = Math.max(padding.left, width);
	                    } else {
	                        padding.right = Math.max(padding.right, width);
	                    }
	                }
	            }

	            return padding;
	        }
	    }, {
	        key: 'dynamicSlopeReflow',
	        value: function dynamicSlopeReflow(box, width, totalHeight) {
	            var options = this.options;
	            var segments = this.points;

	            var count = segments.length;
	            var firstSegment = segments[0];
	            var maxSegment = firstSegment;

	            for (var idx = 0; idx < segments.length; idx++) {
	                if (segments[idx].percentage > maxSegment.percentage) {
	                    maxSegment = segments[idx];
	                }
	            }

	            var lastUpperSide = firstSegment.percentage / maxSegment.percentage * width;
	            var previousOffset = (width - lastUpperSide) / 2;
	            var previousHeight = 0;

	            for (var _idx = 0; _idx < count; _idx++) {
	                var percentage = segments[_idx].percentage;
	                var nextSegment = segments[_idx + 1];
	                var nextPercentage = nextSegment ? nextSegment.percentage : percentage;
	                var points = segments[_idx].points = [];
	                var height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;
	                var offset = void 0;

	                if (!percentage) {
	                    offset = nextPercentage ? 0 : width / 2;
	                } else {
	                    offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;
	                }

	                offset = (0, _limitValue2.default)(offset, 0, width);

	                points.push(new _kendoDrawing.geometry.Point(box.x1 + previousOffset, box.y1 + previousHeight));
	                points.push(new _kendoDrawing.geometry.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));
	                points.push(new _kendoDrawing.geometry.Point(box.x1 + width - offset, box.y1 + height + previousHeight));
	                points.push(new _kendoDrawing.geometry.Point(box.x1 + offset, box.y1 + height + previousHeight));

	                previousOffset = offset;
	                previousHeight += height + options.segmentSpacing;
	                lastUpperSide = (0, _limitValue2.default)(width - 2 * offset, 0, width);
	            }
	        }
	    }, {
	        key: 'constantSlopeReflow',
	        value: function constantSlopeReflow(box, width, totalHeight) {
	            var options = this.options;
	            var segments = this.points;

	            var count = segments.length;
	            var decreasingWidth = options.neckRatio <= 1;
	            var neckRatio = decreasingWidth ? options.neckRatio * width : width;
	            var topMostWidth = decreasingWidth ? width : width - previousOffset * 2;
	            var finalNarrow = (topMostWidth - neckRatio) / 2;
	            var previousOffset = decreasingWidth ? 0 : (width - width / options.neckRatio) / 2;
	            var previousHeight = 0;

	            for (var idx = 0; idx < count; idx++) {
	                var points = segments[idx].points = [];
	                var percentage = segments[idx].percentage;
	                var offset = options.dynamicHeight ? finalNarrow * percentage : finalNarrow / count;
	                var height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;

	                points.push(new _kendoDrawing.geometry.Point(box.x1 + previousOffset, box.y1 + previousHeight));
	                points.push(new _kendoDrawing.geometry.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));
	                points.push(new _kendoDrawing.geometry.Point(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));
	                points.push(new _kendoDrawing.geometry.Point(box.x1 + previousOffset + offset, box.y1 + height + previousHeight));
	                previousOffset += offset;
	                previousHeight += height + options.segmentSpacing;
	            }
	        }
	    }, {
	        key: 'reflow',
	        value: function reflow(chartBox) {
	            var points = this.points;
	            var count = points.length;

	            if (!count) {
	                return;
	            }

	            var options = this.options;
	            var box = chartBox.clone().unpad(this.labelPadding());
	            var totalHeight = box.height() - options.segmentSpacing * (count - 1);
	            var width = box.width();

	            if (options.dynamicSlope) {
	                this.dynamicSlopeReflow(box, width, totalHeight);
	            } else {
	                this.constantSlopeReflow(box, width, totalHeight);
	            }

	            for (var idx = 0; idx < count; idx++) {
	                points[idx].reflow(chartBox);
	            }
	        }
	    }]);

	    return FunnelChart;
	}(_core.ChartElement);

	(0, _setDefaultOptions2.default)(FunnelChart.prototype, {
	    neckRatio: 0.3,
	    width: 300,
	    dynamicSlope: false,
	    dynamicHeight: true,
	    segmentSpacing: 0,
	    labels: {
	        visible: false,
	        align: _constants.CENTER,
	        position: _constants.CENTER
	    }
	});

	(0, _deepExtend2.default)(FunnelChart.prototype, _pieChartMixin2.default);

	exports.default = FunnelChart;

/***/ },

/***/ 162:
/***/ function(module, exports) {

	module.exports = require("../mixins/pie-chart-mixin");

/***/ },

/***/ 163:
/***/ function(module, exports) {

	module.exports = require("./funnel-segment");

/***/ },

/***/ 164:
/***/ function(module, exports) {

	module.exports = require("../utils/series-total");

/***/ },

/***/ 165:
/***/ function(module, exports) {

	module.exports = require("../utils/eval-options");

/***/ },

/***/ 166:
/***/ function(module, exports) {

	module.exports = require("../utils/segment-visible");

/***/ }

/******/ });