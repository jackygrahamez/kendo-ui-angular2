import 'core-js/es6';
import { drawing as draw } from '@progress/kendo-drawing';
import { $ } from 'e2e-utils';

import AreaChart from '../../src/chart/area-chart/area-chart';
import LineChart from '../../src/chart/line-chart/line-chart';
import WaterfallChart from '../../src/chart/waterfall-chart/waterfall-chart';
import BarChart from '../../src/chart/bar-chart/bar-chart';
import RangeBarChart from '../../src/chart/range-bar-chart/range-bar-chart';
import LinePoint from '../../src/chart/line-chart/line-point';
import Bar from '../../src/chart/bar-chart/bar';

import CategoricalPlotArea from '../../src/chart/plotarea/categorical-plotarea';
import { Box } from '../../src/core';
import { deepExtend, inArray, round } from '../../src/common';

import { ok, equal, close, sameBox, sameRectPath, arrayClose, createSpy, stubMethod } from '../../test/test-helpers';
import { clickChart, triggerEvent, createChart, destroyChart, getChartDomElement }  from '../test-helpers';
import '../../test/text-measure';

const SANS = "Arial,Helvetica,sans-serif";
const SANS12 = "12px " + SANS;
const chartBox = new Box(100, 100, 1000, 1000);
const TOLERANCE = 1;
const MARGIN = 10;
const GAP = 4;
const SPACING = 1;
let chartSeries;

(function() {
    const barSeriesData = [{
        name: "Value A",
        type: "bar",
        data: [100, 200, 300],
        gap: GAP,
        spacing: SPACING
    }, {
        name: "Value B",
        type: "bar",
        data: [10, 20, 30]
    }];
    const columnSeriesData = [{
        name: "Value A",
        type: "column",
        data: [100, 200, 300],
        gap: GAP,
        spacing: SPACING
    }, {
        name: "Value B",
        type: "column",
        data: [10, 20, 30]
    }];
    const rangeColumnSeriesData = [{
        name: "Value A",
        type: "rangeColumn",
        data: [[100, 110], [200, 220], [300, 330]],
        gap: GAP,
        spacing: SPACING
    }, {
        name: "Value B",
        type: "rangeColumn",
        data: [[10, 11], [20, 22], [30, 33]]
    }];
    const rangeBarSeriesData = [{
        name: "Value A",
        type: "rangeBar",
        data: [[100, 110], [200, 220], [300, 330]],
        gap: GAP,
        spacing: SPACING
    }, {
        name: "Value B",
        type: "rangeBar",
        data: [[10, 11], [20, 22], [30, 33]]
    }];
    const lineSeriesData = [{
        name: "Value A",
        type: "line",
        data: [100, 200, 300]
    }, {
        name: "Value B",
        type: "line",
        data: [10, 20, 30]
    }];
    const verticalLineSeriesData = [{
        name: "Value A",
        type: "verticalLine",
        data: [100, 200, 300]
    }, {
        name: "Value B",
        type: "verticalLine",
        data: [10, 20, 30]
    }];
    const areaSeriesData = [{
        name: "Value A",
        type: "area",
        data: [100, 200, 300]
    }, {
        name: "Value B",
        type: "area",
        data: [10, 20, 30]
    }];
    const verticalAreaSeriesData = [{
        name: "Value A",
        type: "verticalArea",
        data: [100, 200, 300]
    }, {
        name: "Value B",
        type: "verticalArea",
        data: [10, 20, 30]
    }];
    let plotArea,
        categoryAxis,
        namedCategoryAxes,
        secondaryCategoryAxis,
        namedValueAxes,
        valueAxis,
        secondaryValueAxis;

    function createPlotArea(series, options) {
        plotArea = new CategoricalPlotArea(series,
            deepExtend({
            categoryAxis: {
                categories: ["A", "B", "C"]
            }
        }, options));

        categoryAxis = plotArea.categoryAxis;
        valueAxis = plotArea.valueAxis;
        namedCategoryAxes = plotArea.namedCategoryAxes;
        secondaryCategoryAxis = namedCategoryAxes.secondary;
        namedValueAxes = plotArea.namedValueAxes;
        secondaryValueAxis = namedValueAxes.secondary;

        chartSeries = plotArea.charts[0];
    }

    function renderPlotArea(series, options) {
        createPlotArea(series, options);
        plotArea.reflow(chartBox);
        plotArea.renderVisual();
    }

    function assertAxisRange(axis, min, max, series, options) {
        const fn = CategoricalPlotArea.prototype;
        stubMethod(fn, "createValueAxes",
            function(panes) {
                fn._stubbed["createValueAxes"].call(this, panes);
                equal(this[axis].options.min, min);
                equal(this[axis].options.max, max);
            },
            function() {
                plotArea = createPlotArea(series, options);
            }
        );
    }

    function assertStackedSeries(seriesType) {
        // ------------------------------------------------------------
        describe('Categorical PlotArea / Stacked " + seriesType + " series', () => {

            it("sets isStacked when first series is stacked", () => {
                createPlotArea([{
                    type: seriesType, data: [], stack: true
                }, {
                    type: seriesType, data: []
                }]);

                ok(chartSeries.options.isStacked);
            });

            it("sets isStacked and isStacked100 when first series is 100% stacked", () => {
                createPlotArea([{
                    type: seriesType, data: [], stack: { type: "100%" }
                }, {
                    type: seriesType, data: []
                }]);

                ok(chartSeries.options.isStacked);
                ok(chartSeries.options.isStacked100);
            });

            it("enables clipping when series are stacked", () => {
                createPlotArea([{
                    type: seriesType, data: [], stack: true
                }, {
                    type: seriesType, data: []
                }]);

                ok(chartSeries.options.clip);
            });

            it("enables clipping when series are not stacked", () => {
                createPlotArea([{
                    type: seriesType, data: []
                }, {
                    type: seriesType, data: []
                }]);

                ok(chartSeries.options.clip);
            });
        });
    }

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Axes', () => {
        beforeEach(() => {
            createPlotArea(columnSeriesData);
        });

        it("appends primary value axis to pane content", () => {
            ok(plotArea.panes[0].content.children.indexOf(valueAxis) >= 0);
        });

        it("appends category axis to pane content", () => {
            ok(plotArea.panes[0].content.children.indexOf(categoryAxis) >= 0);
        });

        it("aligns axes at default crossing values", () => {
            const axisX = categoryAxis;
            const axisY = valueAxis;

            plotArea.reflow(chartBox);

            const crossingSlotY = axisY.getSlot(axisY.options.axisCrossingValue);
            const crossingSlotX = axisX.getSlot(axisX.options.axisCrossingValue);
            equal([crossingSlotY.x1, crossingSlotY.y1], [crossingSlotX.x1, crossingSlotX.y1]);
        });

        it("aligns reversed axes at default crossing values", () => {
            createPlotArea(columnSeriesData, {
                categoryAxis: { reverse: true },
                valueAxis: { reverse: true }
            });

            const axisX = categoryAxis;
            const axisY = valueAxis;

            plotArea.reflow(chartBox);

            const crossingSlotY = axisY.getSlot(axisY.options.axisCrossingValue);
            const crossingSlotX = axisX.getSlot(axisX.options.axisCrossingValue);
            equal([crossingSlotY.x2, crossingSlotY.y2], [crossingSlotX.x2, crossingSlotX.y2]);
        });

        it("aligns axises at non-default crossing values", () => {
            const axisX = categoryAxis;
            const axisY = valueAxis;

            axisY.options.axisCrossingValue = 10;
            axisX.options.axisCrossingValue = 1;
            plotArea.reflow(chartBox);

            const crossingSlotY = axisY.getSlot(axisY.options.axisCrossingValue);
            const crossingSlotX = axisX.getSlot(axisX.options.axisCrossingValue);
            equal([crossingSlotY.x1, crossingSlotY.y1], [crossingSlotX.x1, crossingSlotX.y1], TOLERANCE);
        });

        it("reads crossing values from axisCrossingValues alias", () => {
            const axisX = categoryAxis;
            const axisY = valueAxis;

            axisY.options.axisCrossingValues = 10;
            axisX.options.axisCrossingValues = 1;
            plotArea.reflow(chartBox);

            const crossingSlotY = axisY.getSlot(axisY.options.axisCrossingValues);
            const crossingSlotX = axisX.getSlot(axisX.options.axisCrossingValues);
            equal([crossingSlotY.x1, crossingSlotY.y1], [crossingSlotX.x1, crossingSlotX.y1], TOLERANCE);
        });

        it("aligns reversed axes at non-default crossing values", () => {
            createPlotArea(columnSeriesData, {
                categoryAxis: { reverse: true, axisCrossingValue: 3 },
                valueAxis: { reverse: true }
            });

            const axisX = categoryAxis;
            const axisY = valueAxis;

            plotArea.reflow(chartBox);

            const crossingSlotY = axisY.getSlot(axisY.options.axisCrossingValue);
            const crossingSlotX = axisX.getSlot(axisX.options.axisCrossingValue);
            equal([crossingSlotY.x2, crossingSlotY.y2], [crossingSlotX.x2, crossingSlotX.y2]);
        });

        it("axis limit is [0, 1.2] when no series are configured", 2, () => {
            assertAxisRange("valueAxis", 0, 1.2, []);
        });

        it("NaN values are ignored when tracking axis range", 2, () => {
            stubMethod(CategoricalPlotArea.prototype, "createValueAxes",
                function() {
                    equal(this.valueAxisRangeTracker.query().min, 100);
                    equal(this.valueAxisRangeTracker.query().max, 300);
                },
                function() {
                    createPlotArea([{
                        type: "bar",
                        data: [100, NaN, 300]
                    }]);
                }
            );
        });

        it("adds categories to match actual data", () => {
            const plotArea = new CategoricalPlotArea(columnSeriesData, {
                categoryAxis: {
                    categories: ["A", "B"]
                }
            });

            equal(plotArea.categoryAxis.options.categories.length, 3);
        });

        it("accepts extra categories", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "column",
                    data: [100]
                }], {
                categoryAxis: {
                    categories: ["A", "B"]
                }
            });

            equal(plotArea.categoryAxis.options.categories.length, 2);
        });

        it("categoryAxis justified is not altered with line series", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "line",
                    data: [100]
                }], {
                categoryAxis: {
                    categories: ["A", "B"],
                    justified: true
                }
            });

            equal(plotArea.categoryAxis.options.justified, true);
        });

        it("categoryAxis justified is set to false with bar series", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "bar",
                    data: [100]
                }], {
                categoryAxis: {
                    categories: ["A", "B"],
                    justified: true
                }
            });

            equal(plotArea.categoryAxis.options.justified, false);
        });

        it("categoryAxis justified is set to false with column series", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "column",
                    data: [100]
                }], {
                categoryAxis: {
                    categories: ["A", "B"],
                    justified: true
                }
            });

            equal(plotArea.categoryAxis.options.justified, false);
        });

        it("categoryAxis justified is set to false with OHLC series", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "ohlc",
                    data: [[]]
                }], {
                categoryAxis: {
                    categories: ["A", "B"],
                    justified: true
                }
            });

            equal(plotArea.categoryAxis.options.justified, false);
        });

        it("categoryAxis justified is set to false with candlestick series", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "candlestick",
                    data: [[]]
                }], {
                categoryAxis: {
                    categories: ["A", "B"],
                    justified: true
                }
            });

            equal(plotArea.categoryAxis.options.justified, false);
        });

        it("categoryAxis justified is set to false with step line series", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "line",
                    line: {
                        style: "step"
                    },
                    data: [100]
                }], {
                categoryAxis: {
                    categories: ["A", "B"],
                    justified: true
                }
            });

            equal(plotArea.categoryAxis.options.justified, false);
        });

        it("categoryAxis justified is set to false with step area series", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "area",
                    line: {
                        style: "step"
                    },
                    data: [100]
                }], {
                categoryAxis: {
                    categories: ["A", "B"],
                    justified: true
                }
            });

            equal(plotArea.categoryAxis.options.justified, false);
        });

        it("categoryAxis justified is not altered with bar series on secondary axis", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "line",
                    data: [100]
                }, {
                    type: "bar",
                    data: [200],
                    categoryAxis: "secondary"
                }], {
                categoryAxis: [{
                    categories: ["A", "B"],
                    justified: true
                }, {
                    name: "secondary",
                    categories: ["a", "b"]
                }]
            });

            equal(plotArea.categoryAxis.options.justified, true);
        })

        it("categoryAxis justified is not altered with bar series on primary axis", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "line",
                    data: [100]
                }, {
                    type: "bar",
                    data: [200]
                }], {
                categoryAxis: [{
                    categories: ["A", "B"]
                }, {
                    categories: ["a", "b"],
                    justified: true
                }]
            });

            equal(plotArea.axes[1].options.justified, true);
        });

        it("categoryAxis should have justified true if the type of the series is area", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "area",
                    data: [100]
                }], { });

            equal(plotArea.axes[0].options.justified, true);
        });

        it("categoryAxis should have justified true if the type of the series is verticalArea", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "verticalArea",
                    data: [100]
                }], { });

            equal(plotArea.axes[0].options.justified, true);
        });

        it("categoryAxis should have justified false if the one of the all series is not from type area", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "area",
                    data: [100]
                },{
                    type: "bar",
                    data: [100]
                }], { });

            equal(plotArea.axes[0].options.justified, false);
        });

        it("categoryAxis roundToBaseUnit is not altered with line series", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "line",
                    data: [100]
                }], {
                categoryAxis: {
                    categories: ["A", "B"],
                    roundToBaseUnit: false
                }
            });

            equal(plotArea.categoryAxis.options.roundToBaseUnit, false);
        });

        it("categoryAxis roundToBaseUnit is not altered with bar series on other axis", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "line",
                    data: [100]
                }, {
                    type: "bar",
                    data: [200],
                    categoryAxis: "secondary"
                }], {
                categoryAxis: [{
                    categories: ["A", "B"],
                    roundToBaseUnit: false
                }, {
                    name: "secondary",
                    categories: ["a", "b"]
                }]
            });

            equal(plotArea.categoryAxis.options.roundToBaseUnit, false);
        });

        it("categoryAxis justified is not altered with bar series on primary axis", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "line",
                    data: [100]
                }, {
                    type: "bar",
                    data: [200]
                }], {
                categoryAxis: [{
                    categories: ["A", "B"]
                }, {
                    categories: ["a", "b"],
                    roundToBaseUnit: false
                }]
            });

            equal(plotArea.axes[1].options.roundToBaseUnit, false);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Multiple Value Axes', () => {
        beforeEach(() => {

            createPlotArea(columnSeriesData, {
                valueAxis: [{}, {
                    name: "secondary"
                }]
            });
        });

        it("secondary axis added to pane content", () => {
            ok(plotArea.panes[0].content.children.indexOf(secondaryValueAxis) >= 0);
        });

        it("crosses category axis at default value", () => {
            plotArea.reflow(chartBox);

            const slotX = categoryAxis.getSlot(categoryAxis.options.axisCrossingValue);
            const slotY = valueAxis.getSlot(valueAxis.options.axisCrossingValue);

            equal(slotX.y1, slotY.y1);
        });

        it("Throws error when value axis name is duplicate", () => {
            expect(function() {
                plotArea = new CategoricalPlotArea([{
                        type: "column",
                        data: [100]
                    }], {
                    valueAxis: [{
                        name: "b"
                    }, {
                        name: "b"
                    }]
                });
            }).toThrowError(/Value axis with name b is already defined/);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Multiple Value Axes / Stacked Left', () => {
        beforeEach(() => {
            createPlotArea(columnSeriesData, {
                valueAxis: [{}, {
                    name: "secondary"
                }]
            });
        });

        it("overlapping axes are stacked to the left", () => {
            const margin = secondaryValueAxis.options.margin;

            plotArea.reflow(chartBox);

            equal([secondaryValueAxis.box.x2, secondaryValueAxis.box.y1],
                 [valueAxis.box.x1 - margin, valueAxis.box.y1]
            );
        });

        it("axis can be superimposed using options._overlap", () => {
            valueAxis.options._overlap = true;
            secondaryValueAxis._overlap = true;

            plotArea.reflow(chartBox);

            equal([secondaryValueAxis.box.x2, secondaryValueAxis.box.y1],
                 [valueAxis.box.x2, valueAxis.box.y1]
            );
        });

        it("stacked axes on left are aligned", () => {
            plotArea.reflow(chartBox);

            equal([secondaryValueAxis.lineBox().y1, secondaryValueAxis.lineBox().y2],
                 [valueAxis.lineBox().y1, valueAxis.lineBox().y2]
            );
        });

        it("stacked axes on the left are not mirrored", () => {
            plotArea.reflow(chartBox);

            ok(!valueAxis.options.labels.mirror);
            ok(!secondaryValueAxis.options.labels.mirror);
        });

        it("user set mirror option is not changed", () => {
            valueAxis.options.labels.mirror = true;

            plotArea.reflow(chartBox);

            ok(valueAxis.options.labels.mirror);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Multiple Value Axes / Stacked Right', () => {
        beforeEach(() => {

            createPlotArea(columnSeriesData, {
                categoryAxis: {
                    axisCrossingValue: 100
                },
                valueAxis: [{}, {
                    name: "secondary"
                }]
            });
        });

        it("overlapping axes are shifted to the right", () => {
            const margin = secondaryValueAxis.options.margin;

            plotArea.reflow(chartBox);

            equal([secondaryValueAxis.box.x1, secondaryValueAxis.box.y1],
                 [valueAxis.box.x2 + margin, valueAxis.box.y1]
            );
        });

        it("stacked axes on right are aligned", () => {
            plotArea.reflow(chartBox);

            equal([secondaryValueAxis.lineBox().y1, secondaryValueAxis.lineBox().y2],
                 [valueAxis.lineBox().y1, valueAxis.lineBox().y2]
            );
        });

        it("plot area bounding box wraps axis", () => {
            plotArea.reflow(chartBox);

            const axisBox = secondaryValueAxis.box;
            ok(axisBox.x1 >= plotArea.box.x1 && axisBox.y1 >= plotArea.box.x1);
        });

        it("stacked axes on the right are mirrored", () => {
            plotArea.reflow(chartBox);

            ok(valueAxis.options.labels.mirror);
            ok(secondaryValueAxis.options.labels.mirror);
        });

        it("mirroring inverts the mirror option", () => {
            valueAxis.options.labels.mirror = true;

            plotArea.reflow(chartBox);

            ok(!valueAxis.options.labels.mirror);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Inverted / Multiple Value Axes / Stacked Top', () => {
        beforeEach(() => {
            createPlotArea(barSeriesData, {
                categoryAxis: {
                    axisCrossingValue: 0
                },
                valueAxis: [{}, {
                    name: "secondary"
                }]
            });
        });

        it("overlapping axes are shifted to the top", () => {
            const margin = secondaryValueAxis.options.margin;

            plotArea.reflow(chartBox);

            equal(secondaryValueAxis.box.y2, valueAxis.box.y1 - margin);
        });

        it("stacked axes on top are aligned", () => {
            plotArea.reflow(chartBox);

            equal([secondaryValueAxis.lineBox().x1, secondaryValueAxis.lineBox().x2],
                 [valueAxis.lineBox().x1, valueAxis.lineBox().x2]
            );
        });

        it("stacked axes on the top are mirrored", () => {
            plotArea.reflow(chartBox);

            ok(valueAxis.options.labels.mirror);
            ok(secondaryValueAxis.options.labels.mirror);
        });

        it("mirroring inverts the mirror option", () => {
            valueAxis.options.labels.mirror = true;

            plotArea.reflow(chartBox);

            ok(!valueAxis.options.labels.mirror);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Inverted / Multiple Value Axes / Stacked Bottom', () => {
        beforeEach(() => {
            createPlotArea(barSeriesData, {
                valueAxis: [{}, {
                    name: "secondary"
                }]
            });
        });

        it("overlapping axes are shifted to the bottom", () => {
            const margin = secondaryValueAxis.options.margin;

            plotArea.reflow(chartBox);

            equal(secondaryValueAxis.box.y1, valueAxis.box.y2 + margin);
        });

        it("stacked axes on bottom are aligned", () => {
            plotArea.reflow(chartBox);

            equal([secondaryValueAxis.lineBox().x1, secondaryValueAxis.lineBox().x2],
                 [valueAxis.lineBox().x1, valueAxis.lineBox().x2]
            );
        });

        it("stacked axes on the bottom are not mirrored", () => {
            plotArea.reflow(chartBox);

            ok(!valueAxis.options.labels.mirror);
            ok(!secondaryValueAxis.options.labels.mirror);
        });

        it("user set mirror option is not changed", () => {
            valueAxis.options.labels.mirror = true;

            plotArea.reflow(chartBox);

            ok(valueAxis.options.labels.mirror);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Multiple Category Axes', () => {

        it("axes are accessible by name", () => {
            createPlotArea(columnSeriesData, {
                categoryAxis: [{
                        name: "a"
                    }, {
                        name: "b"
                    }]
            });

            ok(plotArea.namedCategoryAxes["a"]);
            ok(plotArea.namedCategoryAxes["b"]);
        });

        it("axis can be superimposed using options._overlap", () => {
            createPlotArea(columnSeriesData, {
                categoryAxis: [{
                        name: "a",
                        _overlap: true
                    }, {
                        name: "b",
                        _overlap: true
                    }]
            });

            plotArea.reflow(chartBox);

            equal(plotArea.namedCategoryAxes["a"].box.y1,
                 plotArea.namedCategoryAxes["b"].box.y1);
        });

        it("first axis is set as primary category axis", () => {
            createPlotArea(columnSeriesData, {
                categoryAxis: [{
                        name: "a"
                    }, {
                        name: "b"
                    }]
            });

            ok(plotArea.categoryAxis === plotArea.namedCategoryAxes["a"]);
        });

        it("secondary category axis is added to pane content", () => {

                createPlotArea(columnSeriesData, {
                    categoryAxis: [{}, {
                        name: "secondary"
                    }]
                });

            ok(inArray(secondaryCategoryAxis, plotArea.panes[0].content.children));
        });

        it("adds categories to match actual data", () => {
            const plotArea = new CategoricalPlotArea([{
                type: "column",
                data: [1, 2, 3],
                categoryAxis: "b"
            }], {
                categoryAxis: [{
                    }, {
                    name: "b",
                    categories: ["A", "B"]
                }]
            });

            equal(plotArea.namedCategoryAxes.b.options.categories.length, 3);
        });

        it("accepts extra categories", () => {
            const plotArea = new CategoricalPlotArea([{
                    type: "column",
                    data: [100],
                    categoryAxis: "b"
                }], {
                categoryAxis: [{
                    }, {
                    name: "b",
                    categories: ["A", "B"]
                }]
            });

            equal(plotArea.namedCategoryAxes.b.options.categories.length, 2);
        });

        it("Throws error when unable to locate category axis", () => {
            expect(function() {
            createPlotArea([{
                data: [100, 200, 300],
                categoryAxis: "b"
            }])}).toThrowError(/Unable to locate category axis with name b/);
        });

        it("Throws error when category axis name is duplicate", () => {
            expect(function() {
                plotArea = new CategoricalPlotArea([{
                        type: "column",
                        data: [100]
                    }], {
                    categoryAxis: [{
                        name: "b"
                    }, {
                        name: "b"
                    }]
                });
            }).toThrowError(/Category axis with name b is already defined/);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Column series', () => {
        beforeEach(() => {
            createPlotArea(columnSeriesData);
        });

        it("value axis is vertical", () => {
            ok(valueAxis.options.vertical);
        });

        it("category axis is horizontal", () => {
            ok(!categoryAxis.options.vertical);
        });

        it("value axis crosses at first category", () => {
            equal(valueAxis.options.axisCrossingValue, 0);
        });

        it("category axis crossing value can be changed", () => {
            plotArea = new CategoricalPlotArea(columnSeriesData, {
                categoryAxis: {
                    categories: ["A", "B", "C"],
                    axisCrossingValue: 2
                }
            });
            equal(plotArea.categoryAxis.options.axisCrossingValue, 2);
        });

        it("creates bar chart", () => {
            ok(chartSeries instanceof BarChart);
        });

        it("groups bar series into bar chart", () => {
            equal(chartSeries.options.series.length, 2);
        });

        it("bar chart added to pane chart container", () => {
            ok(inArray(chartSeries, plotArea.panes[0].chartContainer.children) >= 0);
        });

        it("sets axis min/max to series limits", 2, () => {
            stubMethod(CategoricalPlotArea.prototype, "createValueAxes",
                function() {
                    equal(this.valueAxisRangeTracker.query().min, 10);
                    equal(this.valueAxisRangeTracker.query().max, 300);
                },
                function() {
                    createPlotArea(columnSeriesData);
                }
            );
        });

        it("sets named default axis min/max to series limits (expl. axis)", 2, () => {
            assertAxisRange("valueAxis", 0, 120,
                [{ type: "column", data: [100], axis: "A" }],
                { valueAxis: { name: "A" } }
            );
        });

        it("sets named primary axis min/max to series limits (impl. axis)", () => {
            assertAxisRange("valueAxis", 0, 120,
                [{ type: "column", data: [100] }],
                { valueAxis: { name: "A" } }
            );
        });

        it("sets named default axis min/max to series limits (expl. axis, 0 < value < 1)", 2, () => {
            assertAxisRange("valueAxis", 0, .12,
                [{ type: "column", data: [.1], axis: "A" }],
                { valueAxis: { name: "A" } }
            );
        });

        it("sets named primary axis min/max to series limits (impl. axis, 0 < value < 1)", 2, () => {
            assertAxisRange("valueAxis", 0, .12,
                [{ type: "column", data: [.1] }],
                { valueAxis: { name: "A" } }
            );
        });

        it("sets named primary axis min/max to series limits (implicit axis)", 2, () => {
            assertAxisRange("valueAxis", 0, 350,
                columnSeriesData,
                { valueAxis: { name: "A" } }
            );
        });

        it("NaN values are ignored when tracking axis range", 2, () => {
            stubMethod(CategoricalPlotArea.prototype, "createValueAxes",
                function() {
                    equal(this.valueAxisRangeTracker.query().min, 100);
                    equal(this.valueAxisRangeTracker.query().max, 300);
                },
                function() {
                    createPlotArea([{
                        type: "column",
                        data: [100, NaN, 300]
                    }]);
                }
            );
        });

        it("applies gap from first series", () => {
            equal(chartSeries.options.gap, GAP);
        });

        it("applies spacing from first series", () => {
            equal(chartSeries.options.spacing, SPACING);
        });
    });
    assertStackedSeries("column");

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Range Column series', () => {
        beforeEach(() => {
            createPlotArea(rangeColumnSeriesData);
        });

        it("value axis is vertical", () => {
            ok(valueAxis.options.vertical);
        });

        it("category axis is horizontal", () => {
            ok(!categoryAxis.options.vertical);
        });

        it("creates range bar chart", () => {
            ok(chartSeries instanceof RangeBarChart);
        });

        it("groups range column series into range bar chart", () => {
            equal(chartSeries.options.series.length, 2);
        });

        it("sets axis min/max to series limits", 2, () => {
            stubMethod(CategoricalPlotArea.prototype, "createValueAxes",
                function() {
                    equal(this.valueAxisRangeTracker.query().min, 10);
                    equal(this.valueAxisRangeTracker.query().max, 330);
                },
                function() {
                    createPlotArea(rangeColumnSeriesData);
                }
            );
        });

        it("sets named default axis min/max to series limits (expl. axis)", 2, () => {
            assertAxisRange("valueAxis", 0, 120,
                [{ type: "rangeColumn", data: [[10, 100]], axis: "A" }],
                { valueAxis: { name: "A" } }
            );
        });

        it("sets named primary axis min/max to series limits (impl. axis)", () => {
            assertAxisRange("valueAxis", 0, 120,
                [{ type: "rangeColumn", data: [[10, 100]] }],
                { valueAxis: { name: "A" } }
            );
        });

        it("sets named default axis min/max to series limits (expl. axis, 0 < value < 1)", 2, () => {
            assertAxisRange("valueAxis", 0, .12,
                [{ type: "rangeColumn", data: [[0, .1]], axis: "A" }],
                { valueAxis: { name: "A" } }
            );
        });

        it("sets named primary axis min/max to series limits (impl. axis, 0 < value < 1)", 2, () => {
            assertAxisRange("valueAxis", 0, .12,
                [{ type: "rangeColumn", data: [[0, .1]] }],
                { valueAxis: { name: "A" } }
            );
        });

        it("sets named primary axis min/max to series limits (implicit axis)", 2, () => {
            assertAxisRange("valueAxis", 0, 350,
                rangeColumnSeriesData,
                { valueAxis: { name: "A" } }
            );
        });

        it("NaN values are ignored when tracking axis range", 2, () => {
            stubMethod(CategoricalPlotArea.prototype, "createValueAxes",
                function() {
                    equal(this.valueAxisRangeTracker.query().min, 10);
                    equal(this.valueAxisRangeTracker.query().max, 300);
                },
                function() {
                    createPlotArea([{
                        type: "rangeColumn",
                        data: [[10, 100], [NaN, NaN], [200, 300]]
                    }]);
                }
            );
        });

        it("applies gap from first series", () => {
            equal(chartSeries.options.gap, GAP);
        });

        it("applies spacing from first series", () => {
            equal(chartSeries.options.spacing, SPACING);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Range Bar series', () => {
        beforeEach(() => {
            createPlotArea(rangeBarSeriesData);
        });

        it("value axis is horizontal", () => {
            ok(!valueAxis.options.vertical);
        });

        it("category axis is vertical", () => {
            ok(categoryAxis.options.vertical);
        });

        it("creates range bar chart", () => {
            ok(chartSeries instanceof RangeBarChart);
        });

        it("groups range column series into range bar chart", () => {
            equal(chartSeries.options.series.length, 2);
        });

        it("applies gap from first series", () => {
            equal(chartSeries.options.gap, GAP);
        });

        it("applies spacing from first series", () => {
            equal(chartSeries.options.spacing, SPACING);
        });
    });


    // ------------------------------------------------------------
    describe('Categorical PlotArea / Line series', () => {
        beforeEach(() => {
            createPlotArea(lineSeriesData);
        });

        it("value axis is vertical", () => {
            ok(valueAxis.options.vertical);
        });

        it("category axis is horizontal", () => {
            ok(!categoryAxis.options.vertical);
        });

        it("creates line chart", () => {
            ok(chartSeries instanceof LineChart);
        });

        it("line chart added to pane chart container", () => {
            ok(inArray(chartSeries, plotArea.panes[0].chartContainer.children));
        });
    });
    assertStackedSeries("line");

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Vertical line series', () => {
        beforeEach(() => {
            createPlotArea(verticalLineSeriesData);
        });

        it("value axis is horizontal", () => {
            ok(!valueAxis.options.vertical);
        });

        it("category axis is vertical", () => {
            ok(categoryAxis.options.vertical);
        });

        it("creates line chart", () => {
            ok(chartSeries instanceof LineChart);
        });
    });

    assertStackedSeries("verticalLine");

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Area series', () => {
        beforeEach(() => {
            createPlotArea(areaSeriesData);
        });

        it("value axis is vertical", () => {
            ok(valueAxis.options.vertical);
        });

        it("category axis is horizontal", () => {
            ok(!categoryAxis.options.vertical);
        });

        it("creates area chart", () => {
            ok(chartSeries instanceof AreaChart);
        })

        it("area chart added to pane chart container", () => {
            ok(inArray(chartSeries, plotArea.panes[0].chartContainer.children));
        });;

        it("NaN values are ignored when tracking axis range", 2, () => {
            stubMethod(CategoricalPlotArea.prototype, "createValueAxes",
                function() {
                    equal(this.valueAxisRangeTracker.query().min, 100);
                    equal(this.valueAxisRangeTracker.query().max, 300);
                },
                function() {
                    createPlotArea([{
                        type: "area",
                        data: [100, NaN, 300]
                    }]);
                }
            );
        });
    });

    assertStackedSeries("area");

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Verical area series', () => {
        beforeEach(() => {
            createPlotArea(verticalAreaSeriesData);
        });

        it("value axis is horizontal", () => {
            ok(!valueAxis.options.vertical);
        });

        it("category axis is vertical", () => {
            ok(categoryAxis.options.vertical);
        });

        it("creates area chart", () => {
            ok(chartSeries instanceof AreaChart);
        });
    });

    assertStackedSeries("verticalArea");

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Bar series', () => {
        beforeEach(() => {
            createPlotArea(barSeriesData);
        });

        it("value axis is horizontal", () => {
            ok(!valueAxis.options.vertical);
        });

        it("category axis is vertical", () => {
            ok(categoryAxis.options.vertical);
        });

        it("value axis crosses at last category", () => {
            ok(plotArea.categoryAxis.options.axisCrossingValue >= 3);
        });

        it("value axis crosses at last category when no categories are defined", () => {
            plotArea = new CategoricalPlotArea(barSeriesData);
            ok(plotArea.categoryAxis.options.axisCrossingValue >= 3);
        });

        it("value axis crossing can be changed", () => {
            plotArea = new CategoricalPlotArea(barSeriesData, {
                categoryAxis: {
                    categories: ["A", "B", "C"],
                    axisCrossingValue: 2
                }
            });
            equal(plotArea.categoryAxis.options.axisCrossingValue, 2);
        });

        it("applies gap from first series", () => {
            equal(chartSeries.options.gap, GAP);
        });

        it("applies spacing from first series", () => {
            equal(chartSeries.options.spacing, SPACING);
        });

        it("aligns axes at default crossing values", () => {
            const axisX = valueAxis;
            const axisY = categoryAxis;

            plotArea.reflow(chartBox);

            const crossingSlotY = axisY.getSlot(axisY.options.axisCrossingValue, axisY.options.axisCrossingValue, true);
            const crossingSlotX = axisX.getSlot(axisX.options.axisCrossingValue, axisX.options.axisCrossingValue, true);
            equal([crossingSlotY.x1, crossingSlotY.y1], [crossingSlotX.x1, crossingSlotX.y1]);
        });

        it("aligns reversed axes at default crossing values", () => {
            createPlotArea(barSeriesData, {
                categoryAxis: { reverse: true },
                valueAxis: { reverse: true }
            });

            const axisX = valueAxis;
            const axisY = categoryAxis;

            plotArea.reflow(chartBox);

            const crossingSlotY = axisY.getSlot(axisY.options.axisCrossingValue, axisY.options.axisCrossingValue, true);
            const crossingSlotX = axisX.getSlot(axisX.options.axisCrossingValue, axisX.options.axisCrossingValue, true);

            equal([crossingSlotY.x2, crossingSlotY.y2], [crossingSlotX.x2, crossingSlotX.y2]);
        });

        it("aligns reversed axes at non-default crossing values", () => {
            createPlotArea(barSeriesData, {
                categoryAxis: { reverse: true, axisCrossingValue: 0 },
                valueAxis: { reverse: true }
            });

            const axisX = valueAxis;
            const axisY = categoryAxis;

            plotArea.reflow(chartBox);

            const crossingSlotY = axisY.getSlot(axisY.options.axisCrossingValue);
            const crossingSlotX = axisX.getSlot(axisX.options.axisCrossingValue);

            equal([crossingSlotY.x2, crossingSlotY.y2], [crossingSlotX.x2, crossingSlotX.y2]);
        });
    });

    assertStackedSeries("bar");

    // ------------------------------------------------------------
    describe('Categorical PlotArea / 100% Stacked series', () => {
        beforeEach(() => {
            createPlotArea([{
                name: "Value A",
                type: "column",
                stack: { type: "100%" },
                data: [100, 200, 300]
            }, {
                name: "Value B",
                type: "column",
                data: [10, 20, 30]
            }]);
        });

        it("sets value axis roundToMajorUnit to false", () => {
            ok(!plotArea.valueAxis.options.roundToMajorUnit);
        });

        it("roundToMajorUnit can be overriden", () => {
            createPlotArea([{
                type: "column",
                stack: { type: "100%" },
                data: [1, 2, 3]
            }], { valueAxis: { roundToMajorUnit: false } });
            ok(!plotArea.valueAxis.options.roundToMajorUnit);
        });

        it("default value axis label format is set to P0", () => {
            equal(plotArea.valueAxis.options.labels.format, "P0");
        });

        it("default value axis label format can be overriden", () => {
            createPlotArea([{
                type: "column",
                stack: { type: "100%" },
                data: [1, 2, 3]
            }], { valueAxis: { labels: { format: "N" } } });
            equal(plotArea.valueAxis.options.labels.format, "N");
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / OHLC series', () => {
        beforeEach(() => {
            createPlotArea([{
                type: "ohlc",
                data: [[]]
            }]);
        });

        it("OHLC chart added to pane chart container", () => {
            ok(inArray(chartSeries, plotArea.panes[0].chartContainer.children));
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Candlestick series', () => {
        beforeEach(() => {
            createPlotArea([{
                type: "candlestick",
                data: [[]]
            }]);
        });

        it("Candlestick chart added to pane chart container", () => {
            ok(inArray(chartSeries, plotArea.panes[0].chartContainer.children));
        });

        it("sets named primary axis min/max to series limits (impl./expl. axis)", () => {
            const fn = CategoricalPlotArea.prototype;
            stubMethod(fn, "createValueAxes",
                function(panes) {
                    fn._stubbed["createValueAxes"].call(this, panes);
                    equal(this.valueAxis.options.min, 0);
                    equal(this.valueAxis.options.max, 120);
                },
                function() {
                    createPlotArea([{
                        type: "candlestick",
                        data: [[0, 10, 0, 0]],
                        axis: "A"
                    }, {
                        type: "candlestick",
                        data: [[0, 100, 0, 0]]
                    }], {
                        valueAxis: { name: "A" }
                    });
                }
            );
        });

        it("sets named primary axis min/max to series limits (implicit axis)", () => {
            const fn = CategoricalPlotArea.prototype;
            stubMethod(fn, "createValueAxes",
                function(panes) {
                    fn._stubbed["createValueAxes"].call(this, panes);
                    equal(this.valueAxis.options.min, 0);
                    equal(this.valueAxis.options.max, 12);
                },
                function() {
                    createPlotArea([{
                        type: "candlestick",
                        data: [[0, 10, 0, 0]]
                    }], {
                        valueAxis: { name: "A" }
                    });
                }
            );
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Waterfall series', () => {
        beforeEach(() => {
            createPlotArea([{
                type: "waterfall",
                data: [1, 2, 3],
                gap: GAP,
                spacing: SPACING
            }, {
                type: "waterfall",
                data: [1, 2, 3]
            }]);
        });

        it("value axis is vertical", () => {
            ok(valueAxis.options.vertical);
        });

        it("category axis is horizontal", () => {
            ok(!categoryAxis.options.vertical);
        });

        it("creates waterfall chart", () => {
            ok(chartSeries instanceof WaterfallChart);
        });

        it("groups waterfall series into waterfall chart", () => {
            equal(chartSeries.options.series.length, 2);
        });

        it("sets axis min/max to series limits", 2, () => {
            stubMethod(CategoricalPlotArea.prototype, "createValueAxes",
                function() {
                    equal(this.valueAxisRangeTracker.query().min, 1);
                    equal(this.valueAxisRangeTracker.query().max, 6);
                },
                function() {
                    createPlotArea([{
                        type: "waterfall",
                        data: [1, 2, 3]
                    }, {
                        type: "waterfall",
                        data: [1, 2, 3]
                    }]);
                }
            );
        });

        it("applies gap from first series", () => {
            equal(chartSeries.options.gap, GAP);
        });

        it("applies spacing from first series", () => {
            equal(chartSeries.options.spacing, SPACING);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Horizontal Waterfall series', () => {
        beforeEach(() => {
            createPlotArea([{
                type: "horizontalWaterfall",
                data: [1, 2, 3],
                gap: GAP,
                spacing: SPACING
            }, {
                type: "horizontalWaterfall",
                data: [1, 2, 3]
            }]);
        });

        it("value axis is horizontal", () => {
            ok(!valueAxis.options.vertical);
        });

        it("category axis is vertical", () => {
            ok(categoryAxis.options.vertical);
        });

        it("creates waterfall chart", () => {
            ok(chartSeries instanceof WaterfallChart);
        });

        it("groups horizontal waterfall series into waterfall chart", () => {
            equal(chartSeries.options.series.length, 2);
        });

        it("applies gap from first series", () => {
            equal(chartSeries.options.gap, GAP);
        });

        it("applies spacing from first series", () => {
            equal(chartSeries.options.spacing, SPACING);
        });
    });

    // ------------------------------------------------------------
    const dateCategoryAxis = {
        type: "date",
        categories: ["2012/02/01 00:00", "2012/02/02 00:00", "2012/02/04 00:00"]
    };

    describe('Categorical PlotArea / Date series', () => {

        it("Accepts capitalized type", () => {
            createPlotArea([{
                    type: "bar",
                    data: [100, 200, 300]
                }], {
                categoryAxis: {
                    type: "Date",
                    categories: ["2012/02/01 00:00", "2012/02/02 00:00", "2012/02/04 00:00"]
                }
            });

            equal(plotArea.categoryAxis.options.categories[0].constructor, Date);
        });

        it("Automatically detects date category axis", () => {
            createPlotArea([{
                    type: "bar",
                    data: [100, 200, 300]
                }], {
                categoryAxis: {
                    categories: [
                        new Date(2012, 2, 1),
                        new Date(2012, 2, 2),
                        new Date(2012, 2, 4)
                    ]
                }
            });

            equal(plotArea.categoryAxis.options.type, "date");
            equal(plotArea.series[0].data, [{ value: 100 }, { value: 200 }, {}, { value: 300 }]);
        });

        it("User can override automatic category axis type", () => {
            createPlotArea([{
                    type: "bar",
                    data: [100, 200, 300]
                }], {
                categoryAxis: {
                    type: "category",
                    categories: [
                        new Date(2012, 2, 1),
                        new Date(2012, 2, 2),
                        new Date(2012, 2, 4)
                    ]
                }
            });

            equal(plotArea.categoryAxis.options.type, "category");
            equal(plotArea.series[0].data, [100, 200, 300]);
        });

        it("Does not alter data points when no grouping is done", () => {
            createPlotArea([{
                type: "bar",
                data: [100, 200, 300]
            }], {
                categoryAxis: dateCategoryAxis
            });

            equal(plotArea.series[0].data, [{ value: 100 }, { value: 200 }, {}, { value: 300 }]);
        });

        it("Does not alter original series data", () => {
            const series = [{
                type: "bar",
                data: [100, 200, 300]
            }];

            createPlotArea(series, {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(series[0].data, [100, 200, 300]);
        });

        it("Does not alter original series data items", () => {
            const series = [{
                type: "bar",
                data: [100, 200, 300],
                dataItems: ["a", "b", "c"]
            }];

            createPlotArea(series, {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(series[0].dataItems, ["a", "b", "c"]);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Date series / Aggregates', () => {

        it("Aggregates series data using max by default", () => {
            createPlotArea([{
                type: "bar",
                data: [100, 200, 300]
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 300 }]);
        });

        it("Aggregates are calculated for single values", 1, () => {
            createPlotArea([{
                type: "bar",
                data: [100],
                aggregate: function() { ok(true); }
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });
        });

        it("Aggregates bound series data", () => {
            createPlotArea([{
                type: "bar",
                data: [{ value: 100 }, { value: 200 }, { value: 300 }]
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 300 }]);
        });

        it("Aggregation preserves value field name", () => {
            createPlotArea([{
                type: "bar",
                field: "v",
                data: [{ v: 100 }, { v: 200 }, { v: 300 }]
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ v: 300 }]);
        });

        it("Aggregation preserves compound value field names", () => {
            createPlotArea([{
                type: "candlestick",
                data: [{ o: 100, h: 100, l: 100, c: 100 }, { o: 200, h: 200, l: 200, c: 200 }],
                openField: "o",
                highField: "h",
                lowField: "l",
                closeField: "c",
                aggregate: {
                    open: "max",
                    high: "max",
                    low: "max",
                    close: "max"
                }
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ o: 200, h: 200, l: 200, c: 200 }]);
        });

        it("Does not change series fields", () => {
            createPlotArea([{
                type: "line",
                data: [{}, {}],
                field: "v"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].field, "v");
        });

        it("Binds to data items returned from aggregate (simple aggregate)", () => {
            createPlotArea([{
                type: "line",
                data: [{ v: 100 }, { v: 200 }],
                field: "v",
                aggregate: function() {
                    return { v: 300 };
                }
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ v: 300 }]);
        });

        it("Binds to data items returned from aggregate (compound aggregate)", () => {
            createPlotArea([{
                type: "candlestick",
                data: [{ o: 100, h: 100, l: 100, c: 100 }, { o: 200, h: 200, l: 200, c: 200 }],
                openField: "o",
                highField: "h",
                lowField: "l",
                closeField: "c",
                aggregate: function() {
                    return { o: 300, h: 300, l: 300, c: 300 };
                }
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ o: 300, h: 300, l: 300, c: 300 }]);
        });

        it("Aggregates series data with predefined function", () => {
            createPlotArea([{
                type: "bar",
                data: [100, 200, 300],
                aggregate: "min"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 100 }]);
        });

        it("Aggregates series data with user function", 1, () => {
            createPlotArea([{
                type: "bar",
                data: [100, 200, 300],
                aggregate: function(values, series) {
                    equal(values, series.data);
                    return 0;
                }
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });
        });

        it("User aggregate function receives dataItems", 1, () => {
            createPlotArea([{
                type: "bar",
                data: [100, 200, 300],
                aggregate: function(values, series, dataItems) {
                    equal(dataItems, series.data);
                    return 0;
                }
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });
        });

        it("User aggregate function receives group", 1, () => {
            createPlotArea([{
                type: "bar",
                data: [100, 200, 300],
                aggregate: function(values, series, dataItems, group) {
                    equal(group, new Date("2012/02/01"));
                    return 0;
                }
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });
        });

        it("Does not drop note text", 1, () => {
            createPlotArea([{
                type: "bar",
                field: "v",
                noteTextField: "n",
                aggregate: {
                    value: "max",
                    noteText: "first"
                },
                data: [{ v: 1, n: "foo" }, { v: 2 }]
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ v: 2, n: "foo" }]);
        });

        it("Category axis data items are aggregated", () => {
            createPlotArea([{
                type: "bar",
                data: [100, 200, 300]
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.axes[0].options.dataItems[0].value, 300);
        });

        it("Aggregated category axis data items are not overridden unless the series has point for the category", () => {
            createPlotArea([{
              type: "bar",
              field: "value",
              categoryField: "category",
              data: [{category: 1, value: 1, foo: "bar"}, {category: 3, value: 1, foo: "qux"}]
            }, {
              type: "bar",
              data: [{category: 2, value: 1, foo: "baz"}, {category: 3, value: 1, foo: "quux"}],
              field: "value",
              categoryField: "category"
            }], {
                categoryAxis: {
                    categories: [1,2,3]
                }
            });

            equal(plotArea.axes[0].options.dataItems[0].foo, "bar");
            equal(plotArea.axes[0].options.dataItems[2].foo, "quux");
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Date series / Aggregates / max', () => {

        it("max ignores NaN values", () => {
            createPlotArea([{
                type: "bar",
                data: [100, NaN, 300],
                aggregate: "max"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 300 }]);
        });

        it("max ignores null values", () => {
            createPlotArea([{
                type: "bar",
                data: [100, null, 300],
                aggregate: "max"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 300 }]);
        });

        it("max ignores undefined values", () => {
            createPlotArea([{
                type: "bar",
                data: [100, undefined, 300],
                aggregate: "max"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 300 }]);
        });

        it("max returns Infinity", () => {
            createPlotArea([{
                type: "bar",
                data: [100, Infinity, 300],
                aggregate: "max"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: Infinity }]);
        });

        it("max handles -Infinity", () => {
            createPlotArea([{
                type: "bar",
                data: [100, -Infinity, 300],
                aggregate: "max"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 300 }]);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Date series / Aggregates / min', () => {

        it("min ignores NaN values", () => {
            createPlotArea([{
                type: "bar",
                data: [100, NaN, 300],
                aggregate: "min"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 100 }]);
        });

        it("min ignores null values", () => {
            createPlotArea([{
                type: "bar",
                data: [100, null, 300],
                aggregate: "min"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 100 }]);
        });

        it("min ignores undefined values", () => {
            createPlotArea([{
                type: "bar",
                data: [100, undefined, 300],
                aggregate: "min"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 100 }]);
        });

        it("min handles Infinity", () => {
            createPlotArea([{
                type: "bar",
                data: [100, Infinity, 300],
                aggregate: "min"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 100 }]);
        });

        it("min returns -Infinity", () => {
            createPlotArea([{
                type: "bar",
                data: [100, -Infinity, 300],
                aggregate: "min"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: -Infinity }]);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Date series / Aggregates / sum', () => {

        it("sum ignores NaN values", () => {
            createPlotArea([{
                type: "bar",
                data: [100, NaN, 300],
                aggregate: "sum"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 400 }]);
        });

        it("sum ignores null values", () => {
            createPlotArea([{
                type: "bar",
                data: [100, null, 300],
                aggregate: "sum"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 400 }]);
        });

        it("sum ignores undefined values", () => {
            createPlotArea([{
                type: "bar",
                data: [100, undefined, 300],
                aggregate: "sum"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 400 }]);
        });

        it("sum adds to Infinity", () => {
            createPlotArea([{
                type: "bar",
                data: [100, Infinity, 300],
                aggregate: "sum"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: Infinity }]);
        });

        it("sum adds to -Infinity", () => {
            createPlotArea([{
                type: "bar",
                data: [100, -Infinity, 300],
                aggregate: "sum"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: -Infinity }]);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Date series / Aggregates / count', () => {

        it("count ignores null values", () => {
            createPlotArea([{
                type: "bar",
                data: [100, null, 300],
                aggregate: "count"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 2 }]);
        });

        it("count ignores undefined values", () => {
            createPlotArea([{
                type: "bar",
                data: [100, undefined, 300],
                aggregate: "count"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 2 }]);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Date series / Aggregates / avg', () => {

        it("avg ignores NaN values", () => {
            createPlotArea([{
                type: "bar",
                data: [100, NaN, 300],
                aggregate: "avg"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 200 }]);
        });

        it("avg ignores null values", () => {
            createPlotArea([{
                type: "bar",
                data: [100, null, 300],
                aggregate: "avg"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 200 }]);
        });

        it("avg ignores undefined values", () => {
            createPlotArea([{
                type: "bar",
                data: [100, undefined, 300],
                aggregate: "avg"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 200 }]);
        });

        it("avg returns Infinity", () => {
            createPlotArea([{
                type: "bar",
                data: [100, Infinity, 300],
                aggregate: "avg"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: Infinity }]);
        });

        it("avg returns -Infinity", () => {
            createPlotArea([{
                type: "bar",
                data: [100, -Infinity, 300],
                aggregate: "avg"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: -Infinity }]);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Date series / Aggregates / first', () => {

        it("first ignores null values", () => {
            createPlotArea([{
                type: "bar",
                data: [null, 300],
                aggregate: "first"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 300 }]);
        });

        it("first ignores undefined values", () => {
            createPlotArea([{
                type: "bar",
                data: [undefined, 300],
                aggregate: "first"
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });

            equal(plotArea.series[0].data, [{ value: 300 }]);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Date series / Multiple Category Axes', () => {

        it("Aggregates series on secondary axis", () => {
            createPlotArea([{
                type: "bar",
                data: [100, 200, 300],
                categoryAxis: "b"
            }], {
                categoryAxis: [
                    { },
                    deepExtend({
                        name: "b", baseUnit: "months"
                    }, dateCategoryAxis)
                ]
            });

            equal(plotArea.series[0].data, [{ value: 300 }]);
        });

        it("Throws error when unable to locate category axis", () => {
            expect(function() {
                createPlotArea([{
                    type: "bar",
                    data: [100, 200, 300],
                    categoryAxis: "b"
                }], {
                    categoryAxis:
                        deepExtend({
                            baseUnit: "months"
                        }, dateCategoryAxis)
                })}).toThrowError(/Unable to locate category axis with name b/);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Date series / OHLC Aggregates', () => {

        it("Series data using aggregate", () => {
            createPlotArea([{
                type: "candlestick",
                aggregate: {
                    "open": "max",
                    "high": "max",
                    "low": "min",
                    "close": "max"
                },
                data: [[1,4,0,2], [2,5,1,3], [3,6,2,4]]
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });
            const point = plotArea.series[0].data[0];

            equal(point, { open: 3, high: 6, low: 0, close: 4 });
        });

        it("Series data with predefined function", () => {
            createPlotArea([{
                type: "candlestick",
                aggregate: {
                    "open": "min",
                    "high": "min",
                    "low": "min",
                    "close": "min"
                },
                data: [[1,4,0,2], [2,5,1,3], [3,6,2,4]]
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });
            const point = plotArea.series[0].data[0];

            equal(point, { open: 1, high: 4, low: 0, close: 2 });
        });

        it("Series data with user function", 1, () => {
            const data = [[1,4,0,2], [2,5,1,3], [3,6,2,4]];
            createPlotArea([{
                type: "candlestick",
                aggregate: {
                    "open": function(values, series) {
                        equal(data, series.data);
                        return 0;
                    }
                },
                data: data
            }], {
                categoryAxis: deepExtend({
                    baseUnit: "months"
                }, dateCategoryAxis)
            });
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Date series / Category Field', () => {

        it("Aggregates using category field instead of position", () => {
            createPlotArea([{
                type: "column",
                categoryField: "date",
                data: [{
                    value: 1,
                    date: new Date("2013/06/01")
                }, {
                    value: 2,
                    date: new Date("2013/06/02")
                }, {
                    value: 3,
                    date: new Date("2013/07/01")
                }]
            }], {
                categoryAxis: {
                    categories: [
                        new Date("2013/06/01"), new Date("2013/06/02"),
                        new Date("2013/07/01")
                    ],
                    baseUnit: "months"
                }
            });

            const point = plotArea.series[0].data[0];

            equal(point.value, 2);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Aggregates / Category Field', () => {

        it("Aggregates points with same category", () => {
            createPlotArea([{
                type: "column",
                categoryField: "category",
                data: [{
                    value: 1,
                    category: "A"
                }, {
                    value: 2,
                    category: "A"
                }, {
                    value: 3,
                    category: "B"
                }]
            }], {
                categoryAxis: {
                    categories: [ "A", "B" ]
                }
            });

            const data = plotArea.series[0].data;

            equal(data[0].value, 2);
            equal(data.length, 2);
        });

        it("filters series based on category axis", () => {
            createPlotArea([{
                type: "column",
                categoryField: "category",
                data: [{
                    value: 1,
                    category: "A"
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 3,
                    category: "C"
                }, {
                    value: 4,
                    category: "D"
                }]
            }], {
                categoryAxis: {
                    min: 1,
                    max: 3,
                    categories: [ "A", "B", "C", "D"]
                }
            });

            const data = plotArea.series[0].data;

            equal(data[0].value, 2);
            equal(data.length, 2);
        });
    });

    (function() {
        function assertOutOfRangePoints(expectedMin, expectedMax) {
            const series = plotArea.series[0];
            const min = series._outOfRangeMinPoint;
            const max = series._outOfRangeMaxPoint;

            if (expectedMin === undefined) {
                ok(!min);
            } else {
                equal(min.categoryIx, expectedMin.categoryIx);
                equal(min.item.value, expectedMin.value);
                if (expectedMin.category.getTime) {
                    equal(min.category.getTime(), expectedMin.category.getTime());
                } else {
                    equal(min.category, expectedMin.category);
                }
            }

            if (expectedMax === undefined) {
                ok(!min);
            } else {
                equal(max.categoryIx, expectedMax.categoryIx);
                equal(max.item.value, expectedMax.value);
                if (expectedMax.category.getTime) {
                    equal(max.category.getTime(), expectedMax.category.getTime());
                } else {
                    equal(max.category, expectedMax.category);
                }
            }
        }

        function setupPlotArea(seriesOptions, categoryOptions) {
            createPlotArea([deepExtend({
                type: "line",
                categoryField: "category",
                data: [{
                    value: 1,
                    category: "A"
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 3,
                    category: "C"
                }, {
                    value: 4,
                    category: "D"
                }]
            }, seriesOptions)], {
                categoryAxis: deepExtend({
                    categories: [ "A", "B", "C", "D"]
                }, categoryOptions)
            });
        }

        // ------------------------------------------------------------
        describe('Categorical PlotArea / Category Field / out of range points', () => {

            it("Adds out of range points for line series", () => {
                setupPlotArea({}, {
                    min: 1,
                    max: 3
                });
                assertOutOfRangePoints({
                    categoryIx: -1,
                    category: "A",
                    value: 1
                }, {
                    categoryIx: 2,
                    category: "D",
                    value: 4
                });
            });

            it("Does not add out of range points if full range is shown", () => {
                setupPlotArea({}, {});

                assertOutOfRangePoints();
            });

            it("Does not add out of range points for column series", () => {
                setupPlotArea({
                    type: "column"
                }, {
                    min: 1,
                    max: 3
                });

                assertOutOfRangePoints();
            });

            it("Does not add out of range points if there is are no points in range", () => {
                setupPlotArea({}, {
                    min: 5,
                    max: 10
                });

                assertOutOfRangePoints();
            });

            it("Aggregates out of range points", () => {
                setupPlotArea({
                    data: [{
                        value: 1,
                        category: "A"
                    }, {
                        value: 10,
                        category: "A"
                    }, {
                        value: 2,
                        category: "B"
                    }, {
                        value: 3,
                        category: "C"
                    }, {
                        value: 4,
                        category: "D"
                    }, {
                        value: 10,
                        category: "D"
                    }, {
                        value: 10,
                        category: "D"
                    }],
                    aggregate: "sum"
                }, {
                    min: 1,
                    max: 3
                });

                assertOutOfRangePoints({
                    categoryIx: -1,
                    category: "A",
                    value: 11
                }, {
                    categoryIx: 2,
                    category: "D",
                    value: 24
                });
            });

            it("have absolute categories for date category axis", () => {
                setupPlotArea({
                    data: [{
                        value: 1,
                        category: new Date("2015/01/01")
                    }, {
                        value: 1,
                        category: new Date("2015/01/02")
                    }, {
                        value: 10,
                        category: new Date("2015/01/02")
                    }, {
                        value: 2,
                        category: new Date("2015/01/05")
                    }, {
                        value: 3,
                        category: new Date("2015/01/06")
                    }, {
                        value: 4,
                        category: new Date("2015/01/09")
                    }, {
                        value: 10,
                        category: new Date("2015/01/09")
                    }, {
                        value: 10,
                        category: new Date("2015/01/10")
                    }],
                    aggregate: "sum"
                }, {
                    categories: [new Date("2015/01/01"), new Date("2015/01/10")],
                    min: new Date("2015/01/05"),
                    max: new Date("2015/01/06"),
                    baseUnit: "days"
                });

                assertOutOfRangePoints({
                    categoryIx: -3,
                    category: new Date("2015/01/02"),
                    value: 11
                }, {
                    categoryIx: 4,
                    category: new Date("2015/01/09"),
                    value: 14
                });
            });
        });

    })();

    (function() {

        function assertOutOfRangePoints(expectedMin, expectedMax) {
            const series = plotArea.series[0];
            const min = series._outOfRangeMinPoint;
            const max = series._outOfRangeMaxPoint;

            if (expectedMin === undefined) {
                ok(!min);
            } else {
                equal(min.categoryIx, expectedMin.categoryIx);
                equal(min.item, expectedMin.value);
                equal(min.category, expectedMin.category);
            }

            if (expectedMax === undefined) {
                ok(!min);
            } else {
                equal(max.categoryIx, expectedMax.categoryIx);
                equal(max.item, expectedMax.value);
                equal(min.category, expectedMin.category);
            }
        }

        function setupPlotArea(seriesOptions, categoryOptions) {
            createPlotArea(deepExtend([{
                type: "line",
                data: [1, 2, 3, 4]
            }], seriesOptions), {
                categoryAxis: deepExtend({
                    categories: [ "A", "B", "C", "D"]
                }, categoryOptions)
            });
        }

        // ------------------------------------------------------------
        describe('Categorical PlotArea / Category index filter', () => {

            it("filters series data based on category axis range", () => {
                setupPlotArea([], {
                    min: 1,
                    max: 3
                });

                arrayClose(plotArea.series[0].data, [2, 3]);
            });

            it("filters series data based on category axis range (justified)", () => {
                setupPlotArea([], {
                    min: 1,
                    max: 3,
                    justified: true
                });

                arrayClose(plotArea.series[0].data, [2, 3, 4]);
            });

            it("sets axis _seriesMax field to the maximum series length", () => {
                setupPlotArea([{
                    type: "line",
                    data: [1, 2, 3, 4, 5]
                }, {
                    type: "line",
                    data: [1, 2, 3, 4, 5, 6]
                }], {
                    min: 1,
                    max: 3,
                    justified: true
                });
                equal(plotArea.categoryAxis._seriesMax, 6);
            });
        });

        // ------------------------------------------------------------
        describe('Categorical PlotArea / Category index out of range points', () => {

            it("adds out of range points for line series", () => {
                setupPlotArea([], {
                    min: 1,
                    max: 3
                });

                assertOutOfRangePoints({
                    categoryIx: -1,
                    category: "A",
                    value: 1
                }, {
                    categoryIx: 2,
                    category: "D",
                    value: 4
                });
            });

            it("does not add out of range points for column series", () => {
                setupPlotArea([{
                    type: "column"
                }], {
                    min: 1,
                    max: 3
                });

                assertOutOfRangePoints();
            });

            it("does not add out of range points if full range is shown", () => {
                setupPlotArea([], {});

                assertOutOfRangePoints();
            });
        });

    })();

})();

(function() {
    const barSeriesData = [{
        name: "Value A",
        type: "bar",
        data: [100]
    }];
    let plotArea,
        gridLines;

    function createPlotArea(categoryAxis, valueAxis, options) {
        plotArea = new CategoricalPlotArea(barSeriesData, deepExtend({
            categoryAxis: categoryAxis,
            valueAxis: valueAxis
        }, options));
    }

    function renderPlotArea(categoryAxis, valueAxis, options) {
        createPlotArea(categoryAxis, valueAxis, options);
        plotArea.reflow(chartBox);
        plotArea.renderVisual();

        gridLines = [];
        const axes = plotArea.axes;
        for(let idx = 0; idx < axes.length; idx++) {
            if (axes[idx]._gridLines) {
                gridLines = gridLines.concat(axes[idx]._gridLines.children);
            }
        }
    }

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Major Gridlines', () => {

        it("renders gridlines", () => {
            renderPlotArea({
                categories: ["A"],
                majorGridLines: {
                    visible: true
                }
            });

            equal(gridLines.length, 7);
        });

        it("minorGridLine step of 0 is treated as 1", () => {
            renderPlotArea({
                categories: ["A"],
                minorGridLines: {
                    step: 0,
                    visible: true
                }
            });

            equal(gridLines.length, 8);
        });

        it("majorGridLine step of 0 is treated as 1", () => {
            renderPlotArea({
                categories: ["A"],
                majorGridLines: {
                    step: 0,
                    visible: true
                }
            });

            equal(gridLines.length, 7);
        });

        it("renders gridlines over hidden value axis", () => {
            renderPlotArea({
                categories: ["A"],
                majorGridLines: {
                    visible: true
                }
            }, {
                line: {
                    visible: false
                }
            });

            equal(gridLines.length, 8);
        });

        it("should not render gridlines for numeric axis", () => {
            const categoryAxis = {
                    categories: ["A"],
                    majorGridLines: {
                        visible: true
                    }
                },
                valueAxis = {
                    majorGridLines: {
                        visible: false
                    }
                };

            renderPlotArea(categoryAxis, valueAxis);

            equal(gridLines.length, 1);
        });

        it("should not render gridlines for category axis", () => {
            const categoryAxis = {
                    categories: ["A"]
                };

            renderPlotArea(categoryAxis);

            equal(gridLines.length, 6);
        });

        it("should not render gridlines", () => {
            const categoryAxis = {
                    categories: ["A"],
                    majorGridLines: {
                        visible: false
                    }
                },
                valueAxis = {
                    majorGridLines: {
                        visible: false
                    }
                };

            renderPlotArea(categoryAxis, valueAxis);

            equal(gridLines.length, 0);
        });

        it("gridlines extend to secondary axis end", () => {
            const categoryAxis = {
                    categories: ["A"],
                    majorGridLines: {
                        visible: true
                    }
                },
                valueAxis = {
                    min: 0,
                    max: 10,
                    majorUnit: 3,
                    majorGridLines: {
                        visible: false
                    }
                };

            renderPlotArea(categoryAxis, valueAxis);
            equal(gridLines[0].segments[1].anchor().x, round(plotArea.valueAxis.lineBox().x2, 0) + 0.5);
        });

        it("should not render gridlines for secondary value axis", () => {
            renderPlotArea({
                categories: ["A"]
            }, [{}, {}]);

            equal(gridLines.length, 6);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Major Gridlines / Panes', () => {

        it("renders gridlines when value axis is in different pane", () => {
            renderPlotArea({
                    categories: ["A"],
                    majorGridLines: {
                        visible: true
                    }
                }, {
                    pane: "bottom"
                }, {
                    panes: [{
                        name: "top"
                    }, {
                        name: "bottom"
                    }]
            });

            equal(gridLines.length, 8);
        });

        it("renders grid lines in each pane", () => {
            renderPlotArea({
                    categories: ["A"],
                    majorGridLines: {
                        visible: true
                    }
                }, [{
                    pane: "top"
                },{
                    pane: "bottom"
                }], {
                    panes: [{
                        name: "top"
                    }, {
                        name: "bottom"
                    }]
            });

            equal(gridLines.length, 13);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Minor Gridlines', () => {

        it("renders gridlines", () => {
            const categoryAxis = {
                    categories: ["A"],
                    majorGridLines: {
                        visible: false
                    },
                    minorGridLines: {
                        visible: true
                    }
                },
                valueAxis = {
                    majorGridLines: {
                        visible: false
                    },
                    minorGridLines: {
                        visible: true
                    }
                };

            renderPlotArea(categoryAxis, valueAxis);

            equal(gridLines.length, 32);
        });

        it("should not render gridlines for numeric axis", () => {
            const categoryAxis = {
                    categories: ["A"],
                    majorGridLines: {
                        visible: false
                    },
                    minorGridLines: {
                        visible: true
                    }
                },
                valueAxis = {
                    majorGridLines: {
                        visible: false
                    },
                    minorGridLines: {
                        visible: false
                    }
                };

            renderPlotArea(categoryAxis, valueAxis);

            equal(gridLines.length, 2);
        });

        it("should not render gridlines for category axis", () => {
            const categoryAxis = {
                    categories: ["A"]
                },
                valueAxis = {
                    majorGridLines: {
                        visible: false
                    },
                    minorGridLines: {
                        visible: true
                    }
                };

            renderPlotArea(categoryAxis, valueAxis);

            equal(gridLines.length, 30);
        });

        it("should not render gridlines", () => {
            const categoryAxis = {
                    categories: ["A"]
                },
                valueAxis = {
                    majorGridLines: {
                        visible: false
                    }
                };

            renderPlotArea(categoryAxis, valueAxis);

            equal(gridLines.length, 0);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Major and Minor GridLines', () => {

        it("should not render minor and major gridline to a same point", () => {
            const categoryAxis = {
                    categories: ["A"],
                    majorGridLines: {
                        visible: true
                    },
                    minorGridLines: {
                        visible: true
                    }
                },
                valueAxis = {
                    majorGridLines: {
                        visible: true
                    },
                    minorGridLines: {
                        visible: true
                    }
                };

            renderPlotArea(categoryAxis, valueAxis);

            equal(gridLines.length, 32);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Configuration', () => {

        it("applies margin", () => {
            const plotArea = new CategoricalPlotArea([{
                    data: [100]
                }], {
                categoryAxis: {
                    categories: ["A", "B"],
                    labels: { font: SANS12 }
                },
                valueAxis: {
                    labels: { font: SANS12 }
                },
                plotArea: {
                    margin: MARGIN,
                    background: "red"
                }
            });

            plotArea.reflow(chartBox);

            sameBox(plotArea.box, new Box(110, 110, 990, 990), TOLERANCE);
        });

        it("should render plot area with borders", () => {
            const categoryAxis = {
                    categories: ["A"]
                },
                valueAxis = { };

            renderPlotArea(categoryAxis, valueAxis, {
                plotArea: {
                    border: {
                        color: "red",
                        width: 2,
                        dashType: "dot"
                    }
                }
            });

            const rect = plotArea._bgVisual;
            const stroke = rect.options.stroke;
            equal(stroke.dashType, "dot");
            equal(stroke.color, "red");
            equal(stroke.width, 2);
            sameRectPath(rect.paths[0], [116, 100, 988, 976], TOLERANCE);
        });

        it("should render plot area background", () => {
            const categoryAxis = {
                    categories: ["A"]
                },
                valueAxis = { };

            renderPlotArea(categoryAxis, valueAxis, {
                plotArea: {
                    background: "color"
                }
            });

            const rect = plotArea._bgVisual;
            equal(rect.options.fill.color, "color");

            sameRectPath(rect.paths[0], [116, 100, 988, 976], TOLERANCE);
        });

        it("should render multipath with paths for each pane for the plot area background", () => {
            const categoryAxis = {
                    categories: ["A"]
                },
                valueAxis = [{

                }, {
                    pane: "second"
                }];

            plotArea = new CategoricalPlotArea([{
                data: [1],
                type: "column"
            }], {
                categoryAxis: categoryAxis,
                valueAxis: valueAxis,
                panes: [{}, { name: "second"}]
            });
            plotArea.reflow(chartBox);
            plotArea.renderVisual();

            const rect = plotArea._bgVisual;
            ok(rect instanceof draw.MultiPath);

            sameRectPath(rect.paths[0], [133, 107.5, 999, 526], TOLERANCE);
            sameRectPath(rect.paths[1], [133, 557.5, 999, 992.5], TOLERANCE);
        });

        it("should set plot area background opacity", () => {
            const categoryAxis = {
                    categories: ["A"]
                },
                valueAxis = { };

            renderPlotArea(categoryAxis, valueAxis, {
                plotArea: {
                    background: "color",
                    opacity: 0.5
                }
            });

            const rect = plotArea._bgVisual;
            equal(rect.options.fill.opacity, 0.5);
        });

        it("should render transparent plot area background by default", () => {
            const categoryAxis = {
                    categories: ["A"]
                },
                valueAxis = { };

            renderPlotArea(categoryAxis, valueAxis);

            const rect = plotArea._bgVisual;
            equal(rect.options.fill.color, "#fff");
            equal(rect.options.fill.opacity, 0);
        });
    });

})();

(function() {
    let plotArea;

    function createPlotArea(options, series) {
        plotArea = new CategoricalPlotArea(series || [{
            name: "Value A",
            type: "column",
            data: [100]
        }], deepExtend({
            categoryAxis: {
                categories: ["A"]
            },
            valueAxis: { }
        }, options));
        plotArea.chart = {};
        plotArea.createCrosshairs();
        plotArea.reflow(chartBox);
    }

    function renderPlotArea(series, options) {
        createPlotArea(series, options);
        plotArea.renderVisual();
    }

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Panes / Vertical', () => {

        it("default pane is created", () => {
            createPlotArea();

            equal(plotArea.panes.length, 1);
        });

        it("default pane height is same as plot area height", () => {
            createPlotArea();

            equal(plotArea.panes[0].box.height(), plotArea.box.height());
        });

        it("default pane width is same as plot area width", () => {
            createPlotArea();

            equal(plotArea.panes[0].box.width(), plotArea.box.width());
        });

        it("panes are created", () => {
            createPlotArea({
                panes: [{ name: "a" }, { name: "b" }]
            });

            equal(plotArea.panes.length, 2);
        });

        it("one chart is created per pane", () => {
            plotArea = new CategoricalPlotArea([{
                name: "Value A",
                type: "column",
                data: [100]
            }, {
                name: "Value B",
                type: "column",
                data: [200]
            }], { });

            equal(plotArea.charts.length, 1);
        });

        it("two panes occupy 50% height each by default", () => {
            createPlotArea({
                panes: [{ name: "a" }, { name: "b" }]
            });

            const halfHeight = plotArea.box.height() / 2;
            equal(plotArea.panes[0].box.height(), halfHeight);
            equal(plotArea.panes[1].box.height(), halfHeight);
        });

        it("second pane is positioned below the first", () => {
            createPlotArea({
                panes: [{ name: "a" }, { name: "b" }]
            });

            equal(plotArea.panes[0].box.y1, 100);
            equal(plotArea.panes[1].box.y1, 550);
        });

        it("pane occupies set height in pixels", () => {
            createPlotArea({
                panes: [{ name: "a", height: 200 }, { name: "b" }]
            });

            equal(plotArea.panes[0].box.height(), 200);
        });

        it("pane occupies remaining height (in pixels)", () => {
            createPlotArea({
                panes: [{ name: "a", height: 200 }, { name: "b" }]
            });

            equal(plotArea.panes[1].box.height(), 700);
        });

        it("first pane occupies set height in percents", () => {
            createPlotArea({
                panes: [{ name: "a", height: "30%" }, { name: "b" }]
            });

            equal(plotArea.panes[0].box.height(), 270);
        });

        it("second pane occupies remaining height (in percents)", () => {
            createPlotArea({
                panes: [{ name: "a", height: "30%" }, { name: "b" }]
            });

            equal(plotArea.panes[1].box.height(), 630);
        });

        it("second pane occupies set height in percents", () => {
            createPlotArea({
                panes: [{ name: "a" }, { name: "b", height: "30%" }]
            });

            equal(plotArea.panes[1].box.height(), 270);
        });

        it("first pane occupies remaining height (in percents)", () => {
            createPlotArea({
                panes: [{ name: "a" }, { name: "b", height: "30%" }]
            });

            equal(plotArea.panes[0].box.height(), 630);
        });

        it("top margin is included in pane height", () => {
            createPlotArea({
                panes: [{
                    name: "a", height: 200, margin: { top: 10 }
                }, {
                    name: "b"
                }]
            });

            equal(plotArea.panes[0].box.height(), 200);
            equal(plotArea.panes[1].box.height(), 700);
        });

        it("top margin is applied", () => {
            createPlotArea({
                panes: [{
                    name: "a", height: 200, margin: { top: 10 }
                }, {
                    name: "b"
                }]
            });

            equal(plotArea.panes[0].paddingBox.y1, 110);
        });

        it("bottom margin is included in pane height", () => {
            createPlotArea({
                panes: [{
                    name: "a", height: 200, margin: { bottom: 10 }
                }, {
                    name: "b"
                }]
            });

            equal(plotArea.panes[0].box.height(), 200);
            equal(plotArea.panes[1].box.height(), 700);
        });

        it("bottom margin is applied", () => {
            createPlotArea({
                panes: [{
                    name: "a", height: 200, margin: { bottom: 10 }
                }, {
                    name: "b"
                }]
            });

            equal(plotArea.panes[0].paddingBox.y2, 290);
        });

        it("left margin is included in pane width", () => {
            createPlotArea({
                panes: [{
                    name: "a", margin: { left: 10 }
                }, {
                    name: "b"
                }]
            });

            equal(plotArea.panes[0].box.width(), plotArea.panes[1].box.width());
        });

        it("left margin is applied to pane", () => {
            createPlotArea({
                panes: [{
                    name: "a", margin: { left: 10 }
                }, {
                    name: "b"
                }]
            });

            equal(plotArea.panes[0].paddingBox.x1, 110);
        });

        it("left margin offsets value axis", () => {
            createPlotArea({
                panes: [{
                    name: "a", margin: { left: 10 }
                }, {
                    name: "b"
                }]
            });

            equal(plotArea.valueAxis.box.x1, 110);
        });

        it("right margin is included in pane width", () => {
            createPlotArea({
                panes: [{
                    name: "a", margin: { right: 10 }
                }, {
                    name: "b"
                }]
            });

            equal(plotArea.panes[0].box.width(), plotArea.panes[1].box.width());
        });

        it("right margin is applied to pane", () => {
            createPlotArea({
                panes: [{
                    name: "a", margin: { right: 10 }
                }, {
                    name: "b"
                }]
            });

            equal(plotArea.panes[0].paddingBox.x2, 990);
        });

        it("right margin offsets value axis", () => {
            createPlotArea({
                panes: [{
                    name: "a", margin: { right: 10 }
                }, {
                    name: "b"
                }],
                categoryAxis: {
                    axisCrossingValue: 1
                }
            });

            equal(plotArea.valueAxis.box.x2, 990);
        });

        it("value axis is rendered in the first pane by default", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }]
            });

            const axisBox = plotArea.valueAxis.box;
            const paneBox = plotArea.panes[0].box;

            ok(axisBox.height() < paneBox.height());
            ok(paneBox.y1 <= axisBox.y1);
            ok(axisBox.y2 <= paneBox.y2);
        });

        it("category axis is rendered in the first pane by default", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }]
            });

            equal(plotArea.categoryAxis.box.y1, 526);
        });

        it("value axis is moved to the associated pane", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                valueAxis: {
                    pane: "b"
                }
            });

            const axisBox = plotArea.valueAxis.box;
            const paneBox = plotArea.panes[1].box;

            ok(axisBox.height() < paneBox.height());
            ok(paneBox.y1 <= axisBox.y1);
        });

        it("value axis is within the associated pane", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                valueAxis: {
                    pane: "b"
                }
            });

            const axisBox = plotArea.valueAxis.box;
            const paneBox = plotArea.panes[1].box;

            ok(axisBox.height() < paneBox.height());
            ok(paneBox.y1 <= axisBox.y1);
        });

        it("category axis remains in the first pane", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                valueAxis: {
                    pane: "b"
                }
            });

            equal(plotArea.categoryAxis.box.y1, 526);
        });

        it("category axis fits in the first pane", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                valueAxis: {
                    pane: "b"
                }
            });

            equal(plotArea.categoryAxis.box.y2, plotArea.panes[0].box.y2);
        });

        it("category axis fits in the second pane", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                categoryAxis: {
                    pane: "b"
                }
            });

            equal(plotArea.categoryAxis.box.y2, plotArea.panes[1].box.y2);
        });

        it("right aligned value axis fits in the associated pane", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                valueAxis: {
                    pane: "b"
                },
                categoryAxis: {
                    axisCrossingValue: 1
                }
            });

            equal(plotArea.valueAxis.box.x2,
                   plotArea.panes[1].box.x2);
        });

        it("right aligned value axis is within the associated pane", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                valueAxis: {
                    pane: "b"
                },
                categoryAxis: {
                    axisCrossingValue: 1
                }
            });

            const axisBox = plotArea.valueAxis.box;
            const paneBox = plotArea.panes[1].box;
            ok(axisBox.height() < paneBox.height());
            ok(paneBox.y1 <= axisBox.y1);
        });

        it("secondary value axis is positioned in the designated pane", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                valueAxis: [{
                }, {
                    name: "secondary",
                    pane: "b"
                }]
            });

            equal(plotArea.namedValueAxes["secondary"].box.y1, 557.5);
        });

        it("secondary value axis is aligned to category axis", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                valueAxis: [{
                }, {
                    name: "secondary",
                    pane: "b",
                    labels: {
                        template: "long text"
                    }
                }]
            });

            equal(plotArea.namedValueAxes["secondary"].lineBox().x1,
                   plotArea.categoryAxis.lineBox().x1);
        });

        it("secondary value axis is aligned to category axis end", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                valueAxis: [{
                }, {
                    name: "secondary",
                    pane: "b"
                }],
                categoryAxis: {
                    axisCrossingValue: [0, 1]
                }
            });

            equal(plotArea.namedValueAxes["secondary"].lineBox().x1,
                   plotArea.categoryAxis.lineBox().x2);
        });

        it("category axis in second pane is aligned to secondary value axis", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                valueAxis: [{
                    pane: "a",
                    min: 0,
                    max: 1,
                    axisCrossingValue: 0
                }, {
                    name: "secondary",
                    pane: "b",
                    min: 0,
                    max: 1,
                    axisCrossingValue: 1
                }],
                categoryAxis: {
                    pane: "b"
                }
            });

            equal(plotArea.categoryAxis.lineBox().y1,
                  plotArea.namedValueAxes["secondary"].lineBox().y1);
        });

        it("value axis in second pane is aligned to secondary category axis", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                valueAxis: [{
                    pane: "a"
                }, {
                    name: "secondary",
                    pane: "b"
                }],
                categoryAxis: [{
                    pane: "a",
                    categories: ["foo", "bar"],
                    axisCrossingValue: 1
                }, {
                    name: "secondary",
                    pane: "b",
                    categories: ["foo", "bar"],
                    axisCrossingValue: 2
                }]
            });

            equal(plotArea.namedCategoryAxes["secondary"].lineBox().x2,
                  plotArea.namedValueAxes["secondary"].lineBox().x1);
        });

        it("category axis labels are mirrored if it's on top of the pane", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                valueAxis: [{
                    pane: "a"
                }, {
                    name: "secondary",
                    pane: "b",
                    min: 0,
                    max: 1,
                    axisCrossingValue: 1
                }],
                categoryAxis: [{
                    pane: "a"
                }, {
                    name: "secondary",
                    pane: "b"
                }]
            });

            equal(plotArea.namedCategoryAxes["secondary"].options.labels.mirror, true);
        });

        it("right aligned secondary value axis fits in the associated pane", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                valueAxis: [{
                }, {
                    name: "secondary",
                    pane: "b"
                }],
                categoryAxis: {
                    axisCrossingValue: [0, 1]
                }
            });

            equal(plotArea.namedValueAxes["secondary"].box.x2 -
                   plotArea.panes[1].box.x2, 0);
        });

        it("left anchor axis is assigned per pane", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                valueAxis: [{
                }, {
                    name: "secondary",
                    pane: "b"
                }]
            });

            equal(plotArea.namedValueAxes["secondary"].box.x2,
                   plotArea.valueAxis.box.x2);
        });

        it("right anchor axis is assigned per pane", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                valueAxis: [{
                }, {
                    name: "secondary",
                    pane: "b"
                }],
                categoryAxis: {
                    axisCrossingValue: [1, 1]
                }
            });

            equal(plotArea.namedValueAxes["secondary"].box.x1,
                   plotArea.valueAxis.box.x1);
        });

        it("chart pane determined by series axis", () => {
            plotArea = new CategoricalPlotArea([{
                type: "column",
                data: [1],
                name: "series",
                axis: "b"
            }], {
                panes: [{
                    name: "top"
                }, {
                    name: "bottom"
                }],
                valueAxis: [{
                }, {
                    name: "b",
                    pane: "bottom"
                }]
            });

            equal(plotArea.panes[1].charts[0].options.series[0].name, "series");
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Panes / Title', () => {

        it("title is not visible by default", () => {
            createPlotArea({
                panes: [{
                    name: "a"
                }]
            });

            const textBox = plotArea.panes[0].title;
            equal(textBox, undefined);
        });

        it("title is aligned in pane center", () => {
            createPlotArea({
                panes: [{
                    name: "a",
                    title: {
                        text: "Title",
                        align: "center"
                    }
                }]
            });

            const textBox = plotArea.panes[0].title.children[0];
            equal(textBox.box.x1, 520, TOLERANCE);
        });

        it("title is aligned left by default", () => {
            createPlotArea({
                panes: [{
                    name: "a",
                    title: {
                        text: "Title"
                    }
                }]
            });

            const textBox = plotArea.panes[0].title.children[0];
            equal(textBox.box.x1, 100);
        });

        it("title is aligned right", () => {
            createPlotArea({
                panes: [{
                    name: "a",
                    title: {
                        text: "Title",
                        align: "right"
                    }
                }]
            });

            const textBox = plotArea.panes[0].title.children[0];
            equal(textBox.box.x1, 940, TOLERANCE);
        });

        it("title text can be set directly", () => {
            createPlotArea({
                panes: [{
                    name: "a",
                    title: "Title"
                }]
            });

            const textBox = plotArea.panes[0].title.children[0];
            equal(textBox.content, "Title");
        });

        it("title color is inherited from chart title", () => {
            createPlotArea({
                title: {
                    color: "salmon"
                },
                panes: [{
                    name: "a",
                    title: "Title"
                }]
            });

            const textBox = plotArea.panes[0].title.children[0];
            equal(textBox.options.color, "salmon");
        });

        it("title color can be set directly", () => {
            createPlotArea({
                panes: [{
                    name: "a",
                    title: {
                        text: "Title",
                        color: "salmon"
                    }
                }]
            });

            const textBox = plotArea.panes[0].title.children[0];
            equal(textBox.options.color, "salmon");
        });

        it("title color overrides chart title color", () => {
            createPlotArea({
                title: {
                    color: "fuschia"
                },
                panes: [{
                    name: "a",
                    title: {
                        text: "Title",
                        color: "salmon"
                    }
                }]
            });

            const textBox = plotArea.panes[0].title.children[0];
            equal(textBox.options.color, "salmon");
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Panes / redraw', () => {
        beforeEach(() => {
            renderPlotArea({
                categoryAxis: {
                    name: "cAxis"
                },
                valueAxis: {
                    name: "vAxis"
                },
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }]
                }, [{
                    type: "column",
                    data: [1000],
                    axis: "vAxis"
                }]
            );
        });

        it("Removes pane axes from plotArea.axes collection", () => {
            plotArea.axes[1].dirty = true;
            plotArea.redraw(plotArea.panes[0]);

            ok(!plotArea.axes[1].dirty);
        });

        it("Removes pane axes from namedCategoryAxes collection", () => {
            plotArea.namedCategoryAxes["cAxis"].dirty = true;
            plotArea.redraw(plotArea.panes[0]);

            ok(!plotArea.namedCategoryAxes["cAxis"].dirty);
        });

        it("Removes pane axes from namedValueAxes collection", () => {
            plotArea.namedValueAxes["vAxis"].dirty = true;
            plotArea.redraw(plotArea.panes[0]);

            ok(!plotArea.namedValueAxes["vAxis"].dirty);
        });

        it("Removes pane axes from pane.axes collection", () => {
            renderPlotArea({
                panes: [{
                    name: "a"
                }]
            });

            plotArea.panes[0].axes[0].dirty = true;
            plotArea.redraw(plotArea.panes[0]);

            ok(!plotArea.panes[0].axes[0].dirty);
        });

        it("Resets range tracker for pane value axes", () => {
            plotArea.series[0].data[0] = 10;
            plotArea.redraw(plotArea.panes[0]);

            equal(plotArea.valueAxisRangeTracker.query("vAxis").max, 10);
        });

        it("Resets range tracker for pane value axes (empty series)", () => {
            plotArea.series[0].data[0] = undefined;
            plotArea.redraw(plotArea.panes[0]);

            equal(plotArea.valueAxisRangeTracker.query("vAxis"), undefined);
        });

        it("Updates plotArea.categoryAxis alias", () => {
            plotArea.panes[0].axes[0].dirty = true;
            plotArea.redraw(plotArea.panes[0]);

            ok(!plotArea.categoryAxis.dirty);
        });

        it("Updates plotArea.valueAxis alias", () => {
            plotArea.panes[0].axes[1].dirty = true;
            plotArea.redraw(plotArea.panes[0]);

            ok(!plotArea.valueAxis.dirty);
        });

        it("Updates plotArea.axisX alias", () => {
            plotArea.panes[0].axes[0].dirty = true;
            plotArea.redraw(plotArea.panes[0]);

            ok(!plotArea.axisX.dirty);
        });

        it("Does not update plotArea.axisX alias if axis is not primary", () => {
            plotArea.axisX.dirty = true;
            plotArea.redraw(plotArea.panes[1]);

            ok(plotArea.axisX.dirty);
        });

        it("Updates plotArea.axisY alias", () => {
            plotArea.panes[0].axes[1].dirty = true;
            plotArea.redraw(plotArea.panes[0]);

            ok(!plotArea.axisY.dirty);
        });

        it("Does not update plotArea.axisY alias if axis is not primary", () => {
            plotArea.axisY.dirty = true;
            plotArea.redraw(plotArea.panes[1]);

            ok(plotArea.axisY.dirty);
        });

        it("clears pane", () => {
            plotArea.panes[0].chartContainer.children[0].dirty = true;
            plotArea.redraw(plotArea.panes[0]);

            ok(!plotArea.panes[0].chartContainer.children[0].dirty);
        });

        it("reflows pane", () => {
            const x = plotArea.axes[0].box.x1;

            plotArea.series[0].data[0] = 10;
            plotArea.redraw(plotArea.panes[0]);

            expect(plotArea.axes[0].box.x1).not.toEqual(x);
        });

        it("replaces pane content in DOM", () => {
            const chart = createChart({
                series: [{
                    type: "column",
                    data: [1000]
                }]
            });

            plotArea = chart._model.children[1];
            const pane = plotArea.panes[0];
            const element = getChartDomElement(pane.content);

            plotArea.series[0].data[0] = 10;
            plotArea.redraw(plotArea.panes[0]);

            ok(getChartDomElement(pane.content) !== element);

            destroyChart(chart);
        });

        it("partial reflows account for axes in other panes", () => {
            renderPlotArea({
                categoryAxis: [{
                    name: "cAxis"
                }, {
                    name: "cAxisB",
                    pane: "b",
                    categories: [
                        "Looooooooooooooooooooooooooooooooooooooooooooooooooooooong"
                    ]
                }],
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }]
                }, [{
                    type: "column",
                    data: [1000]
                }]
            );

            const box = plotArea.namedCategoryAxes.cAxisB.box;
            plotArea.redraw(plotArea.panes[1]);

            sameBox(plotArea.namedCategoryAxes.cAxisB.box, box);
        });

        it("recreates crosshairs for the panes", () => {
            renderPlotArea({
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }],
                valueAxis: {
                    pane: "b",
                    crosshair: {
                        visible: true
                    }
                },
                categoryAxis: {
                    pane: "b",
                    crosshair: {
                        visible: true
                    }
                }
            });

            plotArea.crosshairs[0].dirty = true;
            plotArea.crosshairs[1].dirty = true;
            plotArea.redraw(plotArea.panes[1]);
            ok(!plotArea.crosshairs[0].dirty);
            ok(!plotArea.crosshairs[1].dirty);
        });

        it("destroys crosshairs", () => {
            renderPlotArea({
                valueAxis: {
                    crosshair: {
                        visible: true
                    }
                }
            });

            const crosshair = plotArea.crosshairs[0];
            createSpy(crosshair, "destroy");
            plotArea.redraw(plotArea.panes[0]);
            expect(crosshair.destroy).toHaveBeenCalledTimes(1);
        });

        it("destroys crosshairs on destroy", () => {
            renderPlotArea({
                valueAxis: {
                    crosshair: {
                        visible: true
                    }
                }
            });

            const crosshair = plotArea.crosshairs[0];
            createSpy(crosshair, "destroy");
            plotArea.destroy();
            expect(crosshair.destroy).toHaveBeenCalledTimes(1);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical PlotArea / Panes / redraw / batch', () => {
        beforeEach(() => {
            createPlotArea({
                categoryAxis: {
                    name: "cAxis"
                },
                valueAxis: {
                    name: "vAxis"
                },
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }]
                }, [{
                    type: "column",
                    data: [1000],
                    axis: "vAxis"
                }]
            );
        });

        it("redraws multiple panes", () => {
            renderPlotArea({
                categoryAxis: {
                    name: "cAxis"
                },
                valueAxis: [{
                    name: "vAxis"
                }, {
                    name: "vAxisB",
                    pane: "b"
                }, {
                    name: "vAxisC",
                    pane: "c"
                }],
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }, {
                    name: "c"
                }]
                }, [{
                    type: "column",
                    data: [1000],
                    axis: "vAxis"
                }]
            );

            plotArea.namedValueAxes.vAxisC.dirty = true;
            plotArea.redraw([plotArea.panes[0], plotArea.panes[1]]);

            ok(plotArea.namedValueAxes.vAxisC.dirty);
        });
    });

})();

// ------------------------------------------------------------
(function() {
    let plotArea;

    describe('CategoricalPlotArea / pointsBySeriesName', () => {
        beforeEach(() => {
            plotArea = new CategoricalPlotArea([{
                type: "line",
                data: [100],
                name: "lineSeries"
            }, {
                type: "bar",
                data: [200],
                name: "barSeries"
            }]);
        });

        it("finds points based on series name", () => {
           let points = plotArea.pointsBySeriesName("lineSeries");
           equal(points.length, 1);
           equal(points[0].value, 100);
           ok(points[0] instanceof LinePoint);

           points = plotArea.pointsBySeriesName("barSeries");
           equal(points.length, 1);
           equal(points[0].value, 200);
           ok(points[0] instanceof Bar);
        });

        it("returns empty array if there isn't series with matching name", () => {
           const points = plotArea.pointsBySeriesName("foo");
           equal(points.length, 0);
        });
    });

})();

(function() {
    const TOLERANCE = 5;
    let chart, bar, barElement, plotArea, plotAreaElement;

    function createBarChart(options) {
        chart = createChart(deepExtend({
            series: [{
                type: "bar",
                data: [1, 2]
            }],
            categoryAxis: {
                categories: ["A", "B"]
            },
            chartArea: {
                width: 1664,
                height: 400
            }
        }, options));

        $("#container").css({
            position: "absolute", top: "200px", left: "8px"
        });

        plotArea = chart._model.children[1];
        bar = plotArea.charts[0].points[0];
        barElement = getChartDomElement(bar);
        plotAreaElement = getChartDomElement(plotArea);
    }

    // ------------------------------------------------------------
    describe('Categorical Plot Area / Events / plotAreaClick', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("point click bubbles to plot area", 1, () => {
            createBarChart({
                plotAreaClick: function() { ok(true); }
            });

            clickChart(chart, barElement, 300, 300);
        });

        it("fires when clicking plot area directly", 1, () => {
            createBarChart({
                plotAreaClick: function() { ok(true); }
            });

            clickChart(chart, plotAreaElement, 300, 300);
        });

        it("does not fire when clicking outside of axis range", 0, () => {
            createBarChart({
                plotAreaClick: function() { ok(false); }
            });

            clickChart(chart, plotAreaElement, 300, 580);
        });

        it("does not fire when clicking on axes", 0, () => {
            createBarChart({
                plotAreaClick: function() { ok(false); }
            });

            clickChart(chart, plotAreaElement, 3000, 0);
        });

        it("event arguments contain value", 1, () => {
            createBarChart({
                plotAreaClick: function(e) { close(e.value, 0.4, TOLERANCE); }
            });

            clickChart(chart, plotAreaElement, 300, 300);
        });

        it("event arguments contain multiple values", 2, () => {
            createBarChart({
                valueAxis: [{}, { name: "b", min: 100, max: 1000 }],
                plotAreaClick: function(e) { arrayClose(e.value, [1, 250], TOLERANCE); }
            });

            clickChart(chart, plotAreaElement, 300, 300);
        });

        it("event arguments contain category", 1, () => {
            createBarChart({
                plotAreaClick: function(e) { equal(e.category, "A"); }
            });

            clickChart(chart, plotAreaElement, 300, 300);
        });

        it("event arguments contain empty category", 1, () => {
            createBarChart({
                categoryAxis: {
                    categories: ["A"]
                },
                plotAreaClick: function(e) { equal(e.category, ""); }
            });

            clickChart(chart, plotAreaElement, 300, 400);
        });

        it("event arguments contain all categories", 1, () => {
            createBarChart({
                categoryAxis: [{
                    categories: ["A", "B"]
                }, {
                    categories: ["a", "b"]
                }],
                plotAreaClick: function(e) { equal(e.category, ["A", "a"]); }
            });

            clickChart(chart, plotAreaElement, 300, 300);
        });

        it("event arguments contain categories when second axis is moved", 1, () => {
            createBarChart({
                categoryAxis: [{
                    categories: ["A", "B"]
                }, {
                    categories: ["a", "b"]
                }],
                valueAxis: {
                    axisCrossingValue: [0, 100]
                },
                plotAreaClick: function(e) { equal(e.category, ["A", "a"]); }
            });

            clickChart(chart, plotAreaElement, 300, 300);
        });

        it("event arguments contain date category", 1, () => {
            const date = new Date("2012/09/15");
            createBarChart({
                categoryAxis: {
                    categories: [date]
                },
                plotAreaClick: function(e) { equal(e.category.toString(), date.toString()); }
            });

            clickChart(chart, plotAreaElement, 300, 300);
        });
    });

    // ------------------------------------------------------------
    describe('Categorical Plot Area / Events / plotAreaHover', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("point hover bubbles to plot area", 1, () => {
            createBarChart({
                plotAreaHover: function() { ok(true); }
            });

            triggerEvent("mousemove", barElement, 300, 300);
        });

        it("fires when hovering plot area directly", 1, () => {
            createBarChart({
                plotAreaHover: function() { ok(true); }
            });

            triggerEvent("mousemove", plotAreaElement, 300, 300);
        });

        it("does not fire when hovering outside of axis range", 0, () => {
            createBarChart({
                plotAreaHover: function() { ok(false); }
            });

            triggerEvent("mousemove", plotAreaElement, 300, 580);
        });

        it("does not fire when hovering on axes", 0, () => {
            createBarChart({
                plotAreaHover: function() { ok(false); }
            });

            triggerEvent("mousemove", plotAreaElement, 3000, 0);
        });
    });

    // ------------------------------------------------------------
    function createChartWithPanes(plotAreaClick) {
        chart = createChart({
            panes: [{
                name: "top"
            }, {
                name: "bottom"
            }],
            categoryAxis: [{
                name: "catA",
                pane: "top",
                categories: ["A", "B"]
            }, {
                name: "catB",
                pane: "bottom",
                categories: ["C"]
            }],
            valueAxis: [{
                name: "valA",
                pane: "top"
            }, {
                name: "valB",
                pane: "bottom"
            }],
            series: [{
                axis: "valA",
                categoryAxis: "catA",
                data: [1, 2]
            }, {
                axis: "valB",
                categoryAxis: "catB",
                data: [10]
            }],
            plotAreaClick: plotAreaClick,
            chartArea: {
                width: 1664,
                height: 400
            }
        });

        $("#container").css({
            position: "absolute", top: "200px", left: "8px"
        });

        plotArea = chart._model.children[1];
        plotAreaElement = getChartDomElement(plotArea);
    }

    describe('Categorical Plot Area / Events / plotAreaClick / Panes', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("categories are scoped to pane", 1, () => {
            createChartWithPanes(
                function(e) {
                    equal(e.category, "C");
                }
            );

            clickChart(chart, plotAreaElement, 300, 450);
        });

        it("values are scoped to pane", 1, () => {
            createChartWithPanes(
                function(e) {
                    close(e.value, 9, TOLERANCE);
                }
            );

            clickChart(chart, plotAreaElement, 300, 450);
        });

        it("uses primary category axis if the pane lacks one", 1, () => {
            chart = createChart({
                panes: [{
                    name: "top"
                }, {
                    name: "bottom"
                }],
                categoryAxis: {
                    pane: "bottom",
                    categories: ["A", "B"]
                },
                valueAxis: {
                    pane: "top"
                },
                series: [{
                    data: [1, 2]
                }],
                plotAreaClick: function(e) {
                    equal(e.category, "A")
                },
                chartArea: {
                    width: 1664,
                    height: 400
                }
            });

            $("#container").css({
                position: "absolute", top: "200px", left: "8px"
            });

            plotArea = chart._model.children[1];
            plotAreaElement = getChartDomElement(plotArea);
            clickChart(chart, plotAreaElement, 300, 300);
        });
    });

})();

// ------------------------------------------------------------
describe('PlotArea / pointsByCategoryIndex', () => {
    let plotArea;

    function createPlotArea() {
        plotArea = new CategoricalPlotArea([{
            name: "Value A",
            type: "bar",
            data: [1, null],
            gap: GAP
        }, {
            name: "Value B",
            type: "bar",
            data: [2, 3]
        }], {});
    }

    beforeEach(() => {
        createPlotArea();
    });

    it("return points", () => {
        equal(plotArea.pointsByCategoryIndex(0).length, 2);
    });

    it("return all points with some value", () => {
        equal(plotArea.pointsByCategoryIndex(1).length, 1);
    });

});
