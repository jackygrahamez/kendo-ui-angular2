module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(207);


/***/ },

/***/ 5:
/***/ function(module, exports) {

	module.exports = require("../../common/constants");

/***/ },

/***/ 7:
/***/ function(module, exports) {

	module.exports = require("../../common/defined");

/***/ },

/***/ 13:
/***/ function(module, exports) {

	module.exports = require("../../common/is-function");

/***/ },

/***/ 23:
/***/ function(module, exports) {

	module.exports = require("@progress/kendo-drawing");

/***/ },

/***/ 24:
/***/ function(module, exports) {

	module.exports = require("../constants");

/***/ },

/***/ 25:
/***/ function(module, exports) {

	module.exports = require("../../common/set-default-options");

/***/ },

/***/ 50:
/***/ function(module, exports) {

	module.exports = require("../../common/deep-extend");

/***/ },

/***/ 53:
/***/ function(module, exports) {

	module.exports = require("../../common/last");

/***/ },

/***/ 55:
/***/ function(module, exports) {

	module.exports = require("../../core");

/***/ },

/***/ 68:
/***/ function(module, exports) {

	module.exports = require("../../common/value-or-default");

/***/ },

/***/ 86:
/***/ function(module, exports) {

	module.exports = require("../../common/auto-format");

/***/ },

/***/ 158:
/***/ function(module, exports) {

	module.exports = require("../series-binder");

/***/ },

/***/ 162:
/***/ function(module, exports) {

	module.exports = require("../mixins/pie-chart-mixin");

/***/ },

/***/ 164:
/***/ function(module, exports) {

	module.exports = require("../utils/series-total");

/***/ },

/***/ 165:
/***/ function(module, exports) {

	module.exports = require("../utils/eval-options");

/***/ },

/***/ 166:
/***/ function(module, exports) {

	module.exports = require("../utils/segment-visible");

/***/ },

/***/ 207:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _kendoDrawing = __webpack_require__(23);

	var _seriesBinder = __webpack_require__(158);

	var _seriesBinder2 = _interopRequireDefault(_seriesBinder);

	var _pieSegment = __webpack_require__(208);

	var _pieSegment2 = _interopRequireDefault(_pieSegment);

	var _pieChartMixin = __webpack_require__(162);

	var _pieChartMixin2 = _interopRequireDefault(_pieChartMixin);

	var _core = __webpack_require__(55);

	var _constants = __webpack_require__(24);

	var _seriesTotal = __webpack_require__(164);

	var _seriesTotal2 = _interopRequireDefault(_seriesTotal);

	var _segmentVisible = __webpack_require__(166);

	var _segmentVisible2 = _interopRequireDefault(_segmentVisible);

	var _evalOptions = __webpack_require__(165);

	var _evalOptions2 = _interopRequireDefault(_evalOptions);

	var _constants2 = __webpack_require__(5);

	var _setDefaultOptions = __webpack_require__(25);

	var _setDefaultOptions2 = _interopRequireDefault(_setDefaultOptions);

	var _isFunction = __webpack_require__(13);

	var _isFunction2 = _interopRequireDefault(_isFunction);

	var _defined = __webpack_require__(7);

	var _defined2 = _interopRequireDefault(_defined);

	var _deepExtend = __webpack_require__(50);

	var _deepExtend2 = _interopRequireDefault(_deepExtend);

	var _valueOrDefault = __webpack_require__(68);

	var _valueOrDefault2 = _interopRequireDefault(_valueOrDefault);

	var _last = __webpack_require__(53);

	var _last2 = _interopRequireDefault(_last);

	var _round = __webpack_require__(209);

	var _round2 = _interopRequireDefault(_round);

	var _autoFormat = __webpack_require__(86);

	var _autoFormat2 = _interopRequireDefault(_autoFormat);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var PIE_SECTOR_ANIM_DELAY = 70;

	var PieChart = function (_ChartElement) {
	    _inherits(PieChart, _ChartElement);

	    function PieChart(plotArea, options) {
	        _classCallCheck(this, PieChart);

	        var _this = _possibleConstructorReturn(this, (PieChart.__proto__ || Object.getPrototypeOf(PieChart)).call(this, options));

	        _this.plotArea = plotArea;
	        _this.points = [];
	        _this.legendItems = [];
	        _this.render();
	        return _this;
	    }

	    _createClass(PieChart, [{
	        key: 'render',
	        value: function render() {
	            this.traverseDataPoints(this.addValue.bind(this));
	        }
	    }, {
	        key: 'traverseDataPoints',
	        value: function traverseDataPoints(callback) {
	            var options = this.options;
	            var _plotArea$options$ser = this.plotArea.options.seriesColors;
	            var seriesColors = _plotArea$options$ser === undefined ? [] : _plotArea$options$ser;

	            var colorsCount = seriesColors.length;
	            var series = options.series;
	            var seriesCount = series.length;

	            for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
	                var currentSeries = series[seriesIx];
	                var data = currentSeries.data;
	                var total = (0, _seriesTotal2.default)(currentSeries);
	                var anglePerValue = 360 / total;
	                var currentAngle = void 0;

	                if ((0, _defined2.default)(currentSeries.startAngle)) {
	                    currentAngle = currentSeries.startAngle;
	                } else {
	                    currentAngle = options.startAngle;
	                }

	                if (seriesIx !== seriesCount - 1) {
	                    if (currentSeries.labels.position === _constants.OUTSIDE_END) {
	                        currentSeries.labels.position = _constants2.CENTER;
	                    }
	                }

	                for (var i = 0; i < data.length; i++) {
	                    var pointData = _seriesBinder2.default.current.bindPoint(currentSeries, i);
	                    var value = pointData.valueFields.value;
	                    var plotValue = Math.abs(value);
	                    var fields = pointData.fields;
	                    var angle = plotValue * anglePerValue;
	                    var explode = data.length !== 1 && Boolean(fields.explode);

	                    if (!(0, _isFunction2.default)(currentSeries.color)) {
	                        currentSeries.color = fields.color || seriesColors[i % colorsCount];
	                    }

	                    var visible = (0, _segmentVisible2.default)(currentSeries, fields, i);

	                    callback(value, new _core.Ring(null, 0, 0, currentAngle, angle), {
	                        owner: this,
	                        category: fields.category || "",
	                        index: i,
	                        series: currentSeries,
	                        seriesIx: seriesIx,
	                        dataItem: data[i],
	                        percentage: total !== 0 ? plotValue / total : 0,
	                        explode: explode,
	                        visibleInLegend: fields.visibleInLegend,
	                        visible: visible,
	                        zIndex: seriesCount - seriesIx,
	                        animationDelay: this.animationDelay(i, seriesIx, seriesCount)
	                    });

	                    if (visible !== false) {
	                        currentAngle += angle;
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'evalSegmentOptions',
	        value: function evalSegmentOptions(options, value, fields) {
	            var series = fields.series;

	            (0, _evalOptions2.default)(options, {
	                value: value,
	                series: series,
	                dataItem: fields.dataItem,
	                category: fields.category,
	                percentage: fields.percentage
	            }, { defaults: series._defaults, excluded: ["data", "template", "visual", "toggle"] });
	        }
	    }, {
	        key: 'addValue',
	        value: function addValue(value, sector, fields) {
	            var segmentOptions = (0, _deepExtend2.default)({}, fields.series, { index: fields.index });
	            this.evalSegmentOptions(segmentOptions, value, fields);

	            this.createLegendItem(value, segmentOptions, fields);

	            if (fields.visible === false) {
	                return;
	            }

	            var segment = new _pieSegment2.default(value, sector, segmentOptions);
	            Object.assign(segment, fields);
	            this.append(segment);
	            this.points.push(segment);
	        }
	    }, {
	        key: 'reflow',
	        value: function reflow(targetBox) {
	            var options = this.options;
	            var points = this.points;
	            var _seriesConfigs = this.seriesConfigs;
	            var seriesConfigs = _seriesConfigs === undefined ? [] : _seriesConfigs;

	            var count = points.length;
	            var box = targetBox.clone();
	            var space = 5;
	            var minWidth = Math.min(box.width(), box.height());
	            var halfMinWidth = minWidth / 2;
	            var defaultPadding = minWidth - minWidth * 0.85;
	            var newBox = new _core.Box(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);
	            var newBoxCenter = newBox.center();
	            var boxCenter = box.center();
	            var seriesCount = options.series.length;
	            var leftSideLabels = [];
	            var rightSideLabels = [];
	            var padding = (0, _valueOrDefault2.default)(options.padding, defaultPadding);

	            padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;
	            newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);

	            var radius = halfMinWidth - padding;
	            var center = new _core.Point(radius + newBox.x1 + padding, radius + newBox.y1 + padding);

	            for (var i = 0; i < count; i++) {
	                var segment = points[i];
	                var sector = segment.sector;
	                var seriesIndex = segment.seriesIx;
	                sector.radius = radius;
	                sector.center = center;

	                if (seriesConfigs.length) {
	                    var seriesConfig = seriesConfigs[seriesIndex];
	                    sector.innerRadius = seriesConfig.innerRadius;
	                    sector.radius = seriesConfig.radius;
	                }

	                if (seriesIndex === seriesCount - 1 && segment.explode) {
	                    sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());
	                }

	                segment.reflow(newBox);

	                var label = segment.label;
	                if (label) {
	                    if (label.options.position === _constants.OUTSIDE_END) {
	                        if (seriesIndex === seriesCount - 1) {
	                            if (label.orientation === _constants2.RIGHT) {
	                                rightSideLabels.push(label);
	                            } else {
	                                leftSideLabels.push(label);
	                            }
	                        }
	                    }
	                }
	            }

	            if (leftSideLabels.length > 0) {
	                leftSideLabels.sort(this.labelComparator(true));
	                this.leftLabelsReflow(leftSideLabels);
	            }

	            if (rightSideLabels.length > 0) {
	                rightSideLabels.sort(this.labelComparator(false));
	                this.rightLabelsReflow(rightSideLabels);
	            }

	            this.box = newBox;
	        }
	    }, {
	        key: 'leftLabelsReflow',
	        value: function leftLabelsReflow(labels) {
	            var distances = this.distanceBetweenLabels(labels);

	            this.distributeLabels(distances, labels);
	        }
	    }, {
	        key: 'rightLabelsReflow',
	        value: function rightLabelsReflow(labels) {
	            var distances = this.distanceBetweenLabels(labels);

	            this.distributeLabels(distances, labels);
	        }
	    }, {
	        key: 'distanceBetweenLabels',
	        value: function distanceBetweenLabels(labels) {
	            var segment = (0, _last2.default)(this.points);
	            var sector = segment.sector;
	            var count = labels.length - 1;
	            var lr = sector.radius + segment.options.labels.distance;
	            var distances = [];
	            var firstBox = labels[0].box;
	            var distance = (0, _round2.default)(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));

	            distances.push(distance);

	            for (var i = 0; i < count; i++) {
	                var secondBox = labels[i + 1].box;

	                firstBox = labels[i].box;
	                distance = (0, _round2.default)(secondBox.y1 - firstBox.y2);
	                distances.push(distance);
	            }
	            distance = (0, _round2.default)(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);
	            distances.push(distance);

	            return distances;
	        }
	    }, {
	        key: 'distributeLabels',
	        value: function distributeLabels(distances, labels) {
	            var count = distances.length;
	            var left = void 0,
	                right = void 0,
	                remaining = void 0;

	            for (var i = 0; i < count; i++) {
	                remaining = -distances[i];
	                left = right = i;

	                while (remaining > 0 && (left >= 0 || right < count)) {
	                    remaining = this._takeDistance(distances, i, --left, remaining);
	                    remaining = this._takeDistance(distances, i, ++right, remaining);
	                }
	            }

	            this.reflowLabels(distances, labels);
	        }
	    }, {
	        key: '_takeDistance',
	        value: function _takeDistance(distances, anchor, position, amount) {
	            var result = amount;
	            if (distances[position] > 0) {
	                var available = Math.min(distances[position], result);
	                result -= available;
	                distances[position] -= available;
	                distances[anchor] += available;
	            }

	            return result;
	        }
	    }, {
	        key: 'reflowLabels',
	        value: function reflowLabels(distances, labels) {
	            var segment = (0, _last2.default)(this.points);
	            var sector = segment.sector;
	            var labelOptions = segment.options.labels;
	            var labelsCount = labels.length;
	            var labelDistance = labelOptions.distance;
	            var boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();
	            var boxX = void 0;

	            distances[0] += 2;
	            for (var i = 0; i < labelsCount; i++) {
	                var label = labels[i];
	                var box = label.box;

	                boxY += distances[i];
	                boxX = this.hAlignLabel(box.x2, sector.clone().expand(labelDistance), boxY, boxY + box.height(), label.orientation === _constants2.RIGHT);

	                if (label.orientation === _constants2.RIGHT) {
	                    if (labelOptions.align !== _constants2.CIRCLE) {
	                        boxX = sector.radius + sector.center.x + labelDistance;
	                    }
	                    label.reflow(new _core.Box(boxX + box.width(), boxY, boxX, boxY));
	                } else {
	                    if (labelOptions.align !== _constants2.CIRCLE) {
	                        boxX = sector.center.x - sector.radius - labelDistance;
	                    }
	                    label.reflow(new _core.Box(boxX - box.width(), boxY, boxX, boxY));
	                }

	                boxY += box.height();
	            }
	        }
	    }, {
	        key: 'createVisual',
	        value: function createVisual() {
	            var connectors = this.options.connectors;
	            var points = this.points;

	            var count = points.length;
	            var space = 4;

	            _get(PieChart.prototype.__proto__ || Object.getPrototypeOf(PieChart.prototype), 'createVisual', this).call(this);

	            this._connectorLines = [];

	            for (var i = 0; i < count; i++) {
	                var segment = points[i];
	                var sector = segment.sector;
	                var label = segment.label;

	                var angle = sector.middle();
	                var connectorsColor = (segment.options.connectors || {}).color || connectors.color;

	                if (label) {
	                    var connectorLine = new _kendoDrawing.drawing.Path({
	                        stroke: {
	                            color: connectorsColor,
	                            width: connectors.width
	                        },
	                        animation: {
	                            type: _constants.FADEIN,
	                            delay: segment.animationDelay
	                        }
	                    });

	                    if (label.options.position === _constants.OUTSIDE_END && segment.value !== 0) {
	                        var box = label.box;
	                        var centerPoint = sector.center;
	                        var start = sector.point(angle);
	                        var middle = new _core.Point(box.x1, box.center().y);
	                        var sr = void 0,
	                            end = void 0,
	                            crossing = void 0;

	                        start = sector.clone().expand(connectors.padding).point(angle);
	                        connectorLine.moveTo(start.x, start.y);
	                        // TODO: Extract into a method to remove duplication
	                        if (label.orientation === _constants2.RIGHT) {
	                            end = new _core.Point(box.x1 - connectors.padding, box.center().y);
	                            crossing = intersection(centerPoint, start, middle, end);
	                            middle = new _core.Point(end.x - space, end.y);
	                            crossing = crossing || middle;
	                            crossing.x = Math.min(crossing.x, middle.x);

	                            if (this.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x < sector.center.x) {
	                                sr = sector.center.x + sector.radius + space;
	                                if (segment.options.labels.align !== _constants.COLUMN) {
	                                    if (sr < middle.x) {
	                                        connectorLine.lineTo(sr, start.y);
	                                    } else {
	                                        connectorLine.lineTo(start.x + space * 2, start.y);
	                                    }
	                                } else {
	                                    connectorLine.lineTo(sr, start.y);
	                                }
	                                connectorLine.lineTo(middle.x, end.y);
	                            } else {
	                                crossing.y = end.y;
	                                connectorLine.lineTo(crossing.x, crossing.y);
	                            }
	                        } else {
	                            end = new _core.Point(box.x2 + connectors.padding, box.center().y);
	                            crossing = intersection(centerPoint, start, middle, end);
	                            middle = new _core.Point(end.x + space, end.y);
	                            crossing = crossing || middle;
	                            crossing.x = Math.max(crossing.x, middle.x);

	                            if (this.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x > sector.center.x) {
	                                sr = sector.center.x - sector.radius - space;
	                                if (segment.options.labels.align !== _constants.COLUMN) {
	                                    if (sr > middle.x) {
	                                        connectorLine.lineTo(sr, start.y);
	                                    } else {
	                                        connectorLine.lineTo(start.x - space * 2, start.y);
	                                    }
	                                } else {
	                                    connectorLine.lineTo(sr, start.y);
	                                }
	                                connectorLine.lineTo(middle.x, end.y);
	                            } else {
	                                crossing.y = end.y;
	                                connectorLine.lineTo(crossing.x, crossing.y);
	                            }
	                        }

	                        connectorLine.lineTo(end.x, end.y);

	                        this._connectorLines.push(connectorLine);
	                        this.visual.append(connectorLine);
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'labelComparator',
	        value: function labelComparator(reverse) {
	            var reverseValue = reverse ? -1 : 1;

	            return function (a, b) {
	                var first = (a.parent.sector.middle() + 270) % 360;
	                var second = (b.parent.sector.middle() + 270) % 360;
	                return (first - second) * reverseValue;
	            };
	        }
	    }, {
	        key: 'hAlignLabel',
	        value: function hAlignLabel(originalX, sector, y1, y2, direction) {
	            var radius = sector.radius;
	            var _sector$center = sector.center;
	            var cx = _sector$center.x;
	            var cy = _sector$center.y;

	            var t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));

	            if (t > radius) {
	                return originalX;
	            }

	            return cx + Math.sqrt(radius * radius - t * t) * (direction ? 1 : -1);
	        }
	    }, {
	        key: 'pointInCircle',
	        value: function pointInCircle(point, center, radius) {
	            return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);
	        }
	    }, {
	        key: 'formatPointValue',
	        value: function formatPointValue(point, format) {
	            return (0, _autoFormat2.default)(format, point.value);
	        }
	    }, {
	        key: 'animationDelay',
	        value: function animationDelay(categoryIndex) {
	            return categoryIndex * PIE_SECTOR_ANIM_DELAY;
	        }
	    }]);

	    return PieChart;
	}(_core.ChartElement);

	function intersection(a1, a2, b1, b2) {
	    var uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
	    var ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);

	    var result = void 0;
	    if (ub !== 0) {
	        var ua = uat / ub;

	        result = new _core.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y));
	    }

	    return result;
	}

	(0, _setDefaultOptions2.default)(PieChart.prototype, {
	    startAngle: 90,
	    connectors: {
	        width: 1,
	        color: "#939393",
	        padding: 4
	    },
	    inactiveItems: {
	        markers: {},
	        labels: {}
	    }
	});

	(0, _deepExtend2.default)(PieChart.prototype, _pieChartMixin2.default);

	exports.default = PieChart;

/***/ },

/***/ 208:
/***/ function(module, exports) {

	module.exports = require("./pie-segment");

/***/ },

/***/ 209:
/***/ function(module, exports) {

	module.exports = require("../../common/round");

/***/ }

/******/ });