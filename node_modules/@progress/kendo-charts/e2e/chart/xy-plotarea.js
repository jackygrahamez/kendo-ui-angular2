import 'core-js/es6';
import { $ } from 'e2e-utils';

import XYPlotArea from '../../src/chart/plotarea/xy-plotarea';
import { deepExtend, inArray } from '../../src/common';
import { DateValueAxis, NumericAxis, Box } from '../../src/core';

import { ok, equal, close, arrayClose, createSpy, stubMethod } from '../../test/test-helpers';
import { clickChart, triggerEvent, createChart, destroyChart, getChartDomElement }  from '../test-helpers';
import '../../test/text-measure';

const chartBox = new Box(100, 100, 1000, 1000);
const TOLERANCE = 1;
const scatterSeriesData = [{
    name: "Value A",
    type: "scatter",
    data: [[100, 100], [200, 200], [300, 300]]
}, {
    name: "Value B",
    type: "scatter",
    data: [[10, 10], [20, 20], [30, 30]]
}];
let plotArea, categoryAxis, namedXAxes, namedYAxes, axisX,
    secondaryXAxis, axisY, secondaryYAxis, chartSeries;

function createPlotArea(series, options) {
    plotArea = new XYPlotArea(series, options);

    axisX = plotArea.axisX;
    axisY = plotArea.axisY;
    namedXAxes = plotArea.namedXAxes;
    namedYAxes = plotArea.namedYAxes;
    secondaryXAxis = namedXAxes.secondary;
    secondaryYAxis = namedYAxes.secondary;

    chartSeries = plotArea.charts[0];
}

function renderPlotArea(series, options) {
    createPlotArea(series, options);
    plotArea.reflow(chartBox);
    plotArea.renderVisual();
}

function assertAxisRange(axis, min, max, series, options) {
    const fn = XYPlotArea.prototype;
    stubMethod(fn, "createAxes",
        function(panes) {
            fn._stubbed["createAxes"].call(this, panes);
            equal(this[axis].options.min, min);
            equal(this[axis].options.max, max);
        },
        function() {
            plotArea = createPlotArea(series, options);
        }
    );
}

// ------------------------------------------------------------
describe('XY PlotArea / Axes', () => {
    beforeEach(() => {
        createPlotArea(scatterSeriesData);
    });

    it("appends primary X axis to pane content", () => {
        ok(inArray(axisX, plotArea.panes[0].content.children));
    });

    it("appends primary Y axis to pane content", () => {
        ok(inArray(axisY, plotArea.panes[0].content.children));
    });

    it("aligns axes at default crossing values", () => {
        plotArea.reflow(chartBox);

        const crossingSlotY = axisY.getSlot(axisY.options.axisCrossingValue);
        const crossingSlotX = axisX.getSlot(axisX.options.axisCrossingValue);
        equal([crossingSlotY.x1, crossingSlotY.y1], [crossingSlotX.x1, crossingSlotX.y1]);
    });

    it("aligns axises at non-default crossing values", () => {
        axisY.options.axisCrossingValue = 10;
        axisX.options.axisCrossingValue = 1;

        plotArea.reflow(chartBox);

        const crossingSlotY = axisY.getSlot(axisY.options.axisCrossingValue);
        const crossingSlotX = axisX.getSlot(axisX.options.axisCrossingValue);
        equal([crossingSlotY.x1, crossingSlotY.y1], [crossingSlotX.x1, crossingSlotX.y1], TOLERANCE);
    });

    it("X axis limit is [0, 1.2] when no series are configured", 2, () => {
        assertAxisRange("axisX", 0, 1.2, []);
    });

    it("Y axis limit is [0, 1.2] when no series are configured", 2, () => {
        assertAxisRange("axisY", 0, 1.2, []);
    });

    it("sets named primary X axis range (impl. series axis)", 2, () => {
        assertAxisRange("axisX", 0, 120,
            [{ type: "scatter", data: [[100, 0]] }],
            { xAxis: { name: "A" } }
        );
    });

    it("sets named primary X axis range (expl. series axis)", 2, () => {
        assertAxisRange("axisX", 0, 120,
            [{ type: "scatter", data: [[100, 0]], xAxis: "A" }],
            { xAxis: { name: "A" } }
        );
    });

    it("sets named primary X axis range (impl. series axis, 0 < value < 1)", 2, () => {
        assertAxisRange("axisX", 0, .12,
            [{ type: "scatter", data: [[.10, 0]] }],
            { xAxis: { name: "A" } }
        );
    });

    it("sets named primary X axis range (expl. series axis, 0 < value < 1)", 2, () => {
        assertAxisRange("axisX", 0, .12,
            [{ type: "scatter", data: [[.10, 0]], xAxis: "A" }],
            { xAxis: { name: "A" } }
        );
    });

    it("sets named primary X axis range (implicit series axis)", 2, () => {
        assertAxisRange("axisX", 0, 350, scatterSeriesData, { xAxis: { name: "A" } });
    });

    it("sets primary X axis range (date values as strings)", 2, () => {
        assertAxisRange("axisX", new Date("2012/01/31 00:00:00"), new Date("2012/02/03 00:00:00"),
            [{
                type: "scatter",
                data: [["2012/02/01 00:00:00", 0]]
            }, {
                type: "scatter",
                data: [["2012/02/02 00:00:00", 0]]
            }], {
                xAxis: { type: "date" }
            }
        );
    });

    it("sets named primary Y axis range (impl. series axis)", 2, () => {
        assertAxisRange("axisY", 0, 120,
            [{ type: "scatter", data: [[0, 100]] }],
            { yAxis: { name: "A" } }
        );
    });

    it("sets named primary Y axis range (expl. series axis)", 2, () => {
        assertAxisRange("axisY", 0, 120,
            [{ type: "scatter", data: [[0, 100]], yAxis: "A" }],
            { yAxis: { name: "A" } }
        );
    });

    it("sets named primary Y axis range (impl. series axis, 0 < value < 1)", 2, () => {
        assertAxisRange("axisY", 0, .12,
            [{ type: "scatter", data: [[0, .1]] }],
            { yAxis: { name: "A" } }
        );
    });

    it("sets named primary Y axis range (expl. series axis, 0 < value < 1)", 2, () => {
        assertAxisRange("axisY", 0, .12,
            [{ type: "scatter", data: [[0, .1]], yAxis: "A" }],
            { yAxis: { name: "A" } }
        );
    });

    it("sets named primary Y axis range (implicit series axis)", () => {
        assertAxisRange("axisY", 0, 350, scatterSeriesData, { yAxis: { name: "A" } });
    });

    it("creates Numeric axes by default", () => {
        ok(plotArea.axisX instanceof NumericAxis);
        ok(plotArea.axisY instanceof NumericAxis);
    });

    it("creates Date value axes", () => {
        createPlotArea(scatterSeriesData, {
            xAxis: {
                type: "date"
            },
            yAxis: {
                type: "date"
            }
        });

        ok(plotArea.axisX instanceof DateValueAxis);
        ok(plotArea.axisY instanceof DateValueAxis);
    });

    it("creates Date value axes with capitalized type", () => {
        createPlotArea(scatterSeriesData, {
            xAxis: {
                type: "Date"
            },
            yAxis: {
                type: "Date"
            }
        });

        ok(plotArea.axisX instanceof DateValueAxis);
        ok(plotArea.axisY instanceof DateValueAxis);
    });

    it("Automatically detects date X axis", () => {
        createPlotArea([{
            name: "Value A",
            type: "scatter",
            data: [[new Date(2012, 2, 1), 100]]
        }]);

        equal(plotArea.axisX.options.type, "date");
    });

    it("Automatically detects date X axis for bound series", () => {
        createPlotArea([{
            name: "Value A",
            type: "scatter",
            xField: "x",
            yField: "y",
            data: [{ x: new Date(2012, 2, 1), y: 100 }]
        }]);

        equal(plotArea.axisX.options.type, "date");
    });

    it("Automatically detects named date X axis for bound series", () => {
        createPlotArea([{
            name: "Value A",
            type: "scatter",
            xField: "x",
            yField: "y",
            data: [{ x: new Date(2012, 2, 1), y: 100 }]
        }], {
            xAxis: {
                name: "axis"
            }
        });

        equal(plotArea.axisX.options.type, "date");
    });

    it("Automatically detects date X axis from min setting", () => {
        createPlotArea([{
            name: "Value A",
            type: "scatter",
            data: []
        }], {
            xAxis: {
                min: new Date(2012, 2, 1)
            }
        });

        equal(plotArea.axisX.options.type, "date");
    });

    it("Automatically detects date X axis from max setting", () => {
        createPlotArea([{
            name: "Value A",
            type: "scatter",
            data: []
        }], {
            xAxis: {
                max: new Date(2012, 2, 1)
            }
        });

        equal(plotArea.axisX.options.type, "date");
    });

    it("Automatic detection of X axis can be overriden", () => {
        createPlotArea([{
            name: "Value A",
            type: "scatter",
            data: [[new Date(2012, 2, 1), 100]]
        }], {
            xAxis: {
                type: "numeric"
            }
        });

        ok(plotArea.axisX instanceof NumericAxis);
    });

    it("Automatic detection of X axis can be overriden (capitalized)", () => {
        createPlotArea([{
            name: "Value A",
            type: "scatter",
            data: [[new Date(2012, 2, 1), 100]]
        }], {
            xAxis: {
                type: "Numeric"
            }
        });

        ok(plotArea.axisX instanceof NumericAxis);
    });

    it("Automatically detects date Y axis", () => {
        createPlotArea([{
            name: "Value A",
            type: "scatter",
            data: [[100, new Date(2012, 2, 1)]]
        }]);

        equal(plotArea.axisY.options.type, "date");
    });

    it("Automatically detects date Y axis for bound series", () => {
        createPlotArea([{
            name: "Value A",
            type: "scatter",
            xField: "x",
            yField: "y",
            data: [{ x: 100, y: new Date(2012, 2, 1) }]
        }]);

        equal(plotArea.axisY.options.type, "date");
    });

    it("Automatically detects named date Y axis for bound series", () => {
        createPlotArea([{
            name: "Value A",
            type: "scatter",
            xField: "x",
            yField: "y",
            data: [{ x: 100, y: new Date(2012, 2, 1) }]
        }], {
            yAxis: {
                name: "axis"
            }
        });

        equal(plotArea.axisY.options.type, "date");
    });

    it("Automatically detects date Y axis from min setting", () => {
        createPlotArea([{
            name: "Value A",
            type: "scatter",
            data: []
        }], {
            yAxis: {
                min: new Date(2012, 2, 1)
            }
        });

        equal(plotArea.axisY.options.type, "date");
    });

    it("Automatically detects date Y axis from max setting", () => {
        createPlotArea([{
            name: "Value A",
            type: "scatter",
            data: []
        }], {
            yAxis: {
                max: new Date(2012, 2, 1)
            }
        });

        equal(plotArea.axisY.options.type, "date");
    });

    it("Automatic detection of Y axis can be overriden", () => {
        createPlotArea([{
            name: "Value A",
            type: "scatter",
            data: [[100, new Date(2012, 2, 1)]]
        }], {
            yAxis: {
                type: "numeric"
            }
        });

        ok(plotArea.axisY instanceof NumericAxis);
    });

    it("Automatic detection of Y axis can be overriden (capitalized)", () => {
        createPlotArea([{
            name: "Value A",
            type: "scatter",
            data: [[100, new Date(2012, 2, 1)]]
        }], {
            yAxis: {
                type: "Numeric"
            }
        });

        ok(plotArea.axisY instanceof NumericAxis);
    });
});

// ------------------------------------------------------------
describe('XY PlotArea / Multiple Axes', () => {
    beforeEach(() => {
        createPlotArea(scatterSeriesData, {
            xAxis: [{}, {
                name: "secondary"
            }],
            yAxis: [{}, {
                name: "secondary"
            }]
        });
    });

    it("assigns axisX alias to first named X axis", () => {
        createPlotArea(scatterSeriesData, {
            xAxis: [{ name: "a" }, { name: "b" }]
        });

        equal(plotArea.axisX.options.name, "a");
    });

    it("assigns axisY alias to first named Y axis", () => {
        createPlotArea(scatterSeriesData, {
            yAxis: [{ name: "a" }, { name: "b" }]
        });

        equal(plotArea.axisY.options.name, "a");
    });

    it("secondary X axis added to pane content", () => {
        ok(inArray(secondaryXAxis, plotArea.panes[0].content.children));
    });

    it("secondary Y axis added to pane content", () => {
        ok(inArray(secondaryYAxis, plotArea.panes[0].content.children));
    });

    it("aligns primary axes at default crossing values", () => {
        plotArea.reflow(chartBox);

        const crossingSlotY = axisY.getSlot(axisY.options.axisCrossingValue),
            crossingSlotX = axisX.getSlot(axisX.options.axisCrossingValue);
        equal([crossingSlotY.x1, crossingSlotY.y1], [crossingSlotX.x1, crossingSlotX.y1]);
    });

    it("secondary X axis on the right is contained in plot area", () => {
        createPlotArea(scatterSeriesData, {
            xAxis: [{ min: -350 }, { name: "secondary" }],
            yAxis: { axisCrossingValue: [0, 100], min: -350 }
        });

        plotArea.reflow(chartBox);

        equal(secondaryXAxis.lineBox().x2, axisX.lineBox().x2);
    });

    it("secondary X axis on the left is contained in plot area", () => {
        createPlotArea(scatterSeriesData, {
            xAxis: [{ min: -350 }, { name: "secondary", min: -1, max: 0 }],
            yAxis: { axisCrossingValue: [0, 100], min: -350 }
        });

        plotArea.reflow(chartBox);

        equal(secondaryXAxis.lineBox().x1, axisX.lineBox().x1);
    });

    it("secondary Y axis on top is contained in plot area", () => {
        createPlotArea(scatterSeriesData, {
            xAxis: { axisCrossingValue: [0, 100], min: -350 },
            yAxis: [{ min: -350 }, { name: "secondary" }]
        });

        plotArea.reflow(chartBox);

        equal(secondaryYAxis.lineBox().y1, axisY.lineBox().y1, TOLERANCE);
    });

    it("secondary Y axis on bottom is contained in plot area", () => {
        createPlotArea(scatterSeriesData, {
            xAxis: { axisCrossingValue: [0, 100], min: -350 },
            yAxis: [{ min: -350 }, { name: "secondary", min: -1, max: 0 }]
        });

        plotArea.reflow(chartBox);

        equal(secondaryYAxis.lineBox().y2, axisY.lineBox().y2);
    });

    it("Throws error when X axis name is duplicate", () => {
        expect(function() {
            plotArea = createPlotArea(scatterSeriesData, {
                xAxis: [{
                    name: "b"
                }, {
                    name: "b"
                }]
            });
        }).toThrowError(/X axis with name b is already defined/);
    });

    it("Throws error when Y axis name is duplicate", () => {
        expect(function() {
            plotArea = createPlotArea(scatterSeriesData, {
                yAxis: [{
                    name: "b"
                }, {
                    name: "b"
                }]
            });
        }).toThrowError(/Y axis with name b is already defined/);
    });
});

// ------------------------------------------------------------
describe('XY PlotArea / Multiple Axes / Stacked Top', () => {
    beforeEach(() => {
        createPlotArea(scatterSeriesData, {
            xAxis: [{}, { name: "secondary" }],
            yAxis: { axisCrossingValue: 10000 }
        });
    });

    it("overlapping X axes are shifted to the top", () => {
        const margin = secondaryXAxis.options.margin;

        plotArea.reflow(chartBox);

        equal(secondaryXAxis.box.y2, axisX.box.y1 - margin);
    });

    it("X axis can be superimposed using options._overlap", () => {
        axisX.options._overlap = true;
        secondaryXAxis.options._overlap = true;

        plotArea.reflow(chartBox);

        equal(secondaryXAxis.box.y1, axisX.box.y1);
    });

    it("stacked X axes on top are aligned", () => {
        plotArea.reflow(chartBox);

        equal([secondaryXAxis.lineBox().x1, secondaryXAxis.lineBox().x2],
             [axisX.lineBox().x1, axisX.lineBox().x2]
        );
    });

    it("stacked X axes on the top are mirrored", () => {
        plotArea.reflow(chartBox);

        ok(axisX.options.labels.mirror);
        ok(secondaryXAxis.options.labels.mirror);
    });

    it("mirroring inverts the mirror option", () => {
        axisX.options.labels.mirror = true;

        plotArea.reflow(chartBox);

        ok(!axisX.options.labels.mirror);
    });
});

// ------------------------------------------------------------
describe('XY PlotArea / Multiple Axes / Stacked Right', () => {
    beforeEach(() => {
        createPlotArea(scatterSeriesData, {
            xAxis: { axisCrossingValue: 10000 },
            yAxis: [{}, { name: "secondary" }]
        });
    });

    it("overlapping Y axes are shifted to the right", () => {
        const margin = secondaryYAxis.options.margin;

        plotArea.reflow(chartBox);

        equal([secondaryYAxis.box.x1, secondaryYAxis.box.y1],
             [axisY.box.x2 + margin, axisY.box.y1]
        );
    });

    it("Y axis can be superimposed using options._overlap", () => {
        axisY.options._overlap = true;
        secondaryYAxis.options._overlap = true;

        plotArea.reflow(chartBox);

        equal(secondaryYAxis.box.x2, axisY.box.x2);
    });

    it("stacked Y axes on right are aligned", () => {
        plotArea.reflow(chartBox);

        equal([secondaryYAxis.lineBox().y1, secondaryYAxis.lineBox().y2],
             [axisY.lineBox().y1, axisY.lineBox().y2]
        );
    });

    it("stacked Y axes on the right are mirrored", () => {
        plotArea.reflow(chartBox);

        ok(axisY.options.labels.mirror);
        ok(secondaryYAxis.options.labels.mirror);
    });

    it("mirroring inverts the mirror option", () => {
        axisY.options.labels.mirror = true;

        plotArea.reflow(chartBox);

        ok(!axisY.options.labels.mirror);
    });
});

// ------------------------------------------------------------
describe('XY PlotArea / Multiple Axes / Stacked Bottom', () => {
    beforeEach(() => {
        createPlotArea(scatterSeriesData, {
            xAxis: [{}, { name: "secondary" }]
        });
    });

    it("overlapping X axes are shifted to the bottom", () => {
        const margin = secondaryXAxis.options.margin;

        plotArea.reflow(chartBox);

        equal(secondaryXAxis.box.y1, axisX.box.y2 + margin);
    });

    it("stacked X axes on bottom are aligned", () => {
        plotArea.reflow(chartBox);

        equal([secondaryXAxis.lineBox().x1, secondaryXAxis.lineBox().x2],
             [axisX.lineBox().x1, axisX.lineBox().x2]
        );
    });

    it("stacked X axes on the bottom are not mirrored", () => {
        plotArea.reflow(chartBox);

        ok(!axisX.options.labels.mirror);
        ok(!secondaryXAxis.options.labels.mirror);
    });

    it("user set mirror option is not changed", () => {
        axisX.options.labels.mirror = true;

        plotArea.reflow(chartBox);

        ok(axisX.options.labels.mirror);
    });
});

// ------------------------------------------------------------
describe('XY PlotArea / Multiple Axes / Stacked Left', () => {
    beforeEach(() => {
        createPlotArea(scatterSeriesData, {
            yAxis: [{}, { name: "secondary" }]
        });
    });

    it("overlapping Y axes are stacked to the left", () => {
        const margin = secondaryYAxis.options.margin;

        plotArea.reflow(chartBox);

        equal([secondaryYAxis.box.x2, secondaryYAxis.box.y1],
             [axisY.box.x1 - margin, axisY.box.y1]
        );
    });

    it("stacked Y axes on left are aligned", () => {
        plotArea.reflow(chartBox);

        equal([secondaryYAxis.lineBox().y1, secondaryYAxis.lineBox().y2],
             [axisY.lineBox().y1, axisY.lineBox().y2]
        );
    });

    it("stacked Y axes on the left are not mirrored", () => {
        plotArea.reflow(chartBox);

        ok(!axisY.options.labels.mirror);
        ok(!secondaryYAxis.options.labels.mirror);
    });

    it("user set mirror option is not changed", () => {
        axisY.options.labels.mirror = true;

        plotArea.reflow(chartBox);

        ok(axisY.options.labels.mirror);
    });
});

// ------------------------------------------------------------
describe('XY PlotArea / Scatter series', () => {
    beforeEach(() => {
        createPlotArea(scatterSeriesData);
    });

    it("Scatter chart added to pane chart container", () => {
        ok(inArray(chartSeries, plotArea.panes[0].chartContainer.children));
    });
});

// ------------------------------------------------------------
describe('XY PlotArea / Bubble series', () => {
    beforeEach(() => {
        createPlotArea([{
                      type: "bubble",
                      data: []
        }]);
    });

    it("Bubble chart added to pane chart container", () => {
        ok(inArray(chartSeries, plotArea.panes[0].chartContainer.children));
    });
});

// ------------------------------------------------------------
describe('XY PlotArea / Scatter line series', () => {
    beforeEach(() => {
        createPlotArea([{ type: "scatterLine", data: [] }]);
    });

    it("Scatter line chart added to pane chart container", () => {
        ok(inArray(chartSeries, plotArea.panes[0].chartContainer.children));
    });
});

// ------------------------------------------------------------
describe('XY PlotArea / Panes / Redraw', () => {
    beforeEach(() => {
        renderPlotArea([{
                type: "scatter",
                xAxis: "xAxis",
                yAxis: "yAxis",
                data: [[1000, 1000]]
            }], {
                xAxis: {
                    name: "xAxis"
                },
                yAxis: {
                    name: "yAxis"
                },
                panes: [{
                    name: "a"
                }, {
                    name: "b"
                }]
            }
        );
    });

    it("Removes pane axes from plotArea.axes collection", () => {
        plotArea.axes[1].dirty = true;
        plotArea.redraw(plotArea.panes[0]);

        ok(!plotArea.axes[1].dirty);
    });

    it("Removes pane axes from namedXAxes collection", () => {
        plotArea.namedXAxes["xAxis"].dirty = true;
        plotArea.redraw(plotArea.panes[0]);

        ok(!plotArea.namedXAxes["xAxis"].dirty);
    });

    it("Removes pane axes from namedYAxes collection", () => {
        plotArea.namedYAxes["yAxis"].dirty = true;
        plotArea.redraw(plotArea.panes[0]);

        ok(!plotArea.namedYAxes["yAxis"].dirty);
    });

    it("Removes pane axes from pane.axes collection", () => {
        renderPlotArea({
            panes: [{
                name: "a"
            }]
        });

        plotArea.panes[0].axes[0].dirty = true;
        plotArea.redraw(plotArea.panes[0]);

        ok(!plotArea.panes[0].axes[0].dirty);
    });

    it("Resets range tracker for pane x axes", () => {
        plotArea.series[0].data[0][0] = 10;
        plotArea.redraw(plotArea.panes[0]);

        equal(plotArea.xAxisRangeTracker.query("xAxis").max, 10);
    });

    it("Resets range tracker for pane x axes (empty series)", () => {
        plotArea.series[0].data[0][0] = undefined;
        plotArea.redraw(plotArea.panes[0]);

        equal(plotArea.xAxisRangeTracker.query("xAxis"), undefined);
    });

    it("Resets range tracker for pane y axes", () => {
        plotArea.series[0].data[0][1] = 10;
        plotArea.redraw(plotArea.panes[0]);

        equal(plotArea.yAxisRangeTracker.query("yAxis").max, 10);
    });

    it("Resets range tracker for pane y axes (empty series)", () => {
        plotArea.series[0].data[0][1] = undefined;
        plotArea.redraw(plotArea.panes[0]);

        equal(plotArea.yAxisRangeTracker.query("yAxis"), undefined);
    });

    it("Updates plotArea.axisX alias", () => {
        plotArea.panes[0].axes[0].dirty = true;
        plotArea.redraw(plotArea.panes[0]);

        ok(!plotArea.axisX.dirty);
    });

    it("Does not update plotArea.axisX alias if axis is not primary", () => {
        plotArea.axisX.dirty = true;
        plotArea.redraw(plotArea.panes[1]);

        ok(plotArea.axisX.dirty);
    });

    it("Updates plotArea.axisY alias", () => {
        plotArea.panes[0].axes[1].dirty = true;
        plotArea.redraw(plotArea.panes[0]);

        ok(!plotArea.axisY.dirty);
    });

    it("Does not update plotArea.axisY alias if axis is not primary", () => {
        plotArea.axisY.dirty = true;
        plotArea.redraw(plotArea.panes[1]);

        ok(plotArea.axisY.dirty);
    });

    it("clears pane", () => {
        plotArea.panes[0].chartContainer.children[0].dirty = true;
        plotArea.redraw(plotArea.panes[0]);

        ok(!plotArea.panes[0].chartContainer.children[0].dirty);
    });

    it("reflows pane", () => {
        const x = plotArea.axes[0].box.x1;

        plotArea.series[0].data[0] = 10;
        plotArea.redraw(plotArea.panes[0]);

        expect(plotArea.axes[0].box.x1).not.toEqual(x);
    });
});

// ------------------------------------------------------------
describe('XY Plot Area / pointsBySeriesName', () => {
    let plotArea;
    beforeEach(() => {
        plotArea = new XYPlotArea([{
            type: "scatter",
            name: "seriesA",
            data: [[10, 20]]
        }, {
            type: "scatter",
            name: "seriesB",
            data: [[30, 40]]
        }]);
    });

    it("finds points based on series name", () => {
       let points = plotArea.pointsBySeriesName("seriesA");
       equal(points.length, 1);
       equal(points[0].value.x, 10);
       equal(points[0].value.y, 20);

       points = plotArea.pointsBySeriesName("seriesB");
       equal(points.length, 1);
       equal(points[0].value.x, 30);
       equal(points[0].value.y, 40);
    });

    it("returns nothing if there isn't series with matching name", () => {
       const points = plotArea.pointsBySeriesName("foo");
       equal(points.length, 0);
    });
});

(function() {
    const TOLERANCE = 1;
    let chart,
        point,
        pointElement,
        plotArea,
        plotAreaElement;

    function createScatterChart(options) {
        chart = createChart(deepExtend({
            series: [{
                name: "Value A",
                type: "scatter",
                data: [[100, 100]]
            }],
            chartArea: {
                width: 1664,
                height: 400
            }
        }, options));

        $("#container").css({
            position: "absolute", top: "200px", left: "8px"
        });

        plotArea = chart._model.children[1];
        plotAreaElement = getChartDomElement(plotArea);
        point = plotArea.charts[0].points[0];
        pointElement = getChartDomElement(point.marker);
    }

    function xyPlotAreaEventsTests(eventName, triggerEvent) {
        const eventOptions = {};
        // ------------------------------------------------------------
        describe("XY Plot Area / Events / " + eventName, () => {
            afterEach(() => {
                destroyChart(chart);
            });

            it("point event bubbles to plot area", 1, () => {
                eventOptions[eventName] = function() { ok(true); };

                createScatterChart(eventOptions);

                triggerEvent(chart, plotAreaElement, 300, 300);
            });

            it("fires on the plot area directly", 1, () => {
                eventOptions[eventName] = function() { ok(true); };

                createScatterChart(eventOptions);

                triggerEvent(chart, plotAreaElement, 300, 300);
            });

            it("does not fire when outside of axis range", 0, () => {
                eventOptions[eventName] = function() { ok(false); };

                createScatterChart(eventOptions);

                triggerEvent(chart, plotAreaElement, 3000, 0);
            });

            it("event arguments contain x axis value", 1, () => {
                eventOptions[eventName] = function(e) { close(e.x, 12, TOLERANCE); };
                createScatterChart(eventOptions);

                triggerEvent(chart, plotAreaElement, 200, 500);
            });

            it("event arguments contain multiple x axis values", 2, () => {
                eventOptions[eventName] = function(e) { arrayClose(e.x, [12, 192], TOLERANCE); };
                createScatterChart(deepExtend({
                    xAxis: [{}, { name: "b", min: 100, max: 1000 }]
                }, eventOptions));

                triggerEvent(chart, plotAreaElement, 200, 500);
            });

            it("event arguments contain y axis value", 1, () => {
                eventOptions[eventName] = function(e) { close(e.y, 24, TOLERANCE); };
                createScatterChart(eventOptions);

                triggerEvent(chart, plotAreaElement, 200, 500);
            });

            it("event arguments contain multiple y axis values", 2, () => {
                eventOptions[eventName] = function(e) { arrayClose(e.y, [24, 278], TOLERANCE); };
                createScatterChart(deepExtend({
                    yAxis: [{}, { name: "b", min: 100, max: 1000 }]
                }, eventOptions));

                triggerEvent(chart, plotAreaElement, 200, 500);
            });
        });
    }

    function hoverChart(chart, element, x = 0, y = 0) {
        triggerEvent("mousemove", element, x, y, true);
    }

    xyPlotAreaEventsTests("plotAreaClick", clickChart);
    xyPlotAreaEventsTests("plotAreaHover", hoverChart);
})();