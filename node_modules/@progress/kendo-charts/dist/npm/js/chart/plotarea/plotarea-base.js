module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(239);


/***/ },

/***/ 5:
/***/ function(module, exports) {

	module.exports = require("../../common/constants");

/***/ },

/***/ 7:
/***/ function(module, exports) {

	module.exports = require("../../common/defined");

/***/ },

/***/ 13:
/***/ function(module, exports) {

	module.exports = require("../../common/is-function");

/***/ },

/***/ 15:
/***/ function(module, exports) {

	module.exports = require("../../common/in-array");

/***/ },

/***/ 23:
/***/ function(module, exports) {

	module.exports = require("@progress/kendo-drawing");

/***/ },

/***/ 25:
/***/ function(module, exports) {

	module.exports = require("../../common/set-default-options");

/***/ },

/***/ 50:
/***/ function(module, exports) {

	module.exports = require("../../common/deep-extend");

/***/ },

/***/ 55:
/***/ function(module, exports) {

	module.exports = require("../../core");

/***/ },

/***/ 56:
/***/ function(module, exports) {

	module.exports = require("../../common/append");

/***/ },

/***/ 69:
/***/ function(module, exports) {

	module.exports = require("../../common/template");

/***/ },

/***/ 77:
/***/ function(module, exports) {

	module.exports = require("../../common/get-spacing");

/***/ },

/***/ 209:
/***/ function(module, exports) {

	module.exports = require("../../common/round");

/***/ },

/***/ 239:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _kendoDrawing = __webpack_require__(23);

	var _core = __webpack_require__(55);

	var _crosshair = __webpack_require__(240);

	var _crosshair2 = _interopRequireDefault(_crosshair);

	var _pane2 = __webpack_require__(241);

	var _pane3 = _interopRequireDefault(_pane2);

	var _constants = __webpack_require__(5);

	var _setDefaultOptions = __webpack_require__(25);

	var _setDefaultOptions2 = _interopRequireDefault(_setDefaultOptions);

	var _isString = __webpack_require__(242);

	var _isString2 = _interopRequireDefault(_isString);

	var _template = __webpack_require__(69);

	var _template2 = _interopRequireDefault(_template);

	var _isFunction = __webpack_require__(13);

	var _isFunction2 = _interopRequireDefault(_isFunction);

	var _append = __webpack_require__(56);

	var _append2 = _interopRequireDefault(_append);

	var _getSpacing = __webpack_require__(77);

	var _getSpacing2 = _interopRequireDefault(_getSpacing);

	var _inArray = __webpack_require__(15);

	var _inArray2 = _interopRequireDefault(_inArray);

	var _deepExtend = __webpack_require__(50);

	var _deepExtend2 = _interopRequireDefault(_deepExtend);

	var _round = __webpack_require__(209);

	var _round2 = _interopRequireDefault(_round);

	var _defined = __webpack_require__(7);

	var _defined2 = _interopRequireDefault(_defined);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var PlotAreaBase = function (_ChartElement) {
	    _inherits(PlotAreaBase, _ChartElement);

	    function PlotAreaBase(series, options) {
	        _classCallCheck(this, PlotAreaBase);

	        var _this = _possibleConstructorReturn(this, (PlotAreaBase.__proto__ || Object.getPrototypeOf(PlotAreaBase)).call(this, options));

	        _this.initFields(series, options);
	        _this.series = series;
	        _this.initSeries();
	        _this.charts = [];
	        _this.options.legend.items = [];
	        _this.axes = [];
	        _this.crosshairs = [];

	        _this.createPanes();
	        _this.render();
	        return _this;
	    }

	    _createClass(PlotAreaBase, [{
	        key: 'initFields',
	        value: function initFields() {}
	    }, {
	        key: 'initSeries',
	        value: function initSeries() {
	            var series = this.series;

	            for (var i = 0; i < series.length; i++) {
	                series[i].index = i;
	            }
	        }
	    }, {
	        key: 'createPanes',
	        value: function createPanes() {
	            var defaults = { title: { color: (this.options.title || {}).color } };
	            var panes = [];
	            var paneOptions = this.options.panes || [];
	            var panesLength = Math.max(paneOptions.length, 1);

	            function setTitle(options, defaults) {
	                if ((0, _isString2.default)(options.title)) {
	                    options.title = {
	                        text: options.title
	                    };
	                }

	                options.title = (0, _deepExtend2.default)({}, defaults.title, options.title);
	            }

	            for (var i = 0; i < panesLength; i++) {
	                var options = paneOptions[i] || {};
	                setTitle(options, defaults);

	                var currentPane = new _pane3.default(options);
	                currentPane.paneIndex = i;

	                panes.push(currentPane);
	                this.append(currentPane);
	            }

	            this.panes = panes;
	        }
	    }, {
	        key: 'createCrosshairs',
	        value: function createCrosshairs() {
	            var panes = arguments.length <= 0 || arguments[0] === undefined ? this.panes : arguments[0];

	            var chart = this.chart;
	            for (var i = 0; i < panes.length; i++) {
	                var pane = panes[i];
	                for (var j = 0; j < pane.axes.length; j++) {
	                    var axis = pane.axes[j];
	                    if (axis.options.crosshair && axis.options.crosshair.visible) {
	                        var currentCrosshair = new _crosshair2.default(chart, axis, axis.options.crosshair);

	                        this.crosshairs.push(currentCrosshair);
	                        pane.content.append(currentCrosshair);
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'removeCrosshairs',
	        value: function removeCrosshairs(pane) {
	            var crosshairs = this.crosshairs;
	            var axes = pane.axes;

	            for (var i = crosshairs.length - 1; i >= 0; i--) {
	                for (var j = 0; j < axes.length; j++) {
	                    if (crosshairs[i].axis === axes[j]) {
	                        crosshairs.splice(i, 1);
	                        break;
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'hideCrosshairs',
	        value: function hideCrosshairs() {
	            var crosshairs = this.crosshairs;
	            for (var idx = 0; idx < crosshairs.length; idx++) {
	                crosshairs[idx].hide();
	            }
	        }
	    }, {
	        key: 'findPane',
	        value: function findPane(name) {
	            var panes = this.panes;
	            var matchingPane = void 0;

	            for (var i = 0; i < panes.length; i++) {
	                if (panes[i].options.name === name) {
	                    matchingPane = panes[i];
	                    break;
	                }
	            }

	            return matchingPane || panes[0];
	        }
	    }, {
	        key: 'findPointPane',
	        value: function findPointPane(point) {
	            var panes = this.panes;
	            var matchingPane = void 0;

	            for (var i = 0; i < panes.length; i++) {
	                if (panes[i].box.containsPoint(point)) {
	                    matchingPane = panes[i];
	                    break;
	                }
	            }

	            return matchingPane;
	        }
	    }, {
	        key: 'appendAxis',
	        value: function appendAxis(axis) {
	            var pane = this.findPane(axis.options.pane);

	            pane.appendAxis(axis);
	            this.axes.push(axis);
	            axis.plotArea = this;
	        }
	    }, {
	        key: 'removeAxis',
	        value: function removeAxis(axisToRemove) {
	            var filteredAxes = [];

	            for (var i = 0; i < this.axes.length; i++) {
	                var axis = this.axes[i];
	                if (axisToRemove !== axis) {
	                    filteredAxes.push(axis);
	                } else {
	                    axis.destroy();
	                }
	            }

	            this.axes = filteredAxes;
	        }
	    }, {
	        key: 'appendChart',
	        value: function appendChart(chart, pane) {
	            this.charts.push(chart);
	            if (pane) {
	                pane.appendChart(chart);
	            } else {
	                this.append(chart);
	            }
	        }
	    }, {
	        key: 'removeChart',
	        value: function removeChart(chartToRemove) {
	            var filteredCharts = [];

	            for (var i = 0; i < this.charts.length; i++) {
	                var chart = this.charts[i];
	                if (chart !== chartToRemove) {
	                    filteredCharts.push(chart);
	                } else {
	                    chart.destroy();
	                }
	            }

	            this.charts = filteredCharts;
	        }
	    }, {
	        key: 'addToLegend',
	        value: function addToLegend(series) {
	            var count = series.length;
	            var legend = this.options.legend;
	            var labels = legend.labels || {};
	            var inactiveItems = legend.inactiveItems || {};
	            var inactiveItemsLabels = inactiveItems.labels || {};
	            var data = [];

	            for (var i = 0; i < count; i++) {
	                var currentSeries = series[i];
	                var seriesVisible = currentSeries.visible !== false;
	                if (currentSeries.visibleInLegend === false) {
	                    continue;
	                }

	                var text = currentSeries.name || "";
	                var labelTemplate = seriesVisible ? labels.template : inactiveItemsLabels.template || labels.template;
	                if (labelTemplate) {
	                    text = (0, _template2.default)(labelTemplate)({
	                        text: text,
	                        series: currentSeries
	                    });
	                }

	                var defaults = currentSeries._defaults;
	                var color = currentSeries.color;
	                if ((0, _isFunction2.default)(color) && defaults) {
	                    color = defaults.color;
	                }

	                var itemLabelOptions = void 0,
	                    markerColor = void 0;
	                if (seriesVisible) {
	                    itemLabelOptions = {};
	                    markerColor = color;
	                } else {
	                    itemLabelOptions = {
	                        color: inactiveItemsLabels.color,
	                        font: inactiveItemsLabels.font
	                    };
	                    markerColor = inactiveItems.markers.color;
	                }

	                if (text) {
	                    data.push({
	                        text: text,
	                        labels: itemLabelOptions,
	                        markerColor: markerColor,
	                        series: currentSeries,
	                        active: seriesVisible
	                    });
	                }
	            }

	            (0, _append2.default)(legend.items, data);
	        }
	    }, {
	        key: 'groupAxes',
	        value: function groupAxes(panes) {
	            var xAxes = [];
	            var yAxes = [];

	            for (var paneIx = 0; paneIx < panes.length; paneIx++) {
	                var paneAxes = panes[paneIx].axes;
	                for (var axisIx = 0; axisIx < paneAxes.length; axisIx++) {
	                    var axis = paneAxes[axisIx];
	                    if (axis.options.vertical) {
	                        yAxes.push(axis);
	                    } else {
	                        xAxes.push(axis);
	                    }
	                }
	            }

	            return { x: xAxes, y: yAxes, any: xAxes.concat(yAxes) };
	        }
	    }, {
	        key: 'groupSeriesByPane',
	        value: function groupSeriesByPane() {
	            var series = this.series;
	            var seriesByPane = {};

	            for (var i = 0; i < series.length; i++) {
	                var currentSeries = series[i];
	                var pane = this.seriesPaneName(currentSeries);

	                if (seriesByPane[pane]) {
	                    seriesByPane[pane].push(currentSeries);
	                } else {
	                    seriesByPane[pane] = [currentSeries];
	                }
	            }

	            return seriesByPane;
	        }
	    }, {
	        key: 'filterVisibleSeries',
	        value: function filterVisibleSeries(series) {
	            var result = [];

	            for (var i = 0; i < series.length; i++) {
	                var currentSeries = series[i];
	                if (currentSeries.visible !== false) {
	                    result.push(currentSeries);
	                }
	            }

	            return result;
	        }
	    }, {
	        key: 'reflow',
	        value: function reflow(targetBox) {
	            var options = this.options.plotArea;
	            var panes = this.panes;
	            var margin = (0, _getSpacing2.default)(options.margin);

	            this.box = targetBox.clone().unpad(margin);
	            this.reflowPanes();

	            this.reflowAxes(panes);
	            this.reflowCharts(panes);
	        }
	    }, {
	        key: 'redraw',
	        value: function redraw(panes) {
	            var panesArray = [].concat(panes);
	            this.initSeries();

	            for (var i = 0; i < panesArray.length; i++) {
	                this.removeCrosshairs(panesArray[i]);
	                panesArray[i].empty();
	            }

	            this.render(panesArray);
	            this.reflowAxes(this.panes);
	            this.reflowCharts(panesArray);

	            this.createCrosshairs(panesArray);

	            for (var _i = 0; _i < panesArray.length; _i++) {
	                panesArray[_i].refresh();
	            }
	        }
	    }, {
	        key: 'axisCrossingValues',
	        value: function axisCrossingValues(axis, crossingAxes) {
	            var options = axis.options;
	            var crossingValues = [].concat(options.axisCrossingValues || options.axisCrossingValue);
	            var valuesToAdd = crossingAxes.length - crossingValues.length;
	            var defaultValue = crossingValues[0] || 0;

	            for (var i = 0; i < valuesToAdd; i++) {
	                crossingValues.push(defaultValue);
	            }

	            return crossingValues;
	        }
	    }, {
	        key: 'alignAxisTo',
	        value: function alignAxisTo(axis, targetAxis, crossingValue, targetCrossingValue) {
	            var slot = axis.getSlot(crossingValue, crossingValue, true);
	            var slotEdge = axis.options.reverse ? 2 : 1;
	            var targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);
	            var targetEdge = targetAxis.options.reverse ? 2 : 1;
	            var axisBox = axis.box.translate(targetSlot[_constants.X + targetEdge] - slot[_constants.X + slotEdge], targetSlot[_constants.Y + targetEdge] - slot[_constants.Y + slotEdge]);

	            if (axis.pane !== targetAxis.pane) {
	                axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);
	            }

	            axis.reflow(axisBox);
	        }
	    }, {
	        key: 'alignAxes',
	        value: function alignAxes(xAxes, yAxes) {
	            var xAnchor = xAxes[0];
	            var yAnchor = yAxes[0];
	            var xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);
	            var yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);
	            var leftAnchors = {};
	            var rightAnchors = {};
	            var topAnchors = {};
	            var bottomAnchors = {};

	            for (var i = 0; i < yAxes.length; i++) {
	                var axis = yAxes[i];
	                var pane = axis.pane;
	                var paneId = pane.id;

	                // Locate pane anchor, if any, and use its axisCrossingValues
	                var anchor = paneAnchor(xAxes, pane) || xAnchor;
	                var anchorCrossings = xAnchorCrossings;

	                if (anchor !== xAnchor) {
	                    anchorCrossings = this.axisCrossingValues(anchor, yAxes);
	                }

	                this.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);

	                if (axis.options._overlap) {
	                    continue;
	                }

	                if ((0, _round2.default)(axis.lineBox().x1) === (0, _round2.default)(anchor.lineBox().x1)) {
	                    // Push the axis to the left the previous y-axis so they don't overlap
	                    if (leftAnchors[paneId]) {
	                        axis.reflow(axis.box.alignTo(leftAnchors[paneId].box, _constants.LEFT).translate(-axis.options.margin, 0));
	                    }

	                    leftAnchors[paneId] = axis;
	                }

	                if ((0, _round2.default)(axis.lineBox().x2) === (0, _round2.default)(anchor.lineBox().x2)) {
	                    // Flip the labels on the right if we're at the right end of the pane
	                    if (!axis._mirrored) {
	                        axis.options.labels.mirror = !axis.options.labels.mirror;
	                        axis._mirrored = true;
	                    }
	                    this.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);

	                    // Push the axis to the right the previous y-axis so they don't overlap
	                    if (rightAnchors[paneId]) {
	                        axis.reflow(axis.box.alignTo(rightAnchors[paneId].box, _constants.RIGHT).translate(axis.options.margin, 0));
	                    }

	                    rightAnchors[paneId] = axis;
	                }

	                if (i !== 0 && yAnchor.pane === axis.pane) {
	                    axis.alignTo(yAnchor);
	                    axis.reflow(axis.box);
	                }
	            }

	            for (var _i2 = 0; _i2 < xAxes.length; _i2++) {
	                var _axis = xAxes[_i2];
	                var _pane = _axis.pane;
	                var _paneId = _pane.id;

	                // Locate pane anchor and use its axisCrossingValues
	                var _anchor = paneAnchor(yAxes, _pane) || yAnchor;
	                var _anchorCrossings = yAnchorCrossings;
	                if (_anchor !== yAnchor) {
	                    _anchorCrossings = this.axisCrossingValues(_anchor, xAxes);
	                }

	                this.alignAxisTo(_axis, _anchor, xAnchorCrossings[_i2], _anchorCrossings[_i2]);

	                if (_axis.options._overlap) {
	                    continue;
	                }

	                if ((0, _round2.default)(_axis.lineBox().y1) === (0, _round2.default)(_anchor.lineBox().y1)) {
	                    // Flip the labels on top if we're at the top of the pane
	                    if (!_axis._mirrored) {
	                        _axis.options.labels.mirror = !_axis.options.labels.mirror;
	                        _axis._mirrored = true;
	                    }
	                    this.alignAxisTo(_axis, _anchor, xAnchorCrossings[_i2], _anchorCrossings[_i2]);

	                    // Push the axis above the previous x-axis so they don't overlap
	                    if (topAnchors[_paneId]) {
	                        _axis.reflow(_axis.box.alignTo(topAnchors[_paneId].box, _constants.TOP).translate(0, -_axis.options.margin));
	                    }

	                    topAnchors[_paneId] = _axis;
	                }

	                if ((0, _round2.default)(_axis.lineBox().y2, _constants.COORD_PRECISION) === (0, _round2.default)(_anchor.lineBox().y2, _constants.COORD_PRECISION)) {
	                    // Push the axis below the previous x-axis so they don't overlap
	                    if (bottomAnchors[_paneId]) {
	                        _axis.reflow(_axis.box.alignTo(bottomAnchors[_paneId].box, _constants.BOTTOM).translate(0, _axis.options.margin));
	                    }

	                    bottomAnchors[_paneId] = _axis;
	                }

	                if (_i2 !== 0) {
	                    _axis.alignTo(xAnchor);
	                    _axis.reflow(_axis.box);
	                }
	            }
	        }
	    }, {
	        key: 'shrinkAxisWidth',
	        value: function shrinkAxisWidth(panes) {
	            var axes = this.groupAxes(panes).any;
	            var axisBox = axisGroupBox(axes);
	            var overflowX = 0;

	            for (var i = 0; i < panes.length; i++) {
	                var currentPane = panes[i];

	                if (currentPane.axes.length > 0) {
	                    overflowX = Math.max(overflowX, axisBox.width() - currentPane.contentBox.width());
	                }
	            }

	            if (overflowX !== 0) {
	                for (var _i3 = 0; _i3 < axes.length; _i3++) {
	                    var currentAxis = axes[_i3];

	                    if (!currentAxis.options.vertical) {
	                        currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'shrinkAxisHeight',
	        value: function shrinkAxisHeight(panes) {
	            var shrinked = void 0;

	            for (var i = 0; i < panes.length; i++) {
	                var currentPane = panes[i];
	                var axes = currentPane.axes;
	                var overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());

	                if (overflowY !== 0) {
	                    for (var j = 0; j < axes.length; j++) {
	                        var currentAxis = axes[j];

	                        if (currentAxis.options.vertical) {
	                            currentAxis.reflow(currentAxis.box.shrink(0, overflowY));
	                        }
	                    }
	                    shrinked = true;
	                }
	            }

	            return shrinked;
	        }
	    }, {
	        key: 'fitAxes',
	        value: function fitAxes(panes) {
	            var axes = this.groupAxes(panes).any;
	            var offsetX = 0;

	            for (var i = 0; i < panes.length; i++) {
	                var currentPane = panes[i];
	                var paneAxes = currentPane.axes;
	                var paneBox = currentPane.contentBox;

	                if (paneAxes.length > 0) {
	                    var axisBox = axisGroupBox(paneAxes);
	                    // OffsetY is calculated and applied per pane
	                    var offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2);

	                    // OffsetX is calculated and applied globally
	                    offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);

	                    for (var j = 0; j < paneAxes.length; j++) {
	                        var currentAxis = paneAxes[j];

	                        currentAxis.reflow(currentAxis.box.translate(0, offsetY));
	                    }
	                }
	            }

	            for (var _i4 = 0; _i4 < axes.length; _i4++) {
	                var _currentAxis = axes[_i4];

	                _currentAxis.reflow(_currentAxis.box.translate(offsetX, 0));
	            }
	        }
	    }, {
	        key: 'reflowAxes',
	        value: function reflowAxes(panes) {
	            var axes = this.groupAxes(panes);

	            for (var i = 0; i < panes.length; i++) {
	                this.reflowPaneAxes(panes[i]);
	            }

	            if (axes.x.length > 0 && axes.y.length > 0) {
	                this.alignAxes(axes.x, axes.y);
	                this.shrinkAxisWidth(panes);

	                this.autoRotateAxisLabels(axes);

	                this.alignAxes(axes.x, axes.y);
	                if (this.shrinkAxisWidth(panes)) {
	                    this.alignAxes(axes.x, axes.y);
	                }

	                this.shrinkAxisHeight(panes);
	                this.alignAxes(axes.x, axes.y);

	                if (this.shrinkAxisHeight(panes)) {
	                    this.alignAxes(axes.x, axes.y);
	                }

	                this.fitAxes(panes);
	            }
	        }
	    }, {
	        key: 'autoRotateAxisLabels',
	        value: function autoRotateAxisLabels(groupedAxes) {
	            var axes = this.axes;
	            var panes = this.panes;

	            var rotated = void 0;

	            for (var idx = 0; idx < axes.length; idx++) {
	                var axis = axes[idx];
	                if (axis.autoRotateLabels()) {
	                    rotated = true;
	                }
	            }

	            if (rotated) {
	                for (var _idx = 0; _idx < panes.length; _idx++) {
	                    this.reflowPaneAxes(panes[_idx]);
	                }

	                if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {
	                    this.alignAxes(groupedAxes.x, groupedAxes.y);
	                    this.shrinkAxisWidth(panes);
	                }
	            }
	        }
	    }, {
	        key: 'reflowPaneAxes',
	        value: function reflowPaneAxes(pane) {
	            var axes = pane.axes;
	            var length = axes.length;

	            if (length > 0) {
	                for (var i = 0; i < length; i++) {
	                    axes[i].reflow(pane.contentBox);
	                }
	            }
	        }
	    }, {
	        key: 'reflowCharts',
	        value: function reflowCharts(panes) {
	            var charts = this.charts;
	            var count = charts.length;
	            var box = this.box;

	            for (var i = 0; i < count; i++) {
	                var chartPane = charts[i].pane;
	                if (!chartPane || (0, _inArray2.default)(chartPane, panes)) {
	                    charts[i].reflow(box);
	                }
	            }
	        }
	    }, {
	        key: 'reflowPanes',
	        value: function reflowPanes() {
	            var box = this.box;
	            var panes = this.panes;

	            var panesLength = panes.length;
	            var remainingHeight = box.height();
	            var remainingPanes = panesLength;
	            var autoHeightPanes = 0;
	            var top = box.y1;

	            for (var i = 0; i < panesLength; i++) {
	                var currentPane = panes[i];
	                var height = currentPane.options.height;

	                currentPane.options.width = box.width();

	                if (!currentPane.options.height) {
	                    autoHeightPanes++;
	                } else {
	                    if (height.indexOf && height.indexOf("%")) {
	                        var percents = parseInt(height, 10) / 100;
	                        currentPane.options.height = percents * box.height();
	                    }

	                    currentPane.reflow(box.clone());

	                    remainingHeight -= currentPane.options.height;
	                }
	            }

	            for (var _i5 = 0; _i5 < panesLength; _i5++) {
	                var _currentPane = panes[_i5];

	                if (!_currentPane.options.height) {
	                    _currentPane.options.height = remainingHeight / autoHeightPanes;
	                }
	            }

	            for (var _i6 = 0; _i6 < panesLength; _i6++) {
	                var _currentPane2 = panes[_i6];
	                var paneBox = box.clone().move(box.x1, top);

	                _currentPane2.reflow(paneBox);

	                remainingPanes--;
	                top += _currentPane2.options.height;
	            }
	        }
	    }, {
	        key: 'backgroundBox',
	        value: function backgroundBox() {
	            var axes = this.axes;
	            var axesCount = axes.length;
	            var box = void 0;

	            for (var i = 0; i < axesCount; i++) {
	                var axisA = axes[i];

	                for (var j = 0; j < axesCount; j++) {
	                    var axisB = axes[j];

	                    if (axisA.options.vertical !== axisB.options.vertical) {
	                        var lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());

	                        if (!box) {
	                            box = lineBox;
	                        } else {
	                            box = box.wrap(lineBox);
	                        }
	                    }
	                }
	            }

	            return box || this.box;
	        }
	    }, {
	        key: 'chartsBoxes',
	        value: function chartsBoxes() {
	            var panes = this.panes;
	            var boxes = [];

	            for (var idx = 0; idx < panes.length; idx++) {
	                boxes.push(panes[idx].chartsBox());
	            }

	            return boxes;
	        }
	    }, {
	        key: 'addBackgroundPaths',
	        value: function addBackgroundPaths(multipath) {
	            var boxes = this.chartsBoxes();
	            for (var idx = 0; idx < boxes.length; idx++) {
	                multipath.paths.push(_kendoDrawing.drawing.Path.fromRect(boxes[idx].toRect()));
	            }
	        }
	    }, {
	        key: 'backgroundContainsPoint',
	        value: function backgroundContainsPoint(point) {
	            var boxes = this.chartsBoxes();
	            for (var idx = 0; idx < boxes.length; idx++) {
	                if (boxes[idx].containsPoint(point)) {
	                    return true;
	                }
	            }
	        }
	    }, {
	        key: 'createVisual',
	        value: function createVisual() {
	            _get(PlotAreaBase.prototype.__proto__ || Object.getPrototypeOf(PlotAreaBase.prototype), 'createVisual', this).call(this);

	            var options = this.options.plotArea;
	            var opacity = options.opacity;
	            var background = options.background;
	            var _options$border = options.border;
	            var border = _options$border === undefined ? {} : _options$border;

	            if (isTransparent(background)) {
	                background = _constants.WHITE;
	                opacity = 0;
	            }

	            var bg = this._bgVisual = new _kendoDrawing.drawing.MultiPath({
	                fill: {
	                    color: background,
	                    opacity: opacity
	                },
	                stroke: {
	                    color: border.width ? border.color : "",
	                    width: border.width,
	                    dashType: border.dashType
	                },
	                zIndex: -1
	            });

	            this.addBackgroundPaths(bg);

	            this.appendVisual(bg);
	        }
	    }, {
	        key: 'pointsByCategoryIndex',
	        value: function pointsByCategoryIndex(categoryIndex) {
	            var charts = this.charts;
	            var result = [];

	            if (categoryIndex !== null) {
	                for (var i = 0; i < charts.length; i++) {
	                    var chart = charts[i];
	                    if (chart.pane.options.name === "_navigator") {
	                        continue;
	                    }

	                    var points = charts[i].categoryPoints[categoryIndex];
	                    if (points && points.length) {
	                        for (var j = 0; j < points.length; j++) {
	                            var point = points[j];
	                            if (point && (0, _defined2.default)(point.value) && point.value !== null) {
	                                result.push(point);
	                            }
	                        }
	                    }
	                }
	            }

	            return result;
	        }
	    }, {
	        key: 'pointsBySeriesIndex',
	        value: function pointsBySeriesIndex(seriesIndex) {
	            return this.filterPoints(function (point) {
	                return point.series.index === seriesIndex;
	            });
	        }
	    }, {
	        key: 'pointsBySeriesName',
	        value: function pointsBySeriesName(name) {
	            return this.filterPoints(function (point) {
	                return point.series.name === name;
	            });
	        }
	    }, {
	        key: 'filterPoints',
	        value: function filterPoints(callback) {
	            var charts = this.charts;
	            var result = [];

	            for (var i = 0; i < charts.length; i++) {
	                var chart = charts[i];
	                var points = chart.points;
	                for (var j = 0; j < points.length; j++) {
	                    var point = points[j];
	                    if (point && callback(point)) {
	                        result.push(point);
	                    }
	                }
	            }

	            return result;
	        }
	    }, {
	        key: 'findPoint',
	        value: function findPoint(callback) {
	            var charts = this.charts;

	            for (var i = 0; i < charts.length; i++) {
	                var chart = charts[i];
	                var points = chart.points;
	                for (var j = 0; j < points.length; j++) {
	                    var point = points[j];
	                    if (point && callback(point)) {
	                        return point;
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'paneByPoint',
	        value: function paneByPoint(point) {
	            var panes = this.panes;

	            for (var i = 0; i < panes.length; i++) {
	                var pane = panes[i];
	                if (pane.box.containsPoint(point)) {
	                    return pane;
	                }
	            }
	        }
	    }]);

	    return PlotAreaBase;
	}(_core.ChartElement);

	function axisGroupBox(axes) {
	    var length = axes.length;
	    var box = void 0;

	    if (length > 0) {
	        for (var i = 0; i < length; i++) {
	            var axisBox = axes[i].contentBox();

	            if (!box) {
	                box = axisBox.clone();
	            } else {
	                box.wrap(axisBox);
	            }
	        }
	    }

	    return box || new _core.Box();
	}

	function paneAnchor(axes, pane) {
	    for (var i = 0; i < axes.length; i++) {
	        var anchor = axes[i];
	        if (anchor && anchor.pane === pane) {
	            return anchor;
	        }
	    }
	}

	function isTransparent(color) {
	    return color === "" || color === null || color === "none" || color === "transparent" || !(0, _defined2.default)(color);
	}

	(0, _setDefaultOptions2.default)(PlotAreaBase.prototype, {
	    series: [],
	    plotArea: {
	        margin: {}
	    },
	    background: "",
	    border: {
	        color: _constants.BLACK,
	        width: 0
	    },
	    legend: {
	        inactiveItems: {
	            labels: {
	                color: "#919191"
	            },
	            markers: {
	                color: "#919191"
	            }
	        }
	    }
	});

	exports.default = PlotAreaBase;

/***/ },

/***/ 240:
/***/ function(module, exports) {

	module.exports = require("../crosshair/crosshair");

/***/ },

/***/ 241:
/***/ function(module, exports) {

	module.exports = require("../pane");

/***/ },

/***/ 242:
/***/ function(module, exports) {

	module.exports = require("../../common/is-string");

/***/ }

/******/ });