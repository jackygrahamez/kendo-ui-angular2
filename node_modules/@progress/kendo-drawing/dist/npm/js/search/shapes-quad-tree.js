module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(247);


/***/ },

/***/ 243:
/***/ function(module, exports) {

	module.exports = require("./quad-root");

/***/ },

/***/ 244:
/***/ function(module, exports) {

	module.exports = require("../geometry/rect");

/***/ },

/***/ 245:
/***/ function(module, exports) {

	module.exports = require("../common/append");

/***/ },

/***/ 247:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _quadRoot = __webpack_require__(243);

	var _quadRoot2 = _interopRequireDefault(_quadRoot);

	var _quadNode = __webpack_require__(248);

	var _quadNode2 = _interopRequireDefault(_quadNode);

	var _rect = __webpack_require__(244);

	var _rect2 = _interopRequireDefault(_rect);

	var _append = __webpack_require__(245);

	var _append2 = _interopRequireDefault(_append);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ROOT_SIZE = 3000;
	var LEVEL_STEP = 10000;
	var MAX_LEVEL = 75;

	var ShapesQuadTree = function () {
	    function ShapesQuadTree() {
	        _classCallCheck(this, ShapesQuadTree);

	        this.initRoots();
	    }

	    _createClass(ShapesQuadTree, [{
	        key: 'initRoots',
	        value: function initRoots() {
	            this.rootMap = {};
	            this.root = new _quadRoot2.default();
	            this.rootElements = [];
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            var rootElements = this.rootElements;
	            for (var idx = 0; idx < rootElements.length; idx++) {
	                this.remove(rootElements[idx]);
	            }
	            this.initRoots();
	        }
	    }, {
	        key: 'pointShape',
	        value: function pointShape(point) {
	            var sectorRoot = (this.rootMap[Math.floor(point.x / ROOT_SIZE)] || {})[Math.floor(point.y / ROOT_SIZE)];
	            var result = this.root.pointShapes(point);

	            if (sectorRoot) {
	                result = result.concat(sectorRoot.pointShapes(point));
	            }

	            this.assignZindex(result);

	            result.sort(zIndexComparer);
	            for (var idx = 0; idx < result.length; idx++) {
	                if (result[idx].containsPoint(point)) {
	                    return result[idx];
	                }
	            }
	        }
	    }, {
	        key: 'assignZindex',
	        value: function assignZindex(elements) {
	            for (var idx = 0; idx < elements.length; idx++) {
	                var element = elements[idx];
	                var zIndex = 0;
	                var levelWeight = Math.pow(LEVEL_STEP, MAX_LEVEL);
	                var parents = [];

	                while (element) {
	                    parents.push(element);
	                    element = element.parent;
	                }

	                while (parents.length) {
	                    element = parents.pop();
	                    zIndex += ((element.parent ? element.parent.children : this.rootElements).indexOf(element) + 1) * levelWeight;
	                    levelWeight /= LEVEL_STEP;
	                }

	                elements[idx]._zIndex = zIndex;
	            }
	        }
	    }, {
	        key: 'optionsChange',
	        value: function optionsChange(e) {
	            if (e.field === "transform" || e.field === "stroke.width") {
	                this.bboxChange(e.element);
	            }
	        }
	    }, {
	        key: 'geometryChange',
	        value: function geometryChange(e) {
	            this.bboxChange(e.element);
	        }
	    }, {
	        key: 'bboxChange',
	        value: function bboxChange(element) {
	            if (element.nodeType === "Group") {
	                for (var idx = 0; idx < element.children.length; idx++) {
	                    this.bboxChange(element.children[idx]);
	                }
	            } else {
	                if (element._quadNode) {
	                    element._quadNode.remove(element);
	                }
	                this._insertShape(element);
	            }
	        }
	    }, {
	        key: 'add',
	        value: function add(elements) {
	            var elementsArray = Array.isArray(elements) ? elements.slice(0) : [elements];

	            (0, _append2.default)(this.rootElements, elementsArray);
	            this._insert(elementsArray);
	        }
	    }, {
	        key: 'childrenChange',
	        value: function childrenChange(e) {
	            if (e.action === "remove") {
	                for (var idx = 0; idx < e.items.length; idx++) {
	                    this.remove(e.items[idx]);
	                }
	            } else {
	                this._insert(Array.prototype.slice.call(e.items, 0));
	            }
	        }
	    }, {
	        key: '_insert',
	        value: function _insert(elements) {
	            var element = void 0;

	            while (elements.length > 0) {
	                element = elements.pop();
	                element.addObserver(this);
	                if (element.nodeType === "Group") {
	                    (0, _append2.default)(elements, element.children);
	                } else {
	                    this._insertShape(element);
	                }
	            }
	        }
	    }, {
	        key: '_insertShape',
	        value: function _insertShape(shape) {
	            var bbox = shape.bbox();
	            if (bbox) {
	                var sectors = this.getSectors(bbox);
	                var x = sectors[0][0];
	                var y = sectors[1][0];

	                if (this.inRoot(sectors)) {
	                    this.root.insert(shape, bbox);
	                } else {
	                    var rootMap = this.rootMap;
	                    if (!rootMap[x]) {
	                        rootMap[x] = {};
	                    }

	                    if (!rootMap[x][y]) {
	                        rootMap[x][y] = new _quadNode2.default(new _rect2.default([x * ROOT_SIZE, y * ROOT_SIZE], [ROOT_SIZE, ROOT_SIZE]));
	                    }

	                    rootMap[x][y].insert(shape, bbox);
	                }
	            }
	        }
	    }, {
	        key: 'remove',
	        value: function remove(element) {
	            element.removeObserver(this);

	            if (element.nodeType === "Group") {
	                var children = element.children;
	                for (var idx = 0; idx < children.length; idx++) {
	                    this.remove(children[idx]);
	                }
	            } else if (element._quadNode) {
	                element._quadNode.remove(element);
	                delete element._quadNode;
	            }
	        }
	    }, {
	        key: 'inRoot',
	        value: function inRoot(sectors) {
	            return sectors[0].length > 1 || sectors[1].length > 1;
	        }
	    }, {
	        key: 'getSectors',
	        value: function getSectors(rect) {
	            var bottomRight = rect.bottomRight();
	            var bottomX = Math.floor(bottomRight.x / ROOT_SIZE);
	            var bottomY = Math.floor(bottomRight.y / ROOT_SIZE);
	            var sectors = [[], []];
	            for (var x = Math.floor(rect.origin.x / ROOT_SIZE); x <= bottomX; x++) {
	                sectors[0].push(x);
	            }
	            for (var y = Math.floor(rect.origin.y / ROOT_SIZE); y <= bottomY; y++) {
	                sectors[1].push(y);
	            }
	            return sectors;
	        }
	    }]);

	    return ShapesQuadTree;
	}();

	function zIndexComparer(x1, x2) {
	    if (x1._zIndex < x2._zIndex) {
	        return 1;
	    }
	    if (x1._zIndex > x2._zIndex) {
	        return -1;
	    }

	    return 0;
	}

	exports.default = ShapesQuadTree;

/***/ },

/***/ 248:
/***/ function(module, exports) {

	module.exports = require("./quad-node");

/***/ }

/******/ });