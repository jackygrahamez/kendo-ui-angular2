import 'core-js/es6';
import { $ } from 'e2e-utils';

import Chart from '../../src/chart/chart';
import { deepExtend, FontLoader } from '../../src/common';

import { ok, equal, stubMethod } from '../../test/test-helpers';
import { triggerEvent, createChart, destroyChart }  from '../test-helpers';

(function() {
    let chart;
    const defaultOptions = { series: [{}] };
    function setupChart(options) {
        chart = createChart(options);
    }

    // ------------------------------------------------------------
    describe('refresh / redraw', () => {
        
        afterEach(() => {
            destroyChart(chart);
        });

        it("refresh applies axis defaults", () => {
            setupChart(defaultOptions);
            $.extend(chart.options, {
                axisDefaults: {
                    flag: true
                }
            });

            chart.refresh();

            ok(chart.options.categoryAxis.flag === true);
        });

        it("redraw applies axis defaults", () => {
            setupChart(defaultOptions);
            $.extend(chart.options, {
                axisDefaults: {
                    flag: true
                }
            });

            chart.redraw();

            ok(chart.options.categoryAxis.flag === true);
        });

        it("redraw only redraws specified pane", 1, () => {
            setupChart({
                panes: [{ name: "top" }, { name: "bottom" }]
            });

            const plotArea = chart._model._plotArea;
            plotArea.redraw = function(pane) {
                ok(pane === plotArea.panes[1]);
            };

            chart.redraw("bottom");
        });

        it("redraw redraws default pane if invalid name is specified", 1, () => {
            setupChart({
                panes: [{ name: "top" }, { name: "bottom" }]
            });

            const plotArea = chart._model._plotArea;
            plotArea.redraw = function(pane) {
                ok(pane === plotArea.panes[0]);
            };

            chart.redraw("middle");
        });

        it("removes category axis aliases after init", 1, () => {
            setupChart({
                panes: [{ name: "top" }, { name: "bottom" }],
                categoryAxes: [{}]
            });

            ok(!chart.options.categoryAxes);
        });

        it("redraw keeps categories when using categoryAxes alias", () => {
            setupChart({
                series: [{
                    type: "column",
                    data: [{
                        type: "alpha",
                        value: 100
                    }],
                    categoryField: "type"
                }],
                panes: [{
                    name: "top"
                }],
                categoryAxes: [{
                    pane: "top"
                }]
            });

            chart.redraw("top");
            equal(chart._model._plotArea.categoryAxis.options.categories[0], "alpha");
        });

        it("removes value axis alias after init", 1, () => {
            setupChart({
                series: [{
                    type: "column",
                    data: [1000]
                }],
                panes: [{
                    name: "top"
                }],
                valueAxes: [{
                    field: "type",
                    pane: "top"
                }]
            });

            ok(!chart.options.valueAxes);
        });

        it("refresh applies series defaults", () => {
            setupChart(defaultOptions);
            $.extend(chart.options, {
                seriesDefaults: {
                    labels: { visible: true }
                }
            });

            chart.refresh();

            equal(chart.options.series[0].labels.visible, true);
        });

        it("redraw applies series defaults", () => {
            setupChart(defaultOptions);
            $.extend(chart.options, {
                seriesDefaults: {
                    labels: { visible: true }
                }
            });

            chart.redraw();

            equal(chart.options.series[0].labels.visible, true);
        });

        it("redraw replaces SVG element", () => {
            setupChart(defaultOptions);
            $(chart.element).find("svg").data("dirty", true);
            chart.redraw();

            ok(!$(chart.element).data("dirty") > 0);
        });

        it("redraw sets series defaults", () => {
            setupChart({
                series: [{
                    type: "column",
                    data: [1000],
                    color: function() { return "blue"; }
                }],
                seriesColors: ["red"]
            });

            chart.redraw();
            equal(chart.options.series[0]._defaults.color, "red");
        });

        it("refresh applies changes to data-bound series", () => {
            setupChart({
                series: [{ field: "value", data: [{ value: 1 }] }]
            });

            chart.options.series[0].flag = true;
            chart.refresh();

            ok(chart.options.series[0].flag);
        });

        it("refresh applies color to new series", () => {
            setupChart({
                seriesColors: ["red", "blue"],
                series: [{}]
            });

            chart.options.series.push({});
            chart.refresh();

            equal(chart.options.series[1].color, "blue");
        });

        it("refresh cleans up generated cateories", () => {
            setupChart({
                dataSource: [{ value: 1 }],
                series: [{ field: "value" }],
                categoryAxis: { categories: [] }
            });

            chart.options.series = [];
            chart.refresh();

            equal(chart.options.categoryAxis.categories.length, 0);
        });

        it("redraw clears cached size", () => {
            setupChart(defaultOptions);
            $(chart.element).css("width", 1000);
            chart.resize();

            $(chart.element).css("width", 0);
            chart.redraw();

            $(chart.element).css("width", 1000);
            chart.resize();

            equal(chart._model.options.width, 1000);
        });

        it("redraw creates a new overlay with the view and viewElement", () => {
            setupChart(defaultOptions);
            const highlight = chart._highlight;
            ok(highlight.view === chart._view);
            ok(highlight.viewElement === chart._viewElement);
        });

        it("redraw unsets active point", () => {
            setupChart(defaultOptions);
            chart._unsetActivePoint = function() { ok(true); };
            chart.redraw();
        });

        it("redraw resizes surface", () => {
            setupChart();

            chart.surface.resize = function() {
                ok(true);
            };
            chart.redraw();
        });
    });

    // ------------------------------------------------------------
    describe('chartArea size', () => {
        afterEach(() => {
            destroyChart(chart);
        });


        it("applies width in pixels", () => {
            setupChart({
                chartArea: { width: 1000 }
            });
            equal($(chart.element).width(), 1000);
        });

        it("applies height in pixels", () => {
            setupChart({
                chartArea: { height: 500 }
            });
            equal($(chart.element).height(), 500);
        });

        it("applies width in units", () => {
            setupChart({
                chartArea: { width: "1000px" }
            });
            equal($(chart.element).width(), 1000);
        });

        it("applies height", () => {
            setupChart({
                chartArea: { height: "500px" }
            });
            equal($(chart.element).height(), 500);
        });

        it("applies size to surface", () => {
            setupChart({
                chartArea: {
                    height: 300,
                    width: 300
                }
            });

            const size = chart.surface._size;
            equal(size.width, 300);
            equal(size.height, 300);
        });
    });

    // ------------------------------------------------------------
    describe('destroy', () => {
        beforeEach(() => {
            setupChart({
                series: [{}],
                pannable: true,
                zoomable: true
            });
        });

        it("destroys tooltip", () => {
            chart._tooltip.destroy();
            chart._tooltip = { destroy: function() { ok(true); }, hide: $.noop };
            destroyChart(chart);
        });

        it("destroys pannable", () => {
            chart._pannable.destroy();
            chart._pannable = { destroy: function() { ok(true); } };
            destroyChart(chart);
        });

        it("destroys zoomSelection", () => {
            chart._zoomSelection.destroy();
            chart._zoomSelection = { destroy: function() { ok(true); } };
            destroyChart(chart);
        });

        it("destroys MousewheelZoom", () => {
            chart._mousewheelZoom.destroy();
            chart._mousewheelZoom = { destroy: function() { ok(true); } };
            destroyChart(chart);
        });
    });

    // ------------------------------------------------------------
    let panePoint;
    let origEvent;

    function triggerMousewheel(delta) {
        chart._mousewheel({
            detail: delta * 3,
            pageX: panePoint.x,
            pageY: panePoint.y,
            preventDefault: function() {},
            stopPropagation: function() {}
        });
    }

    function createEventArg(options) {
        return deepExtend({
            originalEvent: { },
            pageX: panePoint.x,
            pageY: panePoint.y,
            x: {
                startLocation: 0
            },
            y: {
                startLocation: 0
            }
        }, options);
    }

    describe('Events', () => {
        beforeEach(() => {
            setupChart({
                series: [{}],
                valueAxis: { name: "value" },
                chartArea: { width: 600, height: 400 }
            });
            panePoint = chart._plotArea.panes[0].chartsBox().center();
            origEvent = { pageX: panePoint.x, pageY: panePoint.y };
        });
        
        afterEach(() => {
            destroyChart(chart);
        });

        it("navigation does not start if no handlers are attached", 0, () => {
            stubMethod(Chart.prototype, "_startNavigation", () => {
                ok(false);
            }, () => {
                chart._start(origEvent);
            });
        });

        it("navigation starts if dragStart handler is attached", 1, () => {
            chart.bind("dragStart", () => {});

            stubMethod(Chart.prototype, "_startNavigation", () => {
                ok(true);
            }, () => {
                chart._start(origEvent);
            });
        });

        it("navigation starts if drag handler is attached", 1, () => {
            chart.bind("drag", () => {});

            stubMethod(Chart.prototype, "_startNavigation", () => {
                ok(true);
            }, () => {
                chart._start(origEvent);
            });
        });

        it("navigation starts if dragEnd handler is attached", 1, () => {
            chart.bind("dragEnd", () => {});

            stubMethod(Chart.prototype, "_startNavigation", () => {
                ok(true);
            }, () => {
                chart._start(origEvent);
            });
        });

        it("mousewheel down triggers zoom event (zoom out)", () => {
            chart.bind("zoom", function(e) {
                equal(e.axisRanges.value.max, 3.2);
            });
            triggerMousewheel(10);
        });

        it("mousewheel up triggers zoom event (zoom in)", () => {
            chart.bind("zoom", function(e) {
                equal(e.axisRanges.value.max, -0.8);
            });
            triggerMousewheel(-10);
        });

        it("mousewheel triggers zoomEnd with axisRanges", (done) => {
            chart.bind("zoomEnd", function(e) {
                ok(e.axisRanges.value);
                done();
            });
            triggerMousewheel(10);
        });
    });

    // ------------------------------------------------------------
    describe('Events / zoom selection', () => {
        beforeEach(() => {
            setupChart({
                series: [{}],
                valueAxis: { name: "value" },
                chartArea: { width: 600, height: 400 },
                zoomable: true
            });

            chart._plotArea.paneByPoint = function() {
                return chart._plotArea.panes[0];
            };
        });
        
        afterEach(() => {
            destroyChart(chart);
        });

        it("zoom selection start triggers zoomStart event", () => {
            chart.bind("zoomStart", function(e) {
                ok(true)
            });

            chart._start(createEventArg({
                originalEvent: {
                    shiftKey:  true
                }
            }));
        });

        it("zoom selection end triggers zoom event", () => {
            chart.bind("zoom", function(e) {
                ok(true)
            });

            chart._start(createEventArg({
                originalEvent: {
                    shiftKey:  true
                }
            }));

            chart._end(createEventArg({
                originalEvent: {
                    shiftKey:  true
                }
            }));
        });

        it("zoom event is preventable", 0, () => {
            chart.bind("zoom", function(e) {
                e.preventDefault();
            });

            chart._start(createEventArg({
                originalEvent: {
                    shiftKey:  true
                }
            }));

            chart._plotArea.redraw = function() {
                ok(false);
            };

            chart._end(createEventArg({
                originalEvent: {
                    shiftKey:  true
                }
            }));
        });

        it("zoom selection end triggers zoomEnd event", () => {
            let redrawnPlotarea = false;
            chart.bind("zoomEnd", function(e) {
                ok(redrawnPlotarea);
            });

            chart._start(createEventArg({
                originalEvent: {
                    shiftKey:  true
                }
            }));

            chart._plotArea.redraw = function() {
                redrawnPlotarea = true;
            };

            chart._end(createEventArg({
                originalEvent: {
                    shiftKey:  true
                }
            }));
        });
    });

    // ------------------------------------------------------------
    describe('Events / mousewheel zoom', () => {
        beforeEach(() => {
            setupChart({
                series: [{}],
                categoryAxis: {
                    categories: ["A", "B", "C", "D"],
                    name: "foo",
                    min: 1,
                    max: 2
                },
                chartArea: { width: 600, height: 400 },
                zoomable: true
            });
        });
        
        afterEach(() => {
            destroyChart(chart);
        });

        it("mousewheel triggers zoomStart", () => {
            chart.bind("zoomStart", function(e) {
                ok(true);
            });
            triggerMousewheel(10);
        });

        it("zoomStart is preventable", 0, () => {
            chart.bind("zoomStart", function(e) {
                e.preventDefault();
            });
            chart._plotArea.redraw = function() {
                ok(false);
            };
            triggerMousewheel(10);
        });

        it("mousewheel triggers zoom with updated ranges", () => {
            chart.bind("zoom", function(e) {
                equal(e.axisRanges.foo.min, 0);
                equal(e.axisRanges.foo.max, 4);
            });
            triggerMousewheel(10);
        });

        it("zoom event is preventable", 0, () => {
            chart.bind("zoom", function(e) {
                e.preventDefault();
            });
            chart._plotArea.redraw = function() {
                ok(false);
            };
            triggerMousewheel(10);
        });

        it("mousewheel triggers zoomEnd event", (done) => {
            chart.bind("zoomEnd", function(e) {
                ok(true);
                done();
            });
            triggerMousewheel(10);
        });

        it("zoomEnd sends axisRanges", (done) => {
            chart.bind("zoomEnd", function(e) {
                ok(e.axisRanges.foo);
                done();
            });
            triggerMousewheel(10);
        });
    });


    // ------------------------------------------------------------

    function triggerPinchZoom(distance) {
        chart._gesturestart({
            distance: 10
        });

        chart._gesturechange({
            distance: distance,
            preventDefault: $.noop
        });

        chart._gestureend({
            distance: distance
        });
    }

    describe('Events / pinch zoom', () => {
        beforeEach(() => {
            setupChart({
                series: [{}],
                categoryAxis: {
                    categories: ["A", "B", "C", "D"],
                    name: "foo",
                    min: 1,
                    max: 2
                },
                chartArea: { width: 600, height: 400 },
                zoomable: true
            });
        });
        
        afterEach(() => {
            destroyChart(chart);
        });

        it("triggers zoomStart", () => {
            chart.bind("zoomStart", function(e) {
                ok(true);
            });
            triggerPinchZoom(1);
        });

        it("zoomStart is preventable", 0, () => {
            chart.bind("zoomStart", function(e) {
                e.preventDefault();
            });
            chart._plotArea.redraw = function() {
                ok(false);
            };
            triggerPinchZoom(1);
        });

        it("triggers zoom with updated ranges", () => {
            chart.bind("zoom", function(e) {
                equal(e.axisRanges.foo.min, 0);
                equal(e.axisRanges.foo.max, 4);
            });
            triggerPinchZoom(1);
        });

        it("zoom event is preventable", 0, () => {
            chart.bind("zoom", function(e) {
                e.preventDefault();
            });
            chart._plotArea.redraw = function() {
                ok(false);
            };
            triggerPinchZoom(1);
        });

        it("triggers zoomEnd event", () => {
            chart.bind("zoomEnd", function(e) {
                ok(true);
            });
            triggerPinchZoom(1);
        });
    });

})();

(function() {
    let chart;

    function setupChart(options) {
        chart = createChart(deepExtend({
            series: [{
                type: "bar",
                data: [1, 2]
            }]
        }, options));
    }

    // ------------------------------------------------------------
    describe('Export', () => {
        beforeEach(() => {
            setupChart();
        });
        
        afterEach(() => {
            destroyChart(chart);
        });

        // it("svg() does not replace model", () => {
            // const oldModel = chart._model;
            // chart.svg();
            // ok(oldModel === chart._model);
        // });

        // it("svg() does not replace surface", () => {
            // const oldSurface = chart.surface;
            // chart.svg();
            // ok(oldSurface === chart.surface);
        // });

        // it("svg() encodes entities", () => {
            // setupChart({ categoryAxis: { categories: ["Foo & Bar"] } });
            // ok(chart.svg().indexOf("Foo &amp; Bar") > -1);
        // });

        // it("svg() preserves encoded entities", () => {
            // setupChart({ categoryAxis: { categories: ["Foo &amp; Bar"] } });
            // ok(chart.svg().indexOf("Foo &amp; Bar") > -1);
        // });

        it("imageDataURL() does not replace model", () => {
            const oldModel = chart._model;
            chart.imageDataURL();
            ok(oldModel === chart._model);
        });

        it("imageDataURL() does not replace surface", () => {
            const oldSurface = chart.surface;
            chart.imageDataURL();
            ok(oldSurface === chart.surface);
        });

        it("exportVisual creates visual with the specified width and height", () => {
            const visual = chart.exportVisual({
                width: 300,
                height: 300
            });
            const bbox = visual.bbox();
            equal(bbox.size.width, 300);
            equal(bbox.size.height, 300);
        });

        it("exportVisual return surface export visual if width and height are not specified", () => {
            const visual = chart.exportVisual({
                foo: "bar"
            });
            ok(visual === chart.surface.exportVisual());
        });

        it("exportVisual does not replace surface", () => {
            const oldSurface = chart.surface;
            chart.exportVisual({
                width: 300,
                height: 300
            });
            ok(oldSurface === chart.surface);
        });

        it("exportVisual does not replace model", () => {
            const oldModel = chart._model;
            chart.exportVisual({
                width: 300,
                height: 300
            });
            ok(oldModel === chart._model);
        });

        it("exportVisual does not change chartArea size", () => {
            const chartArea = chart.options.chartArea;
            const width = chartArea.width;
            const height = chartArea.height;
            chart.exportVisual({
                width: 300,
                height: 300
            });
            equal(chart.options.chartArea.width, width);
            equal(chart.options.chartArea.height, height);
        });
    });
})();

// ------------------------------------------------------------
describe('setOptions', () => {    
    
    const themeOptions = {
        foo: true,
        seriesDefaults: {
            foo: true
        },
        seriesColors: ["#f00"]
    };
    let chart;

    function setupChart(options, theme) {
        chart = createChart(options, theme);
    }
    
    afterEach(() => {
        destroyChart(chart);
    });

    it("extends original options", () => {
        setupChart();

        chart.setOptions({
            foo: true
        });

        ok(chart._originalOptions.foo);
    });

    it("applies theme options", () => {
        setupChart();
        chart.setOptions({}, themeOptions);

        ok(chart.options.foo);
    });

    it("does not taint original options with theme", () => {
        setupChart({}, themeOptions);

        chart.setOptions({}, {});

        ok(!chart.options.foo);
    });

    it("does not taint series options with theme", () => {
        setupChart({            
            series: [{ }]
        }, themeOptions);

        chart.setOptions({}, {});

        ok(!chart.options.series[0].foo);
    });

    it("does not taint series colors with theme", () => {
        setupChart({
            series: [{}]
        });

        chart.setOptions({}, themeOptions);
        chart.setOptions({}, {});

        ok(!chart.options.series[0].color);
    });

    it("extends axis options", () => {
        setupChart({
            valueAxis: { name: "foo" }
        });

        chart.setOptions({ valueAxis: { max: 1 } });
        equal(chart.options.valueAxis.name, "foo");
    });

    it("calls redraw implicitly", () => {
        setupChart();

        stubMethod(Chart.prototype, "redraw", () => {
            ok(true);
        }, () => {
            chart.setOptions({
                foo: true
            });
        });
    });

    it("binds mousemove handler if crosshairs are enabled with the new options", (done) => {
        setupChart();
        chart._mousemove = function() {
            ok(true);
            done();
        };

        chart.setOptions({
            categoryAxis: {
                crosshair:{
                    visible: true
                }
            }
        });

        triggerEvent("mousemove", chart.element);
    });

    it("binds categories from series data", () => {
        setupChart({});
        chart.setOptions({
            series: [{
                data: [{
                    value: 1,
                    foo: "A"
                }],
                categoryField: "foo"
            }]
        });
        equal(chart._plotArea.categoryAxis.options.categories[0], "A");
    });

    it("clears original option if null is passed", () => {
        setupChart({
            valueAxis: {
                min: 1
            }
        });

        chart.setOptions({
            valueAxis: {
                min: null
            }
        });
        ok(chart.options.valueAxis.min === undefined);
    });

    it("clears original option if undefined is passed", () => {
        setupChart({
            valueAxis: {
                majorUnit: 1
            }
        });
        chart.setOptions({
            valueAxis: {
                majorUnit: undefined
            }
        });
        ok(chart.options.valueAxis.majorUnit === undefined);
    });

    it("disables panning and zooming", () => {
        setupChart({
            pannable: true,
            zoomable: true
        });
        chart.setOptions({
            pannable: false,
            zoomable: false
        });

        ok(!chart._pannable);
        ok(!chart._zoomSelection);
        ok(!chart._mousewheelZoom);
    });
});

// ------------------------------------------------------------
describe('Events / render', () => {
    let chart;
    afterEach(() => {
        destroyChart(chart);
    });

    it("triggers render after chart is rendered", 1, () => {
        chart = createChart({
            series: [{
                data: [1, 2, 3]
            }],
            render: function(e) {
                ok(e.sender.surface._root.childNodes);
            }
        });
    });
});


// ------------------------------------------------------------
describe('toggleHighlight', () => {
    let chart;
    function setupChart(options) {
        chart = createChart(options);
    }
    
    afterEach(() => {
        destroyChart(chart);
    });

    it("toggles donut chart point highlight by series and category", 6, () => {
        setupChart({
            series: [{
                type: "donut",
                name: "foo",
                data: [{
                    value: 1,
                    category: "bar"
                }]
            }, {
                type: "donut",
                name: "baz",
                data: [{
                    value: 1,
                    category: "qux"
                }],
                value: 1
            }]
        });

        let showHighlight = true;
        chart._highlight.togglePointHighlight = function(point, show) {
            equal(point.series.name, "baz");
            equal(point.category, "qux");
            equal(show, showHighlight);
        };
        chart.toggleHighlight(showHighlight, {
            series: "baz",
            category: "qux"
        });
        showHighlight = false;
        chart.toggleHighlight(showHighlight, {
            series: "baz",
            category: "qux"
        });
    });

    it("does not toggle donut chart point highlight if there isn't point with matching series and category", 0, () => {
        setupChart({
            series: [{
                type: "donut",
                name: "foo",
                data: [{
                    value: 1,
                    category: "bar"
                }]
            }, {
                type: "donut",
                name: "baz",
                data: [{
                    value: 1,
                    category: "qux"
                }],
                value: 1
            }]
        });

        let showHighlight = true;
        chart._highlight.togglePointHighlight = function(point, show) {
            ok(false);
        };
        chart.toggleHighlight(showHighlight, {
            series: "foo",
            category: "qux"
        });
        showHighlight = false;
        chart.toggleHighlight(showHighlight, {
            series: "baz",
            category: "bar"
        });
    });

    it("toggles pie chart point highlight by category", 4, () => {
        setupChart({
            series: [{
                type: "pie",
                data: [{
                    value: 1,
                    category: "foo"
                }, {
                    value: 1,
                    category: "bar"
                }]
            }]
        });

        let showHighlight = true;
        chart._highlight.togglePointHighlight = function(point, show) {
            equal(point.category, "bar");
            equal(show, showHighlight);
        };
        chart.toggleHighlight(showHighlight, {
            category: "bar"
        });
        showHighlight = false;
        chart.toggleHighlight(showHighlight, "bar");
    });

    it("does not toggle pie chart point highlight if there isn't category with matching name", 0, () => {
        setupChart({
            series: [{
                type: "pie",
                data: [{
                    value: 1,
                    category: "foo"
                }, {
                    value: 1,
                    category: "bar"
                }]
            }]
        });

        let showHighlight = true;
        chart._highlight.togglePointHighlight = function(point, show) {
            ok(false);
        };
        chart.toggleHighlight(showHighlight, {
            category: "baz"
        });
        showHighlight = false;
        chart.toggleHighlight(showHighlight, "baz");
    });

    it("toggles categorical chart series points highlight by series name", 8, () => {
        setupChart({
            series: [{
                type: "column",
                name: "column",
                data: [1, 2]
            }, {
                type: "line",
                name: "line",
                data: [3, 4]
            }]
        });

        let showHighlight = true;
        chart._highlight.togglePointHighlight = function(point, show) {
            equal(point.series.name, "line");
            equal(show, showHighlight);
        };
        chart.toggleHighlight(showHighlight, {
            series: "line"
        });
        showHighlight = false;
        chart.toggleHighlight(showHighlight, "line");
    });

    it("does not toggle categorical chart points highlight if there isn't series with matching name", 0, () => {
        setupChart({
            series: [{
                type: "column",
                name: "column",
                data: [1, 2]
            }, {
                type: "line",
                name: "line",
                data: [3, 4]
            }]
        });

        let showHighlight = true;
        chart._highlight.togglePointHighlight = function(point, show) {
            ok(false);
        };
        chart.toggleHighlight(showHighlight, {
            series: "foo"
        });
        showHighlight = false;
        chart.toggleHighlight(showHighlight, "foo");
    });

    it("toggles scatter chart series points highlight by series name", 8, () => {
        setupChart({
            series: [{
                type: "scatter",
                name: "A",
                data: [[1, 2], [3, 4]]
            }, {
                type: "scatter",
                name: "B",
                data: [[5, 6], [7, 8]]
            }]
        });

        let showHighlight = true;
        chart._highlight.togglePointHighlight = function(point, show) {
            equal(point.series.name, "A");
            equal(show, showHighlight);
        };
        chart.toggleHighlight(showHighlight, {
            series: "A"
        });
        showHighlight = false;
        chart.toggleHighlight(showHighlight, "A");
    });

    it("does no toggle scatter chart points highlight if there isn't series with matching name", 0, () => {
        setupChart({
            series: [{
                type: "scatter",
                name: "A",
                data: [[1, 2], [3, 4]]
            }, {
                type: "scatter",
                name: "B",
                data: [[5, 6], [7, 8]]
            }]
        });

        let showHighlight = true;
        chart._highlight.togglePointHighlight = function(point, show) {
            ok(false);
        };
        chart.toggleHighlight(showHighlight, {
            series: "foo"
        });
        showHighlight = false;
        chart.toggleHighlight(showHighlight, "foo");
    });

    it("toggles chart points highlight using function", 4, () => {
        setupChart({
            series: [{
                type: "column",
                name: "column",
                data: [1, 2]
            }, {
                type: "line",
                name: "line",
                data: [3, 4]
            }]
        });

        let showHighlight = true;
        chart._highlight.togglePointHighlight = function(point, show) {
            equal(point.value, 1);
            equal(show, showHighlight);
        };

        chart.toggleHighlight(showHighlight, function(point) {
            return point.value === 1;
        });
        showHighlight = false;
        chart.toggleHighlight(showHighlight, function(point) {
            return point.value === 1;
        });
    });
});

// ------------------------------------------------------------
(function() {
    let chart;

    describe('show/hide Tooltip', () => {
        beforeEach(() => {
            chart = createChart({
                series: [{
                    data: [1, 2, 2]
                }]
            });
        });
        
        afterEach(() => {
            destroyChart(chart);
        });
        
        it("shows tooltip for filtered point", () => {
           chart._tooltip.show = function(point) {
               equal(point.value, 1);
           };
           chart.showTooltip(function(point) {
               return point.value === 1;
           });
        });

        it("shows tooltip for the first point if the filter matches multiple points", () => {
           chart._tooltip.show = function(point) {
               equal(point.value, 2);
               equal(point.categoryIx, 1);
           };
           chart.showTooltip(function(point) {
               return point.value === 2;
           });
        });

        it("does nothing if no filter is passed", 0, () => {
            chart._tooltip.show = function(point) {
               ok(false);
            };
            chart.showTooltip();
        });

        it("does nothing if the filter returns no points", 0, () => {
            chart._tooltip.show = function(point) {
               ok(false);
            };

            chart.showTooltip(function() {
                return false;
            });
        });

        it("hide hides tooltip", () => {
            chart._tooltip.hide = function(point) {
               ok(true);
            };
            chart.hideTooltip();
        });
    });
    
    // ------------------------------------------------------------
    describe('show/hide Tooltip / shared', () => {
        beforeEach(() => {
            chart = createChart({
                series: [{
                    data: [1, 2, 2]
                }, {
                    data: [3, 4, 5]
                }],
                tooltip: {
                    shared: true
                }
            });
        });
        
        afterEach(() => {
            destroyChart(chart);
        });

        it("shows tooltip for filtered point", () => {
           chart._tooltip.showAt = function(points) {
               equal(points[0].value, 1);
               equal(points[1].value, 3);
           };
           chart.showTooltip(function(point) {
               return point.value === 1;
           });
        });

        it("shows tooltip for the first point if the filter matches multiple points", () => {
           chart._tooltip.showAt = function(points) {
               equal(points[0].value, 2);
               equal(points[1].value, 4);
               equal(points[0].categoryIx, 1);
           };
           chart.showTooltip(function(point) {
               return point.value === 2;
           });
        });

        it("does nothing if no filter is passed", 0, () => {
            chart._tooltip.showAt = function(point) {
               ok(false);
            };
            chart.showTooltip();
        });

        it("does nothing if the filter returns no points", 0, () => {
            chart._tooltip.showAt = function(point) {
               ok(false);
            };

            chart.showTooltip(function() {
                return false;
            });
        });

        it("hide hides tooltip", () => {
            chart._tooltip.hide = function(point) {
               ok(true);
            };
            chart.hideTooltip();
        });
    });

})();

// ------------------------------------------------------------
describe('Custom fonts', () => {
    let chart;
    afterEach(() => {
        destroyChart(chart);
    });

    it("loads custom fonts", () => {
        const font = "16px Deja Mu";

        stubMethod(FontLoader, "loadFonts", function(fonts) {
            equal(fonts, [font]);
        }, () => {
            chart = createChart({
                categoryAxis: {
                    labels: {
                        font: font
                    }
                }
            });
        });
    });

    it("does not crash with complex options", () => {
        stubMethod(FontLoader, "loadFonts", () => {
            ok(true)
        }, () => {
            chart = createChart({
                foo: null,
                series: [{
                    visual: function(e) {
                        return e.createVisual();
                    }
                }]
            });
        });
    });
});
