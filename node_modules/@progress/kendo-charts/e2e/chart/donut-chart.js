import 'core-js/es6';

import { drawing as draw } from '@progress/kendo-drawing';

import DonutChart from '../../src/chart/donut-chart/donut-chart';
import DonutSegment from '../../src/chart/donut-chart/donut-segment';
import categoriesCount from '../../src/chart/utils/categories-count';

import { RootElement, Ring, Box, Point } from '../../src/core';
import { deepExtend } from '../../src/common';

import { ok, equal, close, arrayClose, closePaths, sameBox, each } from '../../test/test-helpers';
import { clickChart, triggerEvent, createChart, destroyChart, getChartDomElement }  from '../test-helpers';

const chartBox = new Box(0, 0, 800, 600);
const TOLERANCE = 0.1;
let plotArea, donutChart, firstSegment, root;

function setupDonutChart(plotArea, options) {

    donutChart = new DonutChart(plotArea, deepExtend({}, { padding: 60 }, options));

    root = new RootElement();
    root.append(donutChart);

    root.box = chartBox;
    donutChart.reflow(chartBox);

    root.renderVisual();

    firstSegment = donutChart.points[0];
}

(function() {
    const values = { type: "donut", data: [1, 2] };
    const dataValues = {
       type: "donut",
       data: [{
           value: 1,
           category: "A",
           explode: true
       }, {
           value: 2,
           category: "B"
       }]
    };

    function PlotAreaStub() { }

    deepExtend(PlotAreaStub.prototype, {
        options: { }
    });

    // ------------------------------------------------------------
    describe('Donut Chart / Array with values', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupDonutChart(plotArea, { series: [ values ] });
        });

        it("creates points for donut chart data points", () => {
            equal(donutChart.points.length, values.data.length);
        });

        it("points have set angle", () => {
            each(donutChart.points, function() {
                ok(this.sector.angle);
            });
        });

        it("points have set startAngle", () => {
            each(donutChart.points, function() {
                ok(this.sector.angle);
            });
        });

        it("points have set extremely small angle", () => {
            setupDonutChart(plotArea, {
                series: [{
                    type: "donut",
                    data: [10000000000, 1]
                }]
            });

            each(donutChart.points, function() {
                ok(this.sector.angle > 0);
            });
        });

        it("points have set owner", () => {
            ok(firstSegment.owner === donutChart);
        });

        it("sets segment category", () => {
            equal(firstSegment.category, "");
        });

        it("sets segment series", () => {
            ok(firstSegment.series === values);
        });

        it("sets segment series index", () => {
            ok(firstSegment.seriesIx === 0);
        });

        it("sets segment series index to options", () => {
            ok(donutChart.points[0].options.index === 0);
            ok(donutChart.points[1].options.index === 1);
        });

        it("sets segment dataItem", () => {
            equal(typeof firstSegment.dataItem, "number");
        });
    });

    // ------------------------------------------------------------
    describe('Donut Chart / Array with items', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupDonutChart(plotArea, { series: [ dataValues ] });
        });

        it("sets segment category", () => {
            equal(firstSegment.category, "A");
        });

        it("points have set owner", () => {
            ok(firstSegment.owner === donutChart);
        });

        it("sets segment series", () => {
            ok(firstSegment.series === dataValues);
        });

        it("sets segment series index", () => {
            ok(firstSegment.seriesIx === 0);
        });

        it("sets segment dataItem", () => {
            equal(typeof firstSegment.dataItem, "object");
        });

        it("sets segment dataItem", () => {
            close(firstSegment.percentage, 0.333, TOLERANCE);
        });

        it("sets segment explode", () => {
            ok(firstSegment.explode == true);
        });

        it("sets segment different center if segment have explode sets to true", () => {
            ok(firstSegment.sector.center != donutChart.points[1].sector.center);
        });
    });
})();


(function() {
    const data = [{
        value: 10,
        explode: true,
        color: "red",
        category: "A"
    }, {
        value: 50,
        explode: false,
        color: "red",
        category: "B"
    }];

    let chart, donutChart, firstSegment;

    // ------------------------------------------------------------
    describe('Donut Chart / Data', () => {
        beforeEach(() => {
            chart = createChart({
                series: [{
                    data: data,
                    type: "donut",
                    field: "value",
                    categoryField: "category",
                    colorField: "color",
                    explodeField: "explode"
                }]
            });

            donutChart = chart._plotArea.charts[0];
            firstSegment = donutChart.points[0];
        });
        
        afterEach(() => {
            destroyChart(chart);
        });

        it("sets segment angle based on value", () => {
            equal(firstSegment.sector.angle, 60);
        });

        it("sets segment category from dataItem", () => {
            equal(firstSegment.category, "A");
        });

        it("sets segment color from dataItem", () => {
            equal(firstSegment.options.color, "red");
        });

        it("sets segment explode from dataItem", () => {
            ok(firstSegment.explode == true);
        });
    });

})();


(function() {
    const VALUE = 1;
    const CATEGORY = "A";
    const PERCENTAGE = 0.5;   
    const SERIES_NAME = "series";
    let point, box, label, root, ring, segment;

    function createSegment(options) {
        segment = new DonutSegment(
            VALUE,
            new Ring(new Point(0,0), 20, 100, 90, 100),
            options
        );

        segment.percentage = PERCENTAGE;
        segment.category = CATEGORY;
        segment.series = { name: SERIES_NAME };
        segment.dataItem = { value: VALUE };

        box = new Box(0, 0, 100, 100);
        segment.reflow(box);

        root = new RootElement();
        root.box = box;
        root.append(segment);
        root.renderVisual();

        ring = segment.visual.children[0];
    }

    // ------------------------------------------------------------
    describe('Donut Segment', () => {
        beforeEach(() => {
            createSegment();
        });

        it("fills target box", () => {
            sameBox(segment.box, box);
        });

        it("sets segment border color", () => {
            createSegment({ border: { color: "red" } });
            equal(segment.options.border.color, "red");
        });

        it("sets donut border width", () => {
            createSegment({ border: { width: 4 } });
            equal(segment.options.border.width, 4);
        });

        it("tooltipAnchor is set distance from segment", () => {
            const { point, align } = segment.tooltipAnchor();
            arrayClose([Math.round(point.x), Math.round(point.y)], [80, -67], TOLERANCE);
            equal(align.horizontal, "left");
            equal(align.vertical, "bottom");
        });

        it("renders overlay with same path", () => {
            closePaths(ring, segment.visual.children[1]);
        });

        it("does not set overlay options when no overlay is defined", () => {
            createSegment({ overlay: null });
            equal(segment.visual.children.length, 1);
        });

        it("createOverlay renders the same path", () => {
            closePaths(ring, segment.createHighlight());
        });
    });

    // ------------------------------------------------------------
    describe('Donut Segment / custom visual', () => {

        it("adds custom visual", () => {
            let visual;
            createSegment({
                visual: function(e) {
                    visual = new draw.Path();
                    return visual;
                }
            });
            equal(segment.visual.children.length, 1);
            ok(segment.visual.children[0] === visual);
        });

        it("doesn't add visual  if custom visual function returns undefined", () => {
            createSegment({
                visual: function() {}
            });
            equal(segment.visual.children.length, 0);
        });

        it("passes options to custom visual function", () => {
            createSegment({
                visual: function(e) {
                   equal(segment.options, e.options);
                }
            });
        });

        it("passes category, dataItem, value, series and percentage to custom visual function", () => {
            createSegment({
                visual: function(e) {
                   equal(segment.category, CATEGORY);
                   equal(segment.dataItem.value, VALUE);
                   equal(segment.value, VALUE);
                   equal(e.series.name, SERIES_NAME);
                   equal(e.percentage, PERCENTAGE);
                }
            });
        });

        it("passes radius, innerRadius, startAngle, endAngle and center to custom visual function", () => {
            createSegment({
                visual: function(e) {
                   const startAngle = (segment.sector.startAngle + 180) % 360;
                   equal(e.radius, segment.sector.radius);
                   equal(e.innerRadius, segment.sector.innerRadius);
                   equal(e.startAngle, startAngle);
                   equal(e.endAngle, startAngle + segment.sector.angle);
                   equal(e.center.x, segment.sector.center.x);
                   equal(e.center.y, segment.sector.center.y);
                }
            });
        });

        it("createVisual creates default visual", () => {
            createSegment({
                visual: function(e) {
                   const defaultVisual = e.createVisual();
                   ok(defaultVisual instanceof draw.Group);
                   ok(defaultVisual.children[0] instanceof draw.Path);
                   ok(defaultVisual.children[1] instanceof draw.Path);
                }
            });
        });
    });

})();


(function() {
    // ------------------------------------------------------------
    let chart, labelElement, segmentElement;

    function createDonutChart(options) {
        chart = createChart(deepExtend({
            series: [{
                type: "donut",
                data: [1],
                labels: {
                    visible: true,
                    distance: 20
                }
            }]
        }, options));

        const plotArea = chart._model.children[1];
        const segment = plotArea.charts[0].points[0];
        const label = segment.children[0];

        segmentElement = getChartDomElement(segment);
        labelElement = getChartDomElement(label);
    }

    describe('Donut Chart / Events / seriesClick ', () => {
        beforeEach(() => {
            createDonutChart({
                seriesClick: function() { ok(true); }
            });
        });
        
        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when clicking points", 1, () => {
            clickChart(chart, segmentElement);
        });

        it("fires when clicking labels", 1, () => {
            clickChart(chart, labelElement);
        });
    });

    // ------------------------------------------------------------
    describe('Donut Chart / Events / seriesHover', () => {
        beforeEach(() => {
            createDonutChart({
                seriesHover: function() { ok(true); }
            });
        });
        
        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when clicking points", 1, () => {
            triggerEvent("mouseover", segmentElement);
        });

        it("fires when clicking labels", 1, () => {
            triggerEvent("mouseover", labelElement);            
        });
    });

})();

(function() {
    const chartBox = new Box(0,0,400,400);
    let points, plotArea, donutChart;

    function PlotAreaStub() { }

    deepExtend(PlotAreaStub.prototype, {
        options: { }
    });

    function createDonutChart(options) {
        plotArea = new PlotAreaStub();

        donutChart = new DonutChart(plotArea, deepExtend({}, {
            series: [{
                type: "donut",
                data: [1, 1],
                labels: {},
                margin: 20,
                holeSize: 40,
                startAngle: 20
            }, {
                type: "donut",
                data: [1, 2],
                labels: {},
                margin: 20,
                startAngle: 100
            }]}, options));

        donutChart.reflow(chartBox);

        points = donutChart.points;
    }

    // ------------------------------------------------------------
    describe('Donut Chart / Series / Configuration', () => {
        beforeEach(() => {
            createDonutChart();
        });

        it("first level points have margin", () => {
            const segment = points[points.length - 1];
            const sector = segment.sector;
            const size = sector.radius - sector.innerRadius;

            equal(size, 40);
        });

        it("first level points have holeSize", () => {
            each(points, function() {
                if (this.seriesIx == 0) {
                    ok(this.sector.innerRadius == 40);
                }
            });
        });

        it("should apply start angle to all series", () => {
            ok(points[0].options.startAngle === 20 &&
               points[2].options.startAngle === 100);
        });

        it("points can be removed with visible false", () => {
            plotArea = new PlotAreaStub();

            donutChart = new DonutChart(plotArea, {
                series: [{
                    type: "donut",
                    data: [{
                        value: 100,
                        category: "Value A"
                    }, {
                        value: 200,
                        category: "Value B",
                        visible: false
                    }, {
                        value: 300,
                        category: "Value C",
                        visible: false
                    }]
                }]});

            donutChart.reflow(chartBox);

            points = donutChart.points;

            equal(points.length, 1);
        });

        it("color fn argument contains value", 1, () => {
            createDonutChart({
                series: [{
                    type: "donut",
                    data: [1],
                    color: function(p) { equal(p.value, 1); }
                }]
            });
        });

        it("color fn argument contains percentage", 1, () => {
            createDonutChart({
                series: [{
                    type: "donut",
                    data: [1],
                    color: function(p) { equal(p.percentage, 1); }
                }]
            });
        });

        it("color fn argument contains dataItem", 1, () => {
            createDonutChart({
                series: [{
                    type: "donut",
                    data: [1],
                    color: function(p) {
                        equal(p.dataItem, 1);
                    }
                }]
            });
        });

        it("color fn argument contains series", 1, () => {
            createDonutChart({
                series: [{
                    type: "donut",
                    data: [1],
                    name: "donutSeries",
                    color: function(p) { equal(p.series.name, "donutSeries"); }
                }]
            });
        });
    });
})();
