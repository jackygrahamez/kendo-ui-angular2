import 'core-js/es6';

import { Box, Point } from '../../src/core';
import CategoricalPlotArea from '../../src/chart/plotarea/categorical-plotarea';
import WaterfallChart from '../../src/chart/waterfall-chart/waterfall-chart';
import WaterfallSegment from '../../src/chart/waterfall-chart/waterfall-segment';

import { deepExtend, map } from '../../src/common';

import { ok, equal } from '../../test/test-helpers';

let plotArea, chart;

function createChart(series, options) {
    plotArea = new CategoricalPlotArea([]);
    chart = new WaterfallChart(plotArea, deepExtend({ series: series }, options));
}

function makeSeries(data) {
    return [{
        type: "waterfall",
        data: data
    }];
}

function assertFields(field, values) {
    equal(map(chart.points, function(p) { return p[field]; }), values);
}

// ------------------------------------------------------------
describe('Waterfall / Point Fields /', () => {
    beforeEach(() => {
        createChart(makeSeries([1, 2, 3, 4]));
    });

    it("total field is set on all points", () => {
        assertFields("total", [1, 3, 6, 10]);
    });

    it("runningTotal field is set on all points", () => {
        assertFields("runningTotal", [1, 3, 6, 10]);
    });

    it("sets correct category if multiple categoryAxis are used", () => {
        plotArea = new CategoricalPlotArea([{
                type: "waterfall",
                categoryAxis: "A",
                data: [1, 2]
            }, {
                type: "waterfall",
                categoryAxis: "B",
                data: [3, 4]
            }], {
            categoryAxis: [{
                name: "A",
                categories: [1, 2]
            }, {
                name: "B",
                categories: [3, 4]
            }]
        });

        for (let chartIdx = 0; chartIdx < plotArea.charts.length; chartIdx++) {
            chart = plotArea.charts[chartIdx];

            for (let idx = 0; idx < chart.points.length; idx++) {
                equal(chart.points[idx].category, chart.points[idx].value);
            }
        }
    });
});

// ------------------------------------------------------------
describe('Waterfall / Running Total /', () => {
    beforeEach(() => {
        createChart(makeSeries([
           { summary: "runningTotal" },
           { value: 1 }, { value: 2 }, { summary: "runningTotal" },
           { value: 3 }, { value: 4 }, { summary: "runningTotal" }
        ]));
    });

    it("runningTotal field is set on all points", () => {
        assertFields("runningTotal", [0, 1, 3, 0, 3, 7, 0]);
    });

    it("running total #1 is set as value", () => {
        equal(chart.points[0].value, 0);
    });

    it("running total #2 is set as value", () => {
        equal(chart.points[3].value, 3);
    });

    it("running total #3 is set as value", () => {
        equal(chart.points[6].value, 7);
    });
});

// ------------------------------------------------------------
describe('Waterfall / Running Total / Missing Values /', () => {

    it("ignores null values", () => {
        createChart(makeSeries([
           { value: 1 }, { value: null }, { value: 2 }, { summary: "runningTotal" }
        ]));

        assertFields("runningTotal", [1, 1, 3, 0]);
    });

    it("ignores undefined values", () => {
        createChart(makeSeries([
           { value: 1 }, {}, { value: 2 }, { summary: "runningTotal" }
        ]));

        assertFields("runningTotal", [1, 1, 3, 0]);
    });

    it("ignores NaN values", () => {
        createChart(makeSeries([
           { value: 1 }, { value: NaN }, { value: 2 }, { summary: "runningTotal" }
        ]));

        assertFields("runningTotal", [1, 1, 3, 0]);
    });

    it("ignores other values", () => {
        createChart(makeSeries([
           { value: 1 }, { value: "foo" }, { value: 2 }, { summary: "runningTotal" }
        ]));

        assertFields("runningTotal", [1, 1, 3, 0]);
    });
});

// ------------------------------------------------------------
describe('Waterfall / Total /', () => {
    beforeEach(() => {
        createChart(makeSeries([
           { summary: "total" },
           { value: 1 }, { value: 2 }, { summary: "total" },
           { value: 3 }, { value: 4 }, { summary: "total" }
        ]));
    });

    it("total field is set on all points", () => {
        assertFields("total", [0, 1, 3, 3, 6, 10, 10]);
    });

    it("total #1 is set as value", () => {
        equal(chart.points[0].value, 0);
    });

    it("total #2 is set as value", () => {
        equal(chart.points[3].value, 3);
    });

    it("total #3 is set as value", () => {
        equal(chart.points[6].value, 10);
    });

    it("total is not reset by running total", () => {
        createChart(makeSeries([
           { value: 1 }, { value: 2 }, { summary: "runningTotal" },
           { value: 3 }, { value: 4 }, { summary: "total" }
        ]));

        equal(chart.points[5].value, 10);
    });
});

// ------------------------------------------------------------
describe('Waterfall / Total / Missing Values /', () => {

    it("ignores null values", () => {
        createChart(makeSeries([
           { value: 1 }, { value: null }, { value: 2 }, { summary: "total" }
        ]));

        assertFields("total", [1, 1, 3, 3]);
    });

    it("ignores undefined values", () => {
        createChart(makeSeries([
           { value: 1 }, {}, { value: 2 }, { summary: "total" }
        ]));

        assertFields("total", [1, 1, 3, 3]);
    });

    it("ignores NaN values", () => {
        createChart(makeSeries([
           { value: 1 }, { value: NaN }, { value: 2 }, { summary: "total" }
        ]));

        assertFields("total", [1, 1, 3, 3]);
    });

    it("ignores other values", () => {
        createChart(makeSeries([
           { value: 1 }, { value: "foo" }, { value: 2 }, { summary: "total" }
        ]));

        assertFields("total", [1, 1, 3, 3]);
    });
});

// ------------------------------------------------------------
describe('Waterfall / Plot Range /', () => {
    function assertPlotRange(index, range) {
        equal(chart.plotRange(chart.points[index]), range);
    }

    beforeEach(() => {
        createChart(makeSeries([
           { value: 1 }, { value: 3 }, { summary: "runningTotal" },
           { value: -1 }, { value: -2 }, { summary: "runningTotal" },
           { summary: "total" }
        ]));
    });

    it("point #1 starts at 0", () => {
        assertPlotRange(0, [0, 1]);
    });

    it("point #2 starts point #1 end", () => {
        assertPlotRange(1, [1, 4]);
    });

    it("point #3 shows running total from point #2 end", () => {
        assertPlotRange(2, [4, 0]);
    });

    it("point #4 starts from point #2", () => {
        assertPlotRange(3, [4, 3]);
    });

    it("point #5 starts from point #4 end", () => {
        assertPlotRange(4, [3, 1]);
    });

    it("point #6 shows running total starting from point #5 end", () => {
        assertPlotRange(5, [1, 4]);
    });

    it("point #7 shows total starting from 0", () => {
        assertPlotRange(6, [0, 1]);
    });

    it("negative running total", () => {
        createChart(makeSeries([
           { value: -1 }, { value: -2 }, { summary: "runningTotal" }
        ]));

        assertPlotRange(2, [-3, 0]);
    });

    it("negative total", () => {
        createChart(makeSeries([
           { value: -1 }, { value: -2 }, { summary: "total" }
        ]));

        assertPlotRange(2, [0, -3]);
    });
});

// ------------------------------------------------------------
describe('Waterfall / Axis Range /', () => {
    beforeEach(() => {
        createChart(makeSeries([
           { value: 1 }, { value: 3 }, { summary: "runningTotal" },
           { value: -1 }, { value: -2 }, { summary: "total" }
        ]));
    });

    it("Reports minimum value for default axis", () => {
        equal(chart.valueAxisRanges[undefined].min, 0);
    });

    it("Reports maximum value for default axis", () => {
        equal(chart.valueAxisRanges[undefined].max, 4);
    });

    it("negative running total", () => {
        createChart(makeSeries([
           { value: 1 }, { value: 2 }, { summary: "runningTotal" },
           { value: -1 }, { summary: "runningTotal" }
        ]));

        equal(chart.valueAxisRanges[undefined].min, 0);
    });
});

// ------------------------------------------------------------
describe('Waterfall / Segments /', () => {

    function assertSegment(segmentIx, fromIx, toIx) {
        equal(chart.segments[segmentIx].from, chart.points[fromIx]);
        equal(chart.segments[segmentIx].to, chart.points[toIx]);
    }

    beforeEach(() => {
        createChart(makeSeries([
           { value: 1 }, { value: 3 }, { summary: "runningTotal" },
           { value: -1 }, { value: -2 }, { summary: "total" }
        ]));
    });

    it("creates segments between regular points", () => {
        assertSegment(0, 0, 1);
        assertSegment(3, 3, 4);
    });

    it("creates segments between regular points and totals", () => {
        assertSegment(1, 1, 2);
        assertSegment(2, 2, 3);
        assertSegment(4, 4, 5);
    });

    it("doesn't fail with no points", () => {
        createChart(makeSeries([]));
        ok(true);
    });
});

// ------------------------------------------------------------
(function() {
    let segment, polyline;

    describe('WaterfallSegment', () => {
        beforeEach(() => {
            segment = new WaterfallSegment({
                // From point
                aboveAxis: true,
                isVertical: true,
                box: new Box(0, 0, 10, 100)
            }, {
                // To point
                aboveAxis: true,
                isVertical: true,
                box: new Box(20, 0, 30, 100)
            }, {
                // Series
                line: {
                    color: "blue",
                    width: 2,
                    opacity: 0.5,
                    dashType: "dot"
                }
            });

            segment.renderVisual();
            polyline = segment.visual.children[0];
        });

        it("connects point end to next point start", () => {
            equal(polyline.segments[0].anchor().toString(), "0 0");
            equal(polyline.segments[1].anchor().toString(), "30 0");
        });

        it("connects point end to next point start (negative values)", () => {
            segment.from.aboveAxis = segment.to.aboveAxis = false;
            segment.renderVisual();
            polyline = segment.visual.children[0];
            equal(polyline.segments[0].anchor().toString(), "0 100");
            equal(polyline.segments[1].anchor().toString(), "30 100");
        });

        it("renders open polyline", () => {
            ok(!polyline.closed);
        });

        it("sets default animation", () => {
            equal(segment.animation.options.type, "fadeIn");
        });

        it("sets color", () => {
            equal(polyline.options.stroke.color, "blue");
        });

        it("sets width", () => {
            equal(polyline.options.stroke.width, 2);
        });

        it("sets opacity", () => {
            equal(polyline.options.stroke.opacity, 0.5);
        });

        it("sets dashType", () => {
            equal(polyline.options.stroke.dashType, "dot");
        });
    });

    // ------------------------------------------------------------
    describe('WaterfallSegment / Horizontal', () => {
        beforeEach(() => {
            segment = new WaterfallSegment({
                // From point
                aboveAxis: true,
                isVertical: false,
                box: new Box(0, 0, 100, 10)
            }, {
                // To point
                aboveAxis: true,
                isVertical: false,
                box: new Box(0, 20, 100, 30)
            }, {
                // Series
            });

            segment.renderVisual();
            polyline = segment.visual.children[0];
        });

        it("connects point end to next point start", () => {
            ok(polyline.segments[0].anchor().equals(new Point(100.5, 0.5)));
            ok(polyline.segments[1].anchor().equals(new Point(100.5, 30.5)));
        });

        it("connects point end to next point start (negative values)", () => {
            segment.from.aboveAxis = segment.to.aboveAxis = false;
            segment.renderVisual();
            polyline = segment.visual.children[0];
            ok(polyline.segments[0].anchor().equals(new Point(0.5, 0.5)));
            ok(polyline.segments[1].anchor().equals(new Point(0.5, 30.5)));
        });
    });
});

// ------------------------------------------------------------
describe('Waterfall / point / custom visual', () => {

    let segment, polyline;

    it("Passes runningTotal and total", () => {
        createChart([{
            data: [1, 2],
            visual: function(e) {
                equal(e.runningTotal, 3);
                equal(e.total, 3);
            }
        }]);
        const point = chart.points[1];
        point.parent = {
            appendVisual: function() {},
            getRoot: function() {}
        };
        point.reflow(new Box(0, 0, 100, 100));
        point.renderVisual();

    });

});
