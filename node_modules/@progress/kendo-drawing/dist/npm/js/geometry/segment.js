module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(197);


/***/ },

/***/ 104:
/***/ function(module, exports) {

	module.exports = require("../mixins/observers-mixin");

/***/ },

/***/ 155:
/***/ function(module, exports) {

	module.exports = require("./math/deg");

/***/ },

/***/ 159:
/***/ function(module, exports) {

	module.exports = require("./constants");

/***/ },

/***/ 160:
/***/ function(module, exports) {

	module.exports = require("./point");

/***/ },

/***/ 161:
/***/ function(module, exports) {

	module.exports = require("./rect");

/***/ },

/***/ 197:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _observersMixin = __webpack_require__(104);

	var _observersMixin2 = _interopRequireDefault(_observersMixin);

	var _definePointAccessors = __webpack_require__(198);

	var _definePointAccessors2 = _interopRequireDefault(_definePointAccessors);

	var _rect = __webpack_require__(161);

	var _rect2 = _interopRequireDefault(_rect);

	var _point = __webpack_require__(160);

	var _point2 = _interopRequireDefault(_point);

	var _transform = __webpack_require__(199);

	var _transform2 = _interopRequireDefault(_transform);

	var _deg = __webpack_require__(155);

	var _deg2 = _interopRequireDefault(_deg);

	var _isOutOfEndPoint = __webpack_require__(200);

	var _isOutOfEndPoint2 = _interopRequireDefault(_isOutOfEndPoint);

	var _calculateCurveAt = __webpack_require__(201);

	var _calculateCurveAt2 = _interopRequireDefault(_calculateCurveAt);

	var _hasRootsInRange = __webpack_require__(202);

	var _hasRootsInRange2 = _interopRequireDefault(_hasRootsInRange);

	var _curveIntersectionsCount = __webpack_require__(203);

	var _curveIntersectionsCount2 = _interopRequireDefault(_curveIntersectionsCount);

	var _lineIntersectionsCount = __webpack_require__(204);

	var _lineIntersectionsCount2 = _interopRequireDefault(_lineIntersectionsCount);

	var _constants = __webpack_require__(159);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Segment = function () {
	    function Segment(anchor, controlIn, controlOut) {
	        _classCallCheck(this, Segment);

	        this.anchor(anchor || new _point2.default());
	        this.controlIn(controlIn);
	        this.controlOut(controlOut);
	    }

	    _createClass(Segment, [{
	        key: 'bboxTo',
	        value: function bboxTo(toSegment, matrix) {
	            var segmentAnchor = this.anchor().transformCopy(matrix);
	            var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);
	            var rect = void 0;

	            if (this.controlOut() && toSegment.controlIn()) {
	                rect = this._curveBoundingBox(segmentAnchor, this.controlOut().transformCopy(matrix), toSegment.controlIn().transformCopy(matrix), toSegmentAnchor);
	            } else {
	                rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);
	            }

	            return rect;
	        }
	    }, {
	        key: '_lineBoundingBox',
	        value: function _lineBoundingBox(p1, p2) {
	            return _rect2.default.fromPoints(p1, p2);
	        }
	    }, {
	        key: '_curveBoundingBox',
	        value: function _curveBoundingBox(p1, cp1, cp2, p2) {
	            var points = [p1, cp1, cp2, p2];
	            var extremesX = this._curveExtremesFor(points, "x");
	            var extremesY = this._curveExtremesFor(points, "y");
	            var xLimits = arrayLimits([extremesX.min, extremesX.max, p1.x, p2.x]);
	            var yLimits = arrayLimits([extremesY.min, extremesY.max, p1.y, p2.y]);

	            return _rect2.default.fromPoints(new _point2.default(xLimits.min, yLimits.min), new _point2.default(xLimits.max, yLimits.max));
	        }
	    }, {
	        key: '_curveExtremesFor',
	        value: function _curveExtremesFor(points, field) {
	            var extremes = this._curveExtremes(points[0][field], points[1][field], points[2][field], points[3][field]);

	            return {
	                min: (0, _calculateCurveAt2.default)(extremes.min, field, points),
	                max: (0, _calculateCurveAt2.default)(extremes.max, field, points)
	            };
	        }
	    }, {
	        key: '_curveExtremes',
	        value: function _curveExtremes(x1, x2, x3, x4) {
	            var a = x1 - 3 * x2 + 3 * x3 - x4;
	            var b = -2 * (x1 - 2 * x2 + x3);
	            var c = x1 - x2;
	            var sqrt = Math.sqrt(b * b - 4 * a * c);
	            var t1 = 0;
	            var t2 = 1;

	            if (a === 0) {
	                if (b !== 0) {
	                    t1 = t2 = -c / b;
	                }
	            } else if (!isNaN(sqrt)) {
	                t1 = (-b + sqrt) / (2 * a);
	                t2 = (-b - sqrt) / (2 * a);
	            }

	            var min = Math.max(Math.min(t1, t2), 0);
	            if (min < 0 || min > 1) {
	                min = 0;
	            }

	            var max = Math.min(Math.max(t1, t2), 1);
	            if (max > 1 || max < 0) {
	                max = 1;
	            }

	            return {
	                min: min,
	                max: max
	            };
	        }
	    }, {
	        key: '_intersectionsTo',
	        value: function _intersectionsTo(segment, point) {
	            var intersectionsCount = void 0;
	            if (this.controlOut() && segment.controlIn()) {
	                intersectionsCount = (0, _curveIntersectionsCount2.default)([this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor()], point, this.bboxTo(segment));
	            } else {
	                intersectionsCount = (0, _lineIntersectionsCount2.default)(this.anchor(), segment.anchor(), point);
	            }
	            return intersectionsCount;
	        }
	    }, {
	        key: '_isOnCurveTo',
	        value: function _isOnCurveTo(segment, point, width, endSegment) {
	            var bbox = this.bboxTo(segment).expand(width, width);
	            if (bbox.containsPoint(point)) {
	                var p1 = this.anchor();
	                var p2 = this.controlOut();
	                var p3 = segment.controlIn();
	                var p4 = segment.anchor();

	                if (endSegment === "start" && p1.distanceTo(point) <= width) {
	                    return !(0, _isOutOfEndPoint2.default)(p1, p2, point);
	                } else if (endSegment === "end" && p4.distanceTo(point) <= width) {
	                    return !(0, _isOutOfEndPoint2.default)(p4, p3, point);
	                }

	                //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points
	                var points = [p1, p2, p3, p4];
	                if ((0, _hasRootsInRange2.default)(points, point, "x", "y", width) || (0, _hasRootsInRange2.default)(points, point, "y", "x", width)) {
	                    return true;
	                }
	                var rotation = (0, _transform2.default)().rotate(45, point);
	                var rotatedPoints = [p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation)];
	                return (0, _hasRootsInRange2.default)(rotatedPoints, point, "x", "y", width) || (0, _hasRootsInRange2.default)(rotatedPoints, point, "y", "x", width);
	            }
	        }
	    }, {
	        key: '_isOnLineTo',
	        value: function _isOnLineTo(segment, point, width) {
	            var p1 = this.anchor();
	            var p2 = segment.anchor();
	            var angle = (0, _deg2.default)(Math.atan2(p2.y - p1.y, p2.x - p1.x));
	            var rect = new _rect2.default([p1.x, p1.y - width / 2], [p1.distanceTo(p2), width]);
	            return rect.containsPoint(point.transformCopy((0, _transform2.default)().rotate(-angle, p1)));
	        }
	    }, {
	        key: '_isOnPathTo',
	        value: function _isOnPathTo(segment, point, width, endSegment) {
	            var isOnPath = void 0;
	            if (this.controlOut() && segment.controlIn()) {
	                isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);
	            } else {
	                isOnPath = this._isOnLineTo(segment, point, width);
	            }
	            return isOnPath;
	        }
	    }]);

	    return Segment;
	}();

	(0, _definePointAccessors2.default)(Segment.prototype, ["anchor", "controlIn", "controlOut"]);
	_observersMixin2.default.extend(Segment.prototype);

	function arrayLimits(arr) {
	    var length = arr.length;
	    var min = _constants.MAX_NUM;
	    var max = _constants.MIN_NUM;

	    for (var i = 0; i < length; i++) {
	        max = Math.max(max, arr[i]);
	        min = Math.min(min, arr[i]);
	    }

	    return {
	        min: min,
	        max: max
	    };
	}

	exports.default = Segment;

/***/ },

/***/ 198:
/***/ function(module, exports) {

	module.exports = require("../accessors/define-point-accessors");

/***/ },

/***/ 199:
/***/ function(module, exports) {

	module.exports = require("./transform");

/***/ },

/***/ 200:
/***/ function(module, exports) {

	module.exports = require("./math/is-out-of-end-point");

/***/ },

/***/ 201:
/***/ function(module, exports) {

	module.exports = require("./math/calculate-curve-at");

/***/ },

/***/ 202:
/***/ function(module, exports) {

	module.exports = require("./math/has-roots-in-range");

/***/ },

/***/ 203:
/***/ function(module, exports) {

	module.exports = require("./math/curve-intersections-count");

/***/ },

/***/ 204:
/***/ function(module, exports) {

	module.exports = require("./math/line-intersections-count");

/***/ }

/******/ });