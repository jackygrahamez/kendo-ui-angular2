module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(212);


/***/ },

/***/ 5:
/***/ function(module, exports) {

	module.exports = require("../../common/constants");

/***/ },

/***/ 6:
/***/ function(module, exports) {

	module.exports = require("../../common/is-number");

/***/ },

/***/ 7:
/***/ function(module, exports) {

	module.exports = require("../../common/defined");

/***/ },

/***/ 15:
/***/ function(module, exports) {

	module.exports = require("../../common/in-array");

/***/ },

/***/ 24:
/***/ function(module, exports) {

	module.exports = require("../constants");

/***/ },

/***/ 25:
/***/ function(module, exports) {

	module.exports = require("../../common/set-default-options");

/***/ },

/***/ 42:
/***/ function(module, exports) {

	module.exports = require("../line-chart/line-chart");

/***/ },

/***/ 50:
/***/ function(module, exports) {

	module.exports = require("../../common/deep-extend");

/***/ },

/***/ 55:
/***/ function(module, exports) {

	module.exports = require("../../core");

/***/ },

/***/ 82:
/***/ function(module, exports) {

	module.exports = require("../candlestick-chart/candlestick-chart");

/***/ },

/***/ 96:
/***/ function(module, exports) {

	module.exports = require("../bar-chart/bar-chart");

/***/ },

/***/ 158:
/***/ function(module, exports) {

	module.exports = require("../series-binder");

/***/ },

/***/ 212:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _plotareaBase = __webpack_require__(213);

	var _plotareaBase2 = _interopRequireDefault(_plotareaBase);

	var _axisGroupRangeTracker = __webpack_require__(214);

	var _axisGroupRangeTracker2 = _interopRequireDefault(_axisGroupRangeTracker);

	var _plotareaEventsMixin = __webpack_require__(215);

	var _plotareaEventsMixin2 = _interopRequireDefault(_plotareaEventsMixin);

	var _seriesAggregator = __webpack_require__(216);

	var _seriesAggregator2 = _interopRequireDefault(_seriesAggregator);

	var _defaultAggregates = __webpack_require__(217);

	var _defaultAggregates2 = _interopRequireDefault(_defaultAggregates);

	var _seriesBinder = __webpack_require__(158);

	var _seriesBinder2 = _interopRequireDefault(_seriesBinder);

	var _barChart = __webpack_require__(96);

	var _barChart2 = _interopRequireDefault(_barChart);

	var _rangeBarChart = __webpack_require__(218);

	var _rangeBarChart2 = _interopRequireDefault(_rangeBarChart);

	var _bulletChart = __webpack_require__(219);

	var _bulletChart2 = _interopRequireDefault(_bulletChart);

	var _lineChart = __webpack_require__(42);

	var _lineChart2 = _interopRequireDefault(_lineChart);

	var _areaChart = __webpack_require__(220);

	var _areaChart2 = _interopRequireDefault(_areaChart);

	var _ohlcChart = __webpack_require__(221);

	var _ohlcChart2 = _interopRequireDefault(_ohlcChart);

	var _candlestickChart = __webpack_require__(82);

	var _candlestickChart2 = _interopRequireDefault(_candlestickChart);

	var _boxPlotChart = __webpack_require__(222);

	var _boxPlotChart2 = _interopRequireDefault(_boxPlotChart);

	var _waterfallChart = __webpack_require__(223);

	var _waterfallChart2 = _interopRequireDefault(_waterfallChart);

	var _core = __webpack_require__(55);

	var _filterSeriesByType = __webpack_require__(224);

	var _filterSeriesByType2 = _interopRequireDefault(_filterSeriesByType);

	var _equalsIgnoreCase = __webpack_require__(225);

	var _equalsIgnoreCase2 = _interopRequireDefault(_equalsIgnoreCase);

	var _categoriesCount = __webpack_require__(226);

	var _categoriesCount2 = _interopRequireDefault(_categoriesCount);

	var _getField = __webpack_require__(227);

	var _getField2 = _interopRequireDefault(_getField);

	var _isDateAxis = __webpack_require__(228);

	var _isDateAxis2 = _interopRequireDefault(_isDateAxis);

	var _appendIfNotNull = __webpack_require__(229);

	var _appendIfNotNull2 = _interopRequireDefault(_appendIfNotNull);

	var _singleItemOrArray = __webpack_require__(230);

	var _singleItemOrArray2 = _interopRequireDefault(_singleItemOrArray);

	var _getDateField = __webpack_require__(231);

	var _getDateField2 = _interopRequireDefault(_getDateField);

	var _constants = __webpack_require__(24);

	var _constants2 = __webpack_require__(5);

	var _setDefaultOptions = __webpack_require__(25);

	var _setDefaultOptions2 = _interopRequireDefault(_setDefaultOptions);

	var _inArray = __webpack_require__(15);

	var _inArray2 = _interopRequireDefault(_inArray);

	var _isNumber = __webpack_require__(6);

	var _isNumber2 = _interopRequireDefault(_isNumber);

	var _deepExtend = __webpack_require__(50);

	var _deepExtend2 = _interopRequireDefault(_deepExtend);

	var _defined = __webpack_require__(7);

	var _defined2 = _interopRequireDefault(_defined);

	var _grep = __webpack_require__(232);

	var _grep2 = _interopRequireDefault(_grep);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var EQUALLY_SPACED_SERIES = [_constants.BAR, _constants.COLUMN, _constants.OHLC, _constants.CANDLESTICK, _constants.BOX_PLOT, _constants.VERTICAL_BOX_PLOT, _constants.BULLET, _constants.RANGE_COLUMN, _constants.RANGE_BAR, _constants.WATERFALL, _constants.HORIZONTAL_WATERFALL];

	var CategoricalPlotArea = function (_PlotAreaBase) {
	    _inherits(CategoricalPlotArea, _PlotAreaBase);

	    function CategoricalPlotArea() {
	        _classCallCheck(this, CategoricalPlotArea);

	        return _possibleConstructorReturn(this, (CategoricalPlotArea.__proto__ || Object.getPrototypeOf(CategoricalPlotArea)).apply(this, arguments));
	    }

	    _createClass(CategoricalPlotArea, [{
	        key: 'initFields',
	        value: function initFields(series) {
	            this.namedCategoryAxes = {};
	            this.namedValueAxes = {};
	            this.valueAxisRangeTracker = new _axisGroupRangeTracker2.default();

	            if (series.length > 0) {
	                this.invertAxes = (0, _inArray2.default)(series[0].type, [_constants.BAR, _constants.BULLET, _constants.VERTICAL_LINE, _constants.VERTICAL_AREA, _constants.RANGE_BAR, _constants.HORIZONTAL_WATERFALL, _constants.VERTICAL_BOX_PLOT]);

	                for (var i = 0; i < series.length; i++) {
	                    var stack = series[i].stack;
	                    if (stack && stack.type === "100%") {
	                        this.stack100 = true;
	                        break;
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var panes = arguments.length <= 0 || arguments[0] === undefined ? this.panes : arguments[0];

	            this.createCategoryAxes(panes);
	            this.aggregateCategories(panes);
	            this.createCategoryAxesLabels(panes);
	            this.createCharts(panes);
	            this.createValueAxes(panes);
	        }
	    }, {
	        key: 'removeAxis',
	        value: function removeAxis(axis) {
	            var axisName = axis.options.name;

	            _get(CategoricalPlotArea.prototype.__proto__ || Object.getPrototypeOf(CategoricalPlotArea.prototype), 'removeAxis', this).call(this, axis);

	            if (axis instanceof _core.CategoryAxis) {
	                delete this.namedCategoryAxes[axisName];
	            } else {
	                this.valueAxisRangeTracker.reset(axisName);
	                delete this.namedValueAxes[axisName];
	            }

	            if (axis === this.categoryAxis) {
	                delete this.categoryAxis;
	            }

	            if (axis === this.valueAxis) {
	                delete this.valueAxis;
	            }
	        }
	    }, {
	        key: 'createCharts',
	        value: function createCharts(panes) {
	            var seriesByPane = this.groupSeriesByPane();

	            for (var i = 0; i < panes.length; i++) {
	                var pane = panes[i];
	                var paneSeries = seriesByPane[pane.options.name || "default"] || [];
	                this.addToLegend(paneSeries);

	                var visibleSeries = this.filterVisibleSeries(paneSeries);
	                if (!visibleSeries) {
	                    continue;
	                }

	                var groups = this.groupSeriesByCategoryAxis(visibleSeries);
	                for (var groupIx = 0; groupIx < groups.length; groupIx++) {
	                    this.createChartGroup(groups[groupIx], pane);
	                }
	            }
	        }
	    }, {
	        key: 'createChartGroup',
	        value: function createChartGroup(series, pane) {
	            this.createAreaChart((0, _filterSeriesByType2.default)(series, [_constants.AREA, _constants.VERTICAL_AREA]), pane);

	            this.createBarChart((0, _filterSeriesByType2.default)(series, [_constants.COLUMN, _constants.BAR]), pane);

	            this.createRangeBarChart((0, _filterSeriesByType2.default)(series, [_constants.RANGE_COLUMN, _constants.RANGE_BAR]), pane);

	            this.createBulletChart((0, _filterSeriesByType2.default)(series, [_constants.BULLET, _constants.VERTICAL_BULLET]), pane);

	            this.createCandlestickChart((0, _filterSeriesByType2.default)(series, _constants.CANDLESTICK), pane);

	            this.createBoxPlotChart((0, _filterSeriesByType2.default)(series, [_constants.BOX_PLOT, _constants.VERTICAL_BOX_PLOT]), pane);

	            this.createOHLCChart((0, _filterSeriesByType2.default)(series, _constants.OHLC), pane);

	            this.createWaterfallChart((0, _filterSeriesByType2.default)(series, [_constants.WATERFALL, _constants.HORIZONTAL_WATERFALL]), pane);

	            this.createLineChart((0, _filterSeriesByType2.default)(series, [_constants.LINE, _constants.VERTICAL_LINE]), pane);
	        }
	    }, {
	        key: 'aggregateCategories',
	        value: function aggregateCategories(panes) {
	            var series = this.srcSeries || this.series;
	            var processedSeries = [];

	            for (var i = 0; i < series.length; i++) {
	                var currentSeries = series[i];
	                var categoryAxis = this.seriesCategoryAxis(currentSeries);
	                var axisPane = this.findPane(categoryAxis.options.pane);
	                var dateAxis = (0, _equalsIgnoreCase2.default)(categoryAxis.options.type, _constants2.DATE);

	                if ((dateAxis || currentSeries.categoryField) && (0, _inArray2.default)(axisPane, panes)) {
	                    currentSeries = this.aggregateSeries(currentSeries, categoryAxis);
	                } else if ((0, _isNumber2.default)(categoryAxis.options.min) || (0, _isNumber2.default)(categoryAxis.options.max)) {
	                    currentSeries = this.filterSeries(currentSeries, categoryAxis);
	                }

	                processedSeries.push(currentSeries);
	            }

	            this.srcSeries = series;
	            this.series = processedSeries;
	        }
	    }, {
	        key: 'filterSeries',
	        value: function filterSeries(series, categoryAxis) {
	            var range = categoryAxis.totalRangeIndices();
	            var justified = categoryAxis.options.justified;
	            var outOfRangePoints = (0, _inArray2.default)(series.type, [_constants.LINE, _constants.VERTICAL_LINE, _constants.AREA, _constants.VERTICAL_AREA]);

	            range.min = (0, _isNumber2.default)(categoryAxis.options.min) ? Math.floor(range.min) : 0;
	            if ((0, _isNumber2.default)(categoryAxis.options.max)) {
	                range.max = justified ? Math.floor(range.max) + 1 : Math.ceil(range.max);
	            } else {
	                range.max = series.data.length;
	            }

	            var currentSeries = (0, _deepExtend2.default)({}, series);

	            if (outOfRangePoints) {
	                var minCategory = range.min - 1;
	                var srcCategories = categoryAxis.options.srcCategories || [];
	                if (minCategory >= 0 && minCategory < currentSeries.data.length) {
	                    currentSeries._outOfRangeMinPoint = {
	                        item: currentSeries.data[minCategory],
	                        category: srcCategories[minCategory],
	                        categoryIx: -1
	                    };
	                }

	                if (range.max < currentSeries.data.length) {
	                    currentSeries._outOfRangeMaxPoint = {
	                        item: currentSeries.data[range.max],
	                        category: srcCategories[range.max],
	                        categoryIx: range.max - range.min
	                    };
	                }
	            }

	            categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, currentSeries.data.length);

	            currentSeries.data = (currentSeries.data || []).slice(range.min, range.max);

	            return currentSeries;
	        }
	    }, {
	        key: 'aggregateSeries',
	        value: function aggregateSeries(series, categoryAxis) {
	            var outOfRangePoints = (0, _inArray2.default)(series.type, [_constants.LINE, _constants.VERTICAL_LINE, _constants.AREA, _constants.VERTICAL_AREA]);
	            var _categoryAxis$options = categoryAxis.options;
	            var categories = _categoryAxis$options.categories;
	            var _categoryAxis$options2 = _categoryAxis$options.srcCategories;
	            var srcCategories = _categoryAxis$options2 === undefined ? categories : _categoryAxis$options2;
	            var _categoryAxis$options3 = _categoryAxis$options.dataItems;
	            var dataItems = _categoryAxis$options3 === undefined ? [] : _categoryAxis$options3;

	            var dateAxis = (0, _equalsIgnoreCase2.default)(categoryAxis.options.type, _constants2.DATE);
	            var aggregatorSeries = (0, _deepExtend2.default)({}, series);
	            var result = (0, _deepExtend2.default)({}, series);
	            var srcData = series.data;
	            var srcPoints = [];
	            var outOfRangeMinIdx = _constants2.MIN_VALUE;
	            var outOfRangeMaxIdx = _constants2.MAX_VALUE;
	            var getFn = _getField2.default;
	            var outOfRangeMinCategory = void 0,
	                outOfRangeMaxCategory = void 0;

	            if (dateAxis) {
	                getFn = _getDateField2.default;
	            }

	            for (var i = 0; i < srcData.length; i++) {
	                var category = void 0;
	                if (series.categoryField) {
	                    category = getFn(series.categoryField, srcData[i]);
	                } else {
	                    category = srcCategories[i];
	                }

	                if ((0, _defined2.default)(category)) {
	                    var categoryIx = categoryAxis.categoryIndex(category);
	                    if (0 <= categoryIx && categoryIx < categories.length) {
	                        srcPoints[categoryIx] = srcPoints[categoryIx] || [];
	                        srcPoints[categoryIx].push(i);
	                    } else if (outOfRangePoints) {
	                        if (categoryIx < 0) {
	                            if (categoryIx === outOfRangeMinIdx) {
	                                outOfRangeMinCategory.points.push(i);
	                            } else if (categoryIx > outOfRangeMinIdx) {
	                                outOfRangeMinIdx = categoryIx;
	                                outOfRangeMinCategory = {
	                                    category: category,
	                                    points: [i]
	                                };
	                            }
	                        } else if (categoryIx >= categories.length) {
	                            if (categoryIx === outOfRangeMaxIdx) {
	                                outOfRangeMaxCategory.points.push(i);
	                            } else if (categoryIx < outOfRangeMaxIdx) {
	                                outOfRangeMaxIdx = categoryIx;
	                                outOfRangeMaxCategory = {
	                                    category: category,
	                                    points: [i]
	                                };
	                            }
	                        }
	                    }
	                }
	            }

	            var aggregator = new _seriesAggregator2.default(aggregatorSeries, _seriesBinder2.default.current, _defaultAggregates2.default.current);
	            var data = result.data = [];
	            for (var _i = 0; _i < categories.length; _i++) {
	                data[_i] = aggregator.aggregatePoints(srcPoints[_i], categories[_i]);
	                if (srcPoints[_i]) {
	                    dataItems[_i] = data[_i];
	                }
	            }

	            if (outOfRangeMinCategory && data.length) {
	                result._outOfRangeMinPoint = {
	                    item: aggregator.aggregatePoints(outOfRangeMinCategory.points, outOfRangeMinCategory.category),
	                    categoryIx: outOfRangeMinIdx,
	                    category: outOfRangeMinCategory.category
	                };
	            }

	            if (outOfRangeMaxCategory && data.length) {
	                result._outOfRangeMaxPoint = {
	                    item: aggregator.aggregatePoints(outOfRangeMaxCategory.points, outOfRangeMaxCategory.category),
	                    categoryIx: outOfRangeMaxIdx,
	                    category: outOfRangeMaxCategory.category
	                };
	            }
	            categoryAxis.options.dataItems = dataItems;

	            return result;
	        }
	    }, {
	        key: 'appendChart',
	        value: function appendChart(chart, pane) {
	            var series = chart.options.series;
	            var categoryAxis = this.seriesCategoryAxis(series[0]);
	            var categories = categoryAxis.options.categories;
	            var categoriesToAdd = Math.max(0, (0, _categoriesCount2.default)(series) - categories.length);

	            while (categoriesToAdd--) {
	                categories.push("");
	            }

	            this.valueAxisRangeTracker.update(chart.valueAxisRanges);

	            _get(CategoricalPlotArea.prototype.__proto__ || Object.getPrototypeOf(CategoricalPlotArea.prototype), 'appendChart', this).call(this, chart, pane);
	        }

	        // TODO: Refactor, optionally use series.pane option

	    }, {
	        key: 'seriesPaneName',
	        value: function seriesPaneName(series) {
	            var options = this.options;
	            var axisName = series.axis;
	            var axisOptions = [].concat(options.valueAxis);
	            var axis = (0, _grep2.default)(axisOptions, function (a) {
	                return a.name === axisName;
	            })[0];
	            var panes = options.panes || [{}];
	            var defaultPaneName = (panes[0] || {}).name || "default";
	            var paneName = (axis || {}).pane || defaultPaneName;

	            return paneName;
	        }
	    }, {
	        key: 'seriesCategoryAxis',
	        value: function seriesCategoryAxis(series) {
	            var axisName = series.categoryAxis;
	            var axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;

	            if (!axis) {
	                throw new Error("Unable to locate category axis with name " + axisName);
	            }

	            return axis;
	        }
	    }, {
	        key: 'stackableChartOptions',
	        value: function stackableChartOptions(firstSeries, pane) {
	            var stack = firstSeries.stack;
	            var isStacked100 = stack && stack.type === "100%";
	            var clip = pane.options.clip;

	            return {
	                isStacked: stack,
	                isStacked100: isStacked100,
	                clip: clip
	            };
	        }
	    }, {
	        key: 'groupSeriesByCategoryAxis',
	        value: function groupSeriesByCategoryAxis(series) {
	            var categoryAxes = [];
	            var unique = {};
	            for (var idx = 0; idx < series.length; idx++) {
	                var name = series[idx].categoryAxis || "$$default$$";
	                if (!unique.hasOwnProperty(name)) {
	                    unique[name] = true;
	                    categoryAxes.push(name);
	                }
	            }

	            var groups = [];
	            for (var axisIx = 0; axisIx < categoryAxes.length; axisIx++) {
	                var axis = categoryAxes[axisIx];
	                var axisSeries = groupSeries(series, axis, axisIx);
	                if (axisSeries.length === 0) {
	                    continue;
	                }

	                groups.push(axisSeries);
	            }

	            return groups;
	        }
	    }, {
	        key: 'createBarChart',
	        value: function createBarChart(series, pane) {
	            if (series.length === 0) {
	                return;
	            }

	            var firstSeries = series[0];
	            var barChart = new _barChart2.default(this, Object.assign({
	                series: series,
	                invertAxes: this.invertAxes,
	                gap: firstSeries.gap,
	                spacing: firstSeries.spacing
	            }, this.stackableChartOptions(firstSeries, pane)));

	            this.appendChart(barChart, pane);
	        }
	    }, {
	        key: 'createRangeBarChart',
	        value: function createRangeBarChart(series, pane) {
	            if (series.length === 0) {
	                return;
	            }

	            var firstSeries = series[0];
	            var rangeColumnChart = new _rangeBarChart2.default(this, {
	                series: series,
	                invertAxes: this.invertAxes,
	                gap: firstSeries.gap,
	                spacing: firstSeries.spacing
	            });

	            this.appendChart(rangeColumnChart, pane);
	        }
	    }, {
	        key: 'createBulletChart',
	        value: function createBulletChart(series, pane) {
	            if (series.length === 0) {
	                return;
	            }

	            var firstSeries = series[0];
	            var bulletChart = new _bulletChart2.default(this, {
	                series: series,
	                invertAxes: this.invertAxes,
	                gap: firstSeries.gap,
	                spacing: firstSeries.spacing,
	                clip: pane.options.clip
	            });

	            this.appendChart(bulletChart, pane);
	        }
	    }, {
	        key: 'createLineChart',
	        value: function createLineChart(series, pane) {
	            if (series.length === 0) {
	                return;
	            }

	            var firstSeries = series[0];
	            var lineChart = new _lineChart2.default(this, Object.assign({
	                invertAxes: this.invertAxes,
	                series: series
	            }, this.stackableChartOptions(firstSeries, pane)));

	            this.appendChart(lineChart, pane);
	        }
	    }, {
	        key: 'createAreaChart',
	        value: function createAreaChart(series, pane) {
	            if (series.length === 0) {
	                return;
	            }

	            var firstSeries = series[0];
	            var areaChart = new _areaChart2.default(this, Object.assign({
	                invertAxes: this.invertAxes,
	                series: series
	            }, this.stackableChartOptions(firstSeries, pane)));

	            this.appendChart(areaChart, pane);
	        }
	    }, {
	        key: 'createOHLCChart',
	        value: function createOHLCChart(series, pane) {
	            if (series.length === 0) {
	                return;
	            }

	            var firstSeries = series[0];
	            var chart = new _ohlcChart2.default(this, {
	                invertAxes: this.invertAxes,
	                gap: firstSeries.gap,
	                series: series,
	                spacing: firstSeries.spacing,
	                clip: pane.options.clip
	            });

	            this.appendChart(chart, pane);
	        }
	    }, {
	        key: 'createCandlestickChart',
	        value: function createCandlestickChart(series, pane) {
	            if (series.length === 0) {
	                return;
	            }

	            var firstSeries = series[0];
	            var chart = new _candlestickChart2.default(this, {
	                invertAxes: this.invertAxes,
	                gap: firstSeries.gap,
	                series: series,
	                spacing: firstSeries.spacing,
	                clip: pane.options.clip
	            });

	            this.appendChart(chart, pane);
	        }
	    }, {
	        key: 'createBoxPlotChart',
	        value: function createBoxPlotChart(series, pane) {
	            if (series.length === 0) {
	                return;
	            }

	            var firstSeries = series[0];
	            var chart = new _boxPlotChart2.default(this, {
	                invertAxes: this.invertAxes,
	                gap: firstSeries.gap,
	                series: series,
	                spacing: firstSeries.spacing,
	                clip: pane.options.clip
	            });

	            this.appendChart(chart, pane);
	        }
	    }, {
	        key: 'createWaterfallChart',
	        value: function createWaterfallChart(series, pane) {
	            if (series.length === 0) {
	                return;
	            }

	            var firstSeries = series[0];
	            var waterfallChart = new _waterfallChart2.default(this, {
	                series: series,
	                invertAxes: this.invertAxes,
	                gap: firstSeries.gap,
	                spacing: firstSeries.spacing
	            });

	            this.appendChart(waterfallChart, pane);
	        }
	    }, {
	        key: 'axisRequiresRounding',
	        value: function axisRequiresRounding(categoryAxisName, categoryAxisIndex) {
	            var centeredSeries = (0, _filterSeriesByType2.default)(this.series, EQUALLY_SPACED_SERIES);

	            for (var seriesIx = 0; seriesIx < this.series.length; seriesIx++) {
	                var currentSeries = this.series[seriesIx];
	                if (currentSeries.type === _constants.LINE || currentSeries.type === _constants.AREA) {
	                    var line = currentSeries.line;
	                    if (line && line.style === _constants.STEP) {
	                        centeredSeries.push(currentSeries);
	                    }
	                }
	            }

	            for (var _seriesIx = 0; _seriesIx < centeredSeries.length; _seriesIx++) {
	                var seriesAxis = centeredSeries[_seriesIx].categoryAxis || "";
	                if (seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) {
	                    return true;
	                }
	            }
	        }
	    }, {
	        key: 'aggregatedAxis',
	        value: function aggregatedAxis(categoryAxisName, categoryAxisIndex) {
	            var series = this.series;

	            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
	                var seriesAxis = series[seriesIx].categoryAxis || "";
	                if ((seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) && series[seriesIx].categoryField) {
	                    return true;
	                }
	            }
	        }
	    }, {
	        key: 'createCategoryAxesLabels',
	        value: function createCategoryAxesLabels() {
	            var axes = this.axes;
	            for (var i = 0; i < axes.length; i++) {
	                if (axes[i] instanceof _core.CategoryAxis) {
	                    axes[i].createLabels();
	                }
	            }
	        }
	    }, {
	        key: 'createCategoryAxes',
	        value: function createCategoryAxes(panes) {
	            var invertAxes = this.invertAxes;
	            var definitions = [].concat(this.options.categoryAxis);
	            var axes = [];

	            for (var i = 0; i < definitions.length; i++) {
	                var axisOptions = definitions[i];
	                var axisPane = this.findPane(axisOptions.pane);

	                if ((0, _inArray2.default)(axisPane, panes)) {
	                    var _axisOptions = axisOptions;
	                    var name = _axisOptions.name;
	                    var _axisOptions$categori = _axisOptions.categories;
	                    var categories = _axisOptions$categori === undefined ? [] : _axisOptions$categori;

	                    axisOptions = (0, _deepExtend2.default)({
	                        vertical: invertAxes,
	                        axisCrossingValue: invertAxes ? _constants2.MAX_VALUE : 0,
	                        _deferLabels: true
	                    }, axisOptions);

	                    if (!(0, _defined2.default)(axisOptions.justified)) {
	                        axisOptions.justified = this.isJustified();
	                    }

	                    if (this.axisRequiresRounding(name, i)) {
	                        axisOptions.justified = false;
	                    }

	                    var categoryAxis = void 0;

	                    if ((0, _isDateAxis2.default)(axisOptions, categories[0])) {
	                        categoryAxis = new _core.DateCategoryAxis(axisOptions);
	                    } else {
	                        categoryAxis = new _core.CategoryAxis(axisOptions);
	                    }

	                    if (name) {
	                        if (this.namedCategoryAxes[name]) {
	                            throw new Error('Category axis with name ' + name + ' is already defined');
	                        }
	                        this.namedCategoryAxes[name] = categoryAxis;
	                    }

	                    categoryAxis.axisIndex = i;
	                    axes.push(categoryAxis);
	                    this.appendAxis(categoryAxis);
	                }
	            }

	            var primaryAxis = this.categoryAxis || axes[0];
	            this.categoryAxis = primaryAxis;

	            if (invertAxes) {
	                this.axisY = primaryAxis;
	            } else {
	                this.axisX = primaryAxis;
	            }
	        }
	    }, {
	        key: 'isJustified',
	        value: function isJustified() {
	            var series = this.series;

	            for (var i = 0; i < series.length; i++) {
	                var currentSeries = series[i];
	                if (!(0, _inArray2.default)(currentSeries.type, [_constants.AREA, _constants.VERTICAL_AREA])) {
	                    return false;
	                }
	            }

	            return true;
	        }
	    }, {
	        key: 'createValueAxes',
	        value: function createValueAxes(panes) {
	            var tracker = this.valueAxisRangeTracker;
	            var defaultRange = tracker.query();
	            var definitions = [].concat(this.options.valueAxis);
	            var invertAxes = this.invertAxes;
	            var baseOptions = { vertical: !invertAxes };
	            var axes = [];

	            if (this.stack100) {
	                baseOptions.roundToMajorUnit = false;
	                baseOptions.labels = { format: "P0" };
	            }

	            for (var i = 0; i < definitions.length; i++) {
	                var axisOptions = definitions[i];
	                var axisPane = this.findPane(axisOptions.pane);

	                if ((0, _inArray2.default)(axisPane, panes)) {
	                    var name = axisOptions.name;
	                    var defaultAxisRange = (0, _equalsIgnoreCase2.default)(axisOptions.type, _constants.LOGARITHMIC) ? { min: 0.1, max: 1 } : { min: 0, max: 1 };
	                    var range = tracker.query(name) || defaultRange || defaultAxisRange;

	                    if (i === 0 && range && defaultRange) {
	                        range.min = Math.min(range.min, defaultRange.min);
	                        range.max = Math.max(range.max, defaultRange.max);
	                    }

	                    var axisType = void 0;
	                    if ((0, _equalsIgnoreCase2.default)(axisOptions.type, _constants.LOGARITHMIC)) {
	                        axisType = _core.LogarithmicAxis;
	                    } else {
	                        axisType = _core.NumericAxis;
	                    }

	                    var valueAxis = new axisType(range.min, range.max, (0, _deepExtend2.default)({}, baseOptions, axisOptions));

	                    if (name) {
	                        if (this.namedValueAxes[name]) {
	                            throw new Error('Value axis with name ' + name + ' is already defined');
	                        }
	                        this.namedValueAxes[name] = valueAxis;
	                    }
	                    valueAxis.axisIndex = i;

	                    axes.push(valueAxis);
	                    this.appendAxis(valueAxis);
	                }
	            }

	            var primaryAxis = this.valueAxis || axes[0];
	            this.valueAxis = primaryAxis;

	            if (invertAxes) {
	                this.axisX = primaryAxis;
	            } else {
	                this.axisY = primaryAxis;
	            }
	        }
	    }, {
	        key: '_dispatchEvent',
	        value: function _dispatchEvent(chart, e, eventType) {
	            var coords = chart._eventCoordinates(e);
	            var point = new _core.Point(coords.x, coords.y);
	            var pane = this.pointPane(point);
	            var categories = [];
	            var values = [];

	            if (!pane) {
	                return;
	            }

	            var allAxes = pane.axes;
	            for (var i = 0; i < allAxes.length; i++) {
	                var axis = allAxes[i];
	                if (axis.getValue) {
	                    (0, _appendIfNotNull2.default)(values, axis.getValue(point));
	                } else {
	                    (0, _appendIfNotNull2.default)(categories, axis.getCategory(point));
	                }
	            }

	            if (categories.length === 0) {
	                (0, _appendIfNotNull2.default)(categories, this.categoryAxis.getCategory(point));
	            }

	            if (categories.length > 0 && values.length > 0) {
	                chart.trigger(eventType, {
	                    element: e.target,
	                    originalEvent: e,
	                    category: (0, _singleItemOrArray2.default)(categories),
	                    value: (0, _singleItemOrArray2.default)(values)
	                });
	            }
	        }
	    }, {
	        key: 'pointPane',
	        value: function pointPane(point) {
	            var panes = this.panes;

	            for (var i = 0; i < panes.length; i++) {
	                var currentPane = panes[i];
	                if (currentPane.contentBox.containsPoint(point)) {
	                    return currentPane;
	                }
	            }
	        }
	    }, {
	        key: 'updateAxisOptions',
	        value: function updateAxisOptions(axis, options) {
	            var axesOptions = axis instanceof _core.CategoryAxis ? [].concat(this.options.categoryAxis) : [].concat(this.options.valueAxis);
	            (0, _deepExtend2.default)(axesOptions[axis.axisIndex], options);
	        }
	    }]);

	    return CategoricalPlotArea;
	}(_plotareaBase2.default);

	function groupSeries(series, axis, axisIx) {
	    return (0, _grep2.default)(series, function (s) {
	        return axisIx === 0 && !s.categoryAxis || s.categoryAxis === axis;
	    });
	}

	(0, _setDefaultOptions2.default)(CategoricalPlotArea.prototype, {
	    categoryAxis: {
	        categories: []
	    },
	    valueAxis: {}
	});

	(0, _deepExtend2.default)(CategoricalPlotArea.prototype, _plotareaEventsMixin2.default);

	exports.default = CategoricalPlotArea;

/***/ },

/***/ 213:
/***/ function(module, exports) {

	module.exports = require("./plotarea-base");

/***/ },

/***/ 214:
/***/ function(module, exports) {

	module.exports = require("../axis-group-range-tracker");

/***/ },

/***/ 215:
/***/ function(module, exports) {

	module.exports = require("../mixins/plotarea-events-mixin");

/***/ },

/***/ 216:
/***/ function(module, exports) {

	module.exports = require("../aggregates/series-aggregator");

/***/ },

/***/ 217:
/***/ function(module, exports) {

	module.exports = require("../aggregates/default-aggregates");

/***/ },

/***/ 218:
/***/ function(module, exports) {

	module.exports = require("../range-bar-chart/range-bar-chart");

/***/ },

/***/ 219:
/***/ function(module, exports) {

	module.exports = require("../bullet-chart/bullet-chart");

/***/ },

/***/ 220:
/***/ function(module, exports) {

	module.exports = require("../area-chart/area-chart");

/***/ },

/***/ 221:
/***/ function(module, exports) {

	module.exports = require("../ohlc-chart/ohlc-chart");

/***/ },

/***/ 222:
/***/ function(module, exports) {

	module.exports = require("../box-plot-chart/box-plot-chart");

/***/ },

/***/ 223:
/***/ function(module, exports) {

	module.exports = require("../waterfall-chart/waterfall-chart");

/***/ },

/***/ 224:
/***/ function(module, exports) {

	module.exports = require("../utils/filter-series-by-type");

/***/ },

/***/ 225:
/***/ function(module, exports) {

	module.exports = require("../utils/equals-ignore-case");

/***/ },

/***/ 226:
/***/ function(module, exports) {

	module.exports = require("../utils/categories-count");

/***/ },

/***/ 227:
/***/ function(module, exports) {

	module.exports = require("../utils/get-field");

/***/ },

/***/ 228:
/***/ function(module, exports) {

	module.exports = require("../utils/is-date-axis");

/***/ },

/***/ 229:
/***/ function(module, exports) {

	module.exports = require("../utils/append-if-not-null");

/***/ },

/***/ 230:
/***/ function(module, exports) {

	module.exports = require("../utils/single-item-or-array");

/***/ },

/***/ 231:
/***/ function(module, exports) {

	module.exports = require("../utils/get-date-field");

/***/ },

/***/ 232:
/***/ function(module, exports) {

	module.exports = require("../../common/grep");

/***/ }

/******/ });