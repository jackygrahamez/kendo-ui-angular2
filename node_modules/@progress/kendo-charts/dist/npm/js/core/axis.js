module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(456);


/***/ },

/***/ 23:
/***/ function(module, exports) {

	module.exports = require("@progress/kendo-drawing");

/***/ },

/***/ 60:
/***/ function(module, exports) {

	module.exports = require("../common/constants");

/***/ },

/***/ 134:
/***/ function(module, exports) {

	module.exports = require("../common");

/***/ },

/***/ 380:
/***/ function(module, exports) {

	module.exports = require("../intl-service");

/***/ },

/***/ 456:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _kendoDrawing = __webpack_require__(23);

	var _intlService = __webpack_require__(380);

	var _intlService2 = _interopRequireDefault(_intlService);

	var _chartElement = __webpack_require__(457);

	var _chartElement2 = _interopRequireDefault(_chartElement);

	var _textBox = __webpack_require__(458);

	var _textBox2 = _interopRequireDefault(_textBox);

	var _axisLabel = __webpack_require__(459);

	var _axisLabel2 = _interopRequireDefault(_axisLabel);

	var _note = __webpack_require__(460);

	var _note2 = _interopRequireDefault(_note);

	var _box = __webpack_require__(461);

	var _box2 = _interopRequireDefault(_box);

	var _createAxisTick = __webpack_require__(462);

	var _createAxisTick2 = _interopRequireDefault(_createAxisTick);

	var _createAxisGridLine = __webpack_require__(463);

	var _createAxisGridLine2 = _interopRequireDefault(_createAxisGridLine);

	var _constants = __webpack_require__(60);

	var _common = __webpack_require__(134);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var FORMAT_REPLACE_REGEX = /\{(\d+)(:[^\}]+)?\}/g;

	var Axis = function (_ChartElement) {
	    _inherits(Axis, _ChartElement);

	    function Axis(options) {
	        _classCallCheck(this, Axis);

	        var _this = _possibleConstructorReturn(this, (Axis.__proto__ || Object.getPrototypeOf(Axis)).call(this, options));

	        if (!_this.options.visible) {
	            _this.options = (0, _common.deepExtend)({}, _this.options, {
	                labels: {
	                    visible: false
	                },
	                line: {
	                    visible: false
	                },
	                margin: 0,
	                majorTickSize: 0,
	                minorTickSize: 0
	            });
	        }

	        _this.options.minorTicks = (0, _common.deepExtend)({}, {
	            color: _this.options.line.color,
	            width: _this.options.line.width,
	            visible: _this.options.minorTickType !== _constants.NONE
	        }, _this.options.minorTicks, {
	            size: _this.options.minorTickSize,
	            align: _this.options.minorTickType
	        });

	        _this.options.majorTicks = (0, _common.deepExtend)({}, {
	            color: _this.options.line.color,
	            width: _this.options.line.width,
	            visible: _this.options.majorTickType !== _constants.NONE
	        }, _this.options.majorTicks, {
	            size: _this.options.majorTickSize,
	            align: _this.options.majorTickType
	        });

	        if (!_this.options._deferLabels) {
	            _this.createLabels();
	        }

	        _this.createTitle();
	        _this.createNotes();
	        return _this;
	    }

	    // abstract labelsCount(): Number
	    // abstract createAxisLabel(index, options): AxisLabel

	    _createClass(Axis, [{
	        key: 'labelsRange',
	        value: function labelsRange() {
	            return {
	                min: this.options.labels.skip,
	                max: this.labelsCount()
	            };
	        }
	    }, {
	        key: 'createLabels',
	        value: function createLabels() {
	            var options = this.options;
	            var align = options.vertical ? _constants.RIGHT : _constants.CENTER;
	            var labelOptions = (0, _common.deepExtend)({}, options.labels, {
	                align: align,
	                zIndex: options.zIndex
	            });
	            var step = Math.max(1, labelOptions.step);

	            this.children = (0, _common.grep)(this.children, function (child) {
	                return !(child instanceof _axisLabel2.default);
	            });

	            this.labels = [];

	            if (labelOptions.visible) {
	                var range = this.labelsRange();
	                var rotation = labelOptions.rotation;

	                if ((0, _common.isObject)(rotation)) {
	                    labelOptions.alignRotation = rotation.align;
	                    labelOptions.rotation = rotation.angle;
	                }

	                if (labelOptions.rotation === "auto") {
	                    labelOptions.rotation = 0;
	                    options.autoRotateLabels = true;
	                }

	                for (var idx = range.min; idx < range.max; idx += step) {
	                    var label = this.createAxisLabel(idx, labelOptions);
	                    if (label) {
	                        this.append(label);
	                        this.labels.push(label);
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'lineBox',
	        value: function lineBox() {
	            var options = this.options;
	            var box = this.box;

	            var vertical = options.vertical;
	            var mirror = options.labels.mirror;
	            var axisX = mirror ? box.x1 : box.x2;
	            var axisY = mirror ? box.y2 : box.y1;
	            var lineWidth = options.line.width || 0;

	            return vertical ? new _box2.default(axisX, box.y1, axisX, box.y2 - lineWidth) : new _box2.default(box.x1, axisY, box.x2 - lineWidth, axisY);
	        }
	    }, {
	        key: 'createTitle',
	        value: function createTitle() {
	            var options = this.options;
	            var titleOptions = (0, _common.deepExtend)({
	                rotation: options.vertical ? -90 : 0,
	                text: "",
	                zIndex: 1,
	                visualSize: true
	            }, options.title);

	            if (titleOptions.visible && titleOptions.text) {
	                var title = new _textBox2.default(titleOptions.text, titleOptions);
	                this.append(title);
	                this.title = title;
	            }
	        }
	    }, {
	        key: 'createNotes',
	        value: function createNotes() {
	            var options = this.options;
	            var notes = options.notes;
	            var items = notes.data || [];

	            this.notes = [];

	            for (var i = 0; i < items.length; i++) {
	                var item = (0, _common.deepExtend)({}, notes, items[i]);
	                item.value = this.parseNoteValue(item.value);

	                var note = new _note2.default(item.value, item.label.text, item, null, null, item);

	                if (note.options.visible) {
	                    if ((0, _common.defined)(note.options.position)) {
	                        if (options.vertical && !(0, _common.inArray)(note.options.position, [_constants.LEFT, _constants.RIGHT])) {
	                            note.options.position = options.reverse ? _constants.LEFT : _constants.RIGHT;
	                        } else if (!options.vertical && !(0, _common.inArray)(note.options.position, [_constants.TOP, _constants.BOTTOM])) {
	                            note.options.position = options.reverse ? _constants.BOTTOM : _constants.TOP;
	                        }
	                    } else {
	                        if (options.vertical) {
	                            note.options.position = options.reverse ? _constants.LEFT : _constants.RIGHT;
	                        } else {
	                            note.options.position = options.reverse ? _constants.BOTTOM : _constants.TOP;
	                        }
	                    }
	                    this.append(note);
	                    this.notes.push(note);
	                }
	            }
	        }
	    }, {
	        key: 'parseNoteValue',
	        value: function parseNoteValue(value) {
	            return value;
	        }
	    }, {
	        key: 'renderVisual',
	        value: function renderVisual() {
	            _get(Axis.prototype.__proto__ || Object.getPrototypeOf(Axis.prototype), 'renderVisual', this).call(this);

	            this.createPlotBands();
	        }
	    }, {
	        key: 'createVisual',
	        value: function createVisual() {
	            _get(Axis.prototype.__proto__ || Object.getPrototypeOf(Axis.prototype), 'createVisual', this).call(this);

	            this.createBackground();
	            this.createLine();
	        }
	    }, {
	        key: 'gridLinesVisual',
	        value: function gridLinesVisual() {
	            var gridLines = this._gridLines;
	            if (!gridLines) {
	                gridLines = this._gridLines = new _kendoDrawing.drawing.Group({
	                    zIndex: -2
	                });
	                this.appendVisual(this._gridLines);
	            }

	            return gridLines;
	        }
	    }, {
	        key: 'createTicks',
	        value: function createTicks(lineGroup) {
	            var options = this.options;
	            var lineBox = this.lineBox();
	            var mirror = options.labels.mirror;
	            var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;
	            var tickLineOptions = {
	                // TODO
	                // _alignLines: options._alignLines,
	                vertical: options.vertical
	            };

	            function render(tickPositions, tickOptions, skipUnit) {
	                var count = tickPositions.length;
	                var step = Math.max(1, tickOptions.step);

	                if (tickOptions.visible) {
	                    for (var i = tickOptions.skip; i < count; i += step) {
	                        if ((0, _common.defined)(skipUnit) && i % skipUnit === 0) {
	                            continue;
	                        }

	                        tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
	                        tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
	                        tickLineOptions.position = tickPositions[i];

	                        lineGroup.append((0, _createAxisTick2.default)(tickLineOptions, tickOptions));
	                    }
	                }
	            }

	            render(this.getMajorTickPositions(), options.majorTicks);
	            render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);
	        }
	    }, {
	        key: 'createLine',
	        value: function createLine() {
	            var options = this.options;
	            var line = options.line;
	            var lineBox = this.lineBox();

	            if (line.width > 0 && line.visible) {
	                var path = new _kendoDrawing.drawing.Path({
	                    stroke: {
	                        width: line.width,
	                        color: line.color,
	                        dashType: line.dashType
	                    }

	                    /* TODO
	                    zIndex: line.zIndex,
	                    */
	                });

	                path.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);

	                if (options._alignLines) {
	                    (0, _common.alignPathToPixel)(path);
	                }

	                var group = this._lineGroup = new _kendoDrawing.drawing.Group();
	                group.append(path);

	                this.visual.append(group);
	                this.createTicks(group);
	            }
	        }
	    }, {
	        key: 'getActualTickSize',
	        value: function getActualTickSize() {
	            var options = this.options;
	            var tickSize = 0;

	            if (options.majorTicks.visible && options.minorTicks.visible) {
	                tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);
	            } else if (options.majorTicks.visible) {
	                tickSize = options.majorTicks.size;
	            } else if (options.minorTicks.visible) {
	                tickSize = options.minorTicks.size;
	            }

	            return tickSize;
	        }
	    }, {
	        key: 'createBackground',
	        value: function createBackground() {
	            var options = this.options;
	            var box = this.box;

	            var background = options.background;

	            if (background) {
	                this._backgroundPath = _kendoDrawing.drawing.Path.fromRect(box.toRect(), {
	                    fill: {
	                        color: background
	                    },
	                    stroke: null
	                });

	                this.visual.append(this._backgroundPath);
	            }
	        }
	    }, {
	        key: 'createPlotBands',
	        value: function createPlotBands() {
	            var _this2 = this;

	            var options = this.options;
	            var plotBands = options.plotBands || [];
	            var vertical = options.vertical;
	            var plotArea = this.plotArea;

	            if (plotBands.length === 0) {
	                return;
	            }

	            var group = this._plotbandGroup = new _kendoDrawing.drawing.Group({
	                zIndex: -1
	            });

	            var altAxis = (0, _common.grep)(this.pane.axes, function (axis) {
	                return axis.options.vertical !== _this2.options.vertical;
	            })[0];

	            for (var idx = 0; idx < plotBands.length; idx++) {
	                var item = plotBands[idx];
	                var slotX = void 0,
	                    slotY = void 0;

	                if (vertical) {
	                    slotX = (altAxis || plotArea.axisX).lineBox();
	                    slotY = this.getSlot(item.from, item.to, true);
	                } else {
	                    slotX = this.getSlot(item.from, item.to, true);
	                    slotY = (altAxis || plotArea.axisY).lineBox();
	                }

	                if (slotX.width() !== 0 && slotY.height() !== 0) {
	                    var bandRect = new _kendoDrawing.geometry.Rect([slotX.x1, slotY.y1], [slotX.width(), slotY.height()]);

	                    var path = _kendoDrawing.drawing.Path.fromRect(bandRect, {
	                        fill: {
	                            color: item.color,
	                            opacity: item.opacity
	                        },
	                        stroke: null
	                    });

	                    group.append(path);
	                }
	            }

	            this.appendVisual(group);
	        }
	    }, {
	        key: 'createGridLines',
	        value: function createGridLines(altAxis) {
	            var options = this.options;
	            var minorGridLines = options.minorGridLines;
	            var majorGridLines = options.majorGridLines;
	            var minorUnit = options.minorUnit;
	            var vertical = options.vertical;

	            var axisLineVisible = altAxis.options.line.visible;
	            var majorUnit = majorGridLines.visible ? options.majorUnit : 0;
	            var lineBox = altAxis.lineBox();
	            var linePos = lineBox[vertical ? "y1" : "x1"];
	            var lineOptions = {
	                lineStart: lineBox[vertical ? "x1" : "y1"],
	                lineEnd: lineBox[vertical ? "x2" : "y2"],
	                vertical: vertical
	            };
	            var majorTicks = [];

	            var container = this.gridLinesVisual();

	            function render(tickPositions, gridLine, skipUnit) {
	                var count = tickPositions.length;
	                var step = Math.max(1, gridLine.step);

	                if (gridLine.visible) {
	                    for (var i = gridLine.skip; i < count; i += step) {
	                        var pos = (0, _common.round)(tickPositions[i]);
	                        if (!(0, _common.inArray)(pos, majorTicks)) {
	                            if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {
	                                lineOptions.position = pos;
	                                container.append((0, _createAxisGridLine2.default)(lineOptions, gridLine));

	                                majorTicks.push(pos);
	                            }
	                        }
	                    }
	                }
	            }

	            render(this.getMajorTickPositions(), majorGridLines);
	            render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);

	            return container.children;
	        }
	    }, {
	        key: 'reflow',
	        value: function reflow(box) {
	            var options = this.options;
	            var labels = this.labels;
	            var title = this.title;

	            var vertical = options.vertical;
	            var count = labels.length;
	            var sizeFn = vertical ? _constants.WIDTH : _constants.HEIGHT;
	            var titleSize = title ? title.box[sizeFn]() : 0;
	            var space = this.getActualTickSize() + options.margin + titleSize;
	            var rootBox = (this.getRoot() || {}).box || box;
	            var boxSize = rootBox[sizeFn]();
	            var maxLabelSize = 0;

	            for (var i = 0; i < count; i++) {
	                var labelSize = labels[i].box[sizeFn]();
	                if (labelSize + space <= boxSize) {
	                    maxLabelSize = Math.max(maxLabelSize, labelSize);
	                }
	            }

	            if (vertical) {
	                this.box = new _box2.default(box.x1, box.y1, box.x1 + maxLabelSize + space, box.y2);
	            } else {
	                this.box = new _box2.default(box.x1, box.y1, box.x2, box.y1 + maxLabelSize + space);
	            }

	            this.arrangeTitle();
	            this.arrangeLabels();
	            this.arrangeNotes();
	        }
	    }, {
	        key: 'getLabelsTickPositions',
	        value: function getLabelsTickPositions() {
	            return this.getMajorTickPositions();
	        }
	    }, {
	        key: 'labelTickIndex',
	        value: function labelTickIndex(label) {
	            return label.index;
	        }
	    }, {
	        key: 'arrangeLabels',
	        value: function arrangeLabels() {
	            var options = this.options;
	            var labels = this.labels;

	            var labelsBetweenTicks = !options.justified;
	            var vertical = options.vertical;
	            var lineBox = this.lineBox();
	            var mirror = options.labels.mirror;
	            var tickPositions = this.getLabelsTickPositions();
	            var labelOffset = this.getActualTickSize() + options.margin;

	            for (var idx = 0; idx < labels.length; idx++) {
	                var label = labels[idx];
	                var tickIx = this.labelTickIndex(label);
	                var labelSize = vertical ? label.box.height() : label.box.width();
	                var labelPos = tickPositions[tickIx] - labelSize / 2;
	                var labelBox = void 0,
	                    firstTickPosition = void 0,
	                    nextTickPosition = void 0;

	                if (vertical) {
	                    if (labelsBetweenTicks) {
	                        firstTickPosition = tickPositions[tickIx];
	                        nextTickPosition = tickPositions[tickIx + 1];

	                        var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;
	                        labelPos = middle - labelSize / 2;
	                    }

	                    var labelX = lineBox.x2;

	                    if (mirror) {
	                        labelX += labelOffset;
	                        label.options.rotationOrigin = _constants.LEFT;
	                    } else {
	                        labelX -= labelOffset + label.box.width();
	                        label.options.rotationOrigin = _constants.RIGHT;
	                    }

	                    labelBox = label.box.move(labelX, labelPos);
	                } else {
	                    if (labelsBetweenTicks) {
	                        firstTickPosition = tickPositions[tickIx];
	                        nextTickPosition = tickPositions[tickIx + 1];
	                    } else {
	                        firstTickPosition = labelPos;
	                        nextTickPosition = labelPos + labelSize;
	                    }

	                    var labelY = lineBox.y1;

	                    if (mirror) {
	                        labelY -= labelOffset + label.box.height();
	                        label.options.rotationOrigin = _constants.BOTTOM;
	                    } else {
	                        labelY += labelOffset;
	                        label.options.rotationOrigin = _constants.TOP;
	                    }

	                    labelBox = new _box2.default(firstTickPosition, labelY, nextTickPosition, labelY + label.box.height());
	                }

	                label.reflow(labelBox);
	            }
	        }
	    }, {
	        key: 'autoRotateLabels',
	        value: function autoRotateLabels() {
	            if (this.options.autoRotateLabels && !this.options.vertical) {
	                var tickPositions = this.getMajorTickPositions();
	                var labels = this.labels;
	                var angle = void 0;

	                for (var idx = 0; idx < labels.length; idx++) {
	                    var width = tickPositions[idx + 1] - tickPositions[idx];
	                    var labelBox = labels[idx].box;

	                    if (labelBox.width() > width) {
	                        if (labelBox.height() > width) {
	                            angle = -90;
	                            break;
	                        }
	                        angle = -45;
	                    }
	                }

	                if (angle) {
	                    for (var _idx = 0; _idx < labels.length; _idx++) {
	                        labels[_idx].options.rotation = angle;
	                        labels[_idx].reflow(new _box2.default());
	                    }
	                    return true;
	                }
	            }
	        }
	    }, {
	        key: 'arrangeTitle',
	        value: function arrangeTitle() {
	            var options = this.options;
	            var title = this.title;

	            var mirror = options.labels.mirror;
	            var vertical = options.vertical;

	            if (title) {
	                if (vertical) {
	                    title.options.align = mirror ? _constants.RIGHT : _constants.LEFT;
	                    title.options.vAlign = title.options.position;
	                } else {
	                    title.options.align = title.options.position;
	                    title.options.vAlign = mirror ? _constants.TOP : _constants.BOTTOM;
	                }

	                title.reflow(this.box);
	            }
	        }
	    }, {
	        key: 'arrangeNotes',
	        value: function arrangeNotes() {
	            for (var idx = 0; idx < this.notes.length; idx++) {
	                var item = this.notes[idx];
	                var value = item.options.value;
	                var slot = void 0;

	                if ((0, _common.defined)(value)) {
	                    if (this.shouldRenderNote(value)) {
	                        item.show();
	                    } else {
	                        item.hide();
	                    }

	                    slot = this.getSlot(value);
	                } else {
	                    item.hide();
	                }

	                item.reflow(slot || this.lineBox());
	            }
	        }
	    }, {
	        key: 'alignTo',
	        value: function alignTo(secondAxis) {
	            var lineBox = secondAxis.lineBox();
	            var vertical = this.options.vertical;
	            var pos = vertical ? _constants.Y : _constants.X;

	            this.box.snapTo(lineBox, pos);
	            if (vertical) {
	                this.box.shrink(0, this.lineBox().height() - lineBox.height());
	            } else {
	                this.box.shrink(this.lineBox().width() - lineBox.width(), 0);
	            }
	            this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];
	            this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];
	        }
	    }, {
	        key: 'axisLabelText',
	        value: function axisLabelText(value, dataItem, options) {
	            var text = value;

	            if (options.template) {
	                var tmpl = (0, _common.template)(options.template);
	                text = tmpl({ value: value, dataItem: dataItem, format: options.format, culture: options.culture });
	            } else if (options.format) {
	                if (options.format.match(_constants.FORMAT_REGEX)) {
	                    (function () {
	                        var values = [value];
	                        text = options.format.replace(FORMAT_REPLACE_REGEX, function (match, index, placeholderFormat) {
	                            return _intlService2.default.implementation.toString(values[index], placeholderFormat ? placeholderFormat.substring(1) : "", options.culture);
	                        });
	                    })();
	                } else {
	                    text = _intlService2.default.implementation.toString(value, options.format, options.culture);
	                }
	            }

	            return text;
	        }
	    }, {
	        key: 'slot',
	        value: function slot(from, to, limit) {
	            var slot = this.getSlot(from, to, limit);
	            if (slot) {
	                return slot.toRect();
	            }
	        }
	    }, {
	        key: 'contentBox',
	        value: function contentBox() {
	            var box = this.box.clone();
	            var labels = this.labels;
	            if (labels.length) {
	                if (labels[0].options.visible) {
	                    box.wrap(labels[0].box);
	                }
	                var lastLabel = labels[labels.length - 1];
	                if (lastLabel.options.visible) {
	                    box.wrap(lastLabel.box);
	                }
	            }

	            return box;
	        }
	    }, {
	        key: 'limitRange',
	        value: function limitRange(from, to, min, max, offset) {
	            var options = this.options;

	            if (from < min && offset < 0 && (!(0, _common.defined)(options.min) || options.min <= min) || max < to && offset > 0 && (!(0, _common.defined)(options.max) || max <= options.max)) {
	                return null;
	            }

	            if (to < min && offset > 0 || max < from && offset < 0) {
	                return {
	                    min: from,
	                    max: to
	                };
	            }

	            var rangeSize = to - from;
	            var minValue = from;
	            var maxValue = to;

	            if (from < min) {
	                minValue = (0, _common.limitValue)(from, min, max);
	                maxValue = (0, _common.limitValue)(from + rangeSize, min + rangeSize, max);
	            } else if (to > max) {
	                maxValue = (0, _common.limitValue)(to, min, max);
	                minValue = (0, _common.limitValue)(to - rangeSize, min, max - rangeSize);
	            }

	            return {
	                min: minValue,
	                max: maxValue
	            };
	        }
	    }, {
	        key: 'valueRange',
	        value: function valueRange() {
	            return {
	                min: this.seriesMin,
	                max: this.seriesMax
	            };
	        }
	    }]);

	    return Axis;
	}(_chartElement2.default);

	(0, _common.setDefaultOptions)(Axis.prototype, {
	    labels: {
	        visible: true,
	        rotation: 0,
	        mirror: false,
	        step: 1,
	        skip: 0
	    },
	    line: {
	        width: 1,
	        color: _constants.BLACK,
	        visible: true
	    },
	    title: {
	        visible: true,
	        position: _constants.CENTER
	    },
	    majorTicks: {
	        align: _constants.OUTSIDE,
	        size: 4,
	        skip: 0,
	        step: 1
	    },
	    minorTicks: {
	        align: _constants.OUTSIDE,
	        size: 3,
	        skip: 0,
	        step: 1
	    },
	    axisCrossingValue: 0,
	    majorTickType: _constants.OUTSIDE,
	    minorTickType: _constants.NONE,
	    majorGridLines: {
	        skip: 0,
	        step: 1
	    },
	    minorGridLines: {
	        visible: false,
	        width: 1,
	        color: _constants.BLACK,
	        skip: 0,
	        step: 1
	    },
	    // TODO: Move to line or labels options
	    margin: 5,
	    visible: true,
	    reverse: false,
	    justified: true,
	    notes: {
	        label: {
	            text: ""
	        }
	    },

	    _alignLines: true,
	    _deferLabels: false
	});

	exports.default = Axis;

/***/ },

/***/ 457:
/***/ function(module, exports) {

	module.exports = require("./chart-element");

/***/ },

/***/ 458:
/***/ function(module, exports) {

	module.exports = require("./text-box");

/***/ },

/***/ 459:
/***/ function(module, exports) {

	module.exports = require("./axis-label");

/***/ },

/***/ 460:
/***/ function(module, exports) {

	module.exports = require("./note");

/***/ },

/***/ 461:
/***/ function(module, exports) {

	module.exports = require("./box");

/***/ },

/***/ 462:
/***/ function(module, exports) {

	module.exports = require("./utils/create-axis-tick");

/***/ },

/***/ 463:
/***/ function(module, exports) {

	module.exports = require("./utils/create-axis-grid-line");

/***/ }

/******/ });