module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(275);


/***/ },

/***/ 6:
/***/ function(module, exports) {

	module.exports = require("../geometry/point");

/***/ },

/***/ 23:
/***/ function(module, exports) {

	module.exports = require("../geometry/transform");

/***/ },

/***/ 244:
/***/ function(module, exports) {

	module.exports = require("../geometry/rect");

/***/ },

/***/ 275:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _group = __webpack_require__(276);

	var _group2 = _interopRequireDefault(_group);

	var _size = __webpack_require__(277);

	var _size2 = _interopRequireDefault(_size);

	var _rect = __webpack_require__(244);

	var _rect2 = _interopRequireDefault(_rect);

	var _point = __webpack_require__(6);

	var _point2 = _interopRequireDefault(_point);

	var _transform = __webpack_require__(23);

	var _transform2 = _interopRequireDefault(_transform);

	var _translateToPoint = __webpack_require__(278);

	var _translateToPoint2 = _interopRequireDefault(_translateToPoint);

	var _alignStart = __webpack_require__(279);

	var _alignStart2 = _interopRequireDefault(_alignStart);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var DEFAULT_OPTIONS = {
	    alignContent: "start",
	    justifyContent: "start",
	    alignItems: "start",
	    spacing: 0,
	    orientation: "horizontal",
	    lineSpacing: 0,
	    wrap: true
	};

	var Layout = function (_Group) {
	    _inherits(Layout, _Group);

	    function Layout(rect, options) {
	        _classCallCheck(this, Layout);

	        var _this = _possibleConstructorReturn(this, (Layout.__proto__ || Object.getPrototypeOf(Layout)).call(this, Object.assign({}, DEFAULT_OPTIONS, options)));

	        _this._rect = rect;
	        _this._fieldMap = {};
	        return _this;
	    }

	    _createClass(Layout, [{
	        key: 'rect',
	        value: function rect(value) {
	            if (value) {
	                this._rect = value;
	                return this;
	            }

	            return this._rect;
	        }
	    }, {
	        key: '_initMap',
	        value: function _initMap() {
	            var options = this.options;
	            var fieldMap = this._fieldMap;
	            if (options.orientation === "horizontal") {
	                fieldMap.sizeField = "width";
	                fieldMap.groupsSizeField = "height";
	                fieldMap.groupAxis = "x";
	                fieldMap.groupsAxis = "y";
	            } else {
	                fieldMap.sizeField = "height";
	                fieldMap.groupsSizeField = "width";
	                fieldMap.groupAxis = "y";
	                fieldMap.groupsAxis = "x";
	            }
	        }
	    }, {
	        key: 'reflow',
	        value: function reflow() {
	            if (!this._rect || this.children.length === 0) {
	                return;
	            }
	            this._initMap();

	            if (this.options.transform) {
	                this.transform(null);
	            }

	            var options = this.options;
	            var rect = this._rect;

	            var _initGroups2 = this._initGroups();

	            var groups = _initGroups2.groups;
	            var groupsSize = _initGroups2.groupsSize;
	            var _fieldMap = this._fieldMap;
	            var sizeField = _fieldMap.sizeField;
	            var groupsSizeField = _fieldMap.groupsSizeField;
	            var groupAxis = _fieldMap.groupAxis;
	            var groupsAxis = _fieldMap.groupsAxis;

	            var groupOrigin = new _point2.default();
	            var elementOrigin = new _point2.default();
	            var size = new _size2.default();
	            var groupStart = (0, _alignStart2.default)(groupsSize, rect, options.alignContent, groupsAxis, groupsSizeField);
	            var elementStart = void 0,
	                bbox = void 0,
	                element = void 0,
	                group = void 0,
	                groupBox = void 0;

	            for (var groupIdx = 0; groupIdx < groups.length; groupIdx++) {
	                group = groups[groupIdx];
	                groupOrigin[groupAxis] = elementStart = (0, _alignStart2.default)(group.size, rect, options.justifyContent, groupAxis, sizeField);
	                groupOrigin[groupsAxis] = groupStart;
	                size[sizeField] = group.size;
	                size[groupsSizeField] = group.lineSize;
	                groupBox = new _rect2.default(groupOrigin, size);
	                for (var idx = 0; idx < group.bboxes.length; idx++) {
	                    element = group.elements[idx];
	                    bbox = group.bboxes[idx];
	                    elementOrigin[groupAxis] = elementStart;
	                    elementOrigin[groupsAxis] = (0, _alignStart2.default)(bbox.size[groupsSizeField], groupBox, options.alignItems, groupsAxis, groupsSizeField);
	                    (0, _translateToPoint2.default)(elementOrigin, bbox, element);
	                    elementStart += bbox.size[sizeField] + options.spacing;
	                }
	                groupStart += group.lineSize + options.lineSpacing;
	            }

	            if (!options.wrap && group.size > rect.size[sizeField]) {
	                var scale = rect.size[sizeField] / groupBox.size[sizeField];
	                var scaledStart = groupBox.topLeft().scale(scale, scale);
	                var scaledSize = groupBox.size[groupsSizeField] * scale;
	                var newStart = (0, _alignStart2.default)(scaledSize, rect, options.alignContent, groupsAxis, groupsSizeField);
	                var transform = (0, _transform2.default)();
	                if (groupAxis === "x") {
	                    transform.translate(rect.origin.x - scaledStart.x, newStart - scaledStart.y);
	                } else {
	                    transform.translate(newStart - scaledStart.x, rect.origin.y - scaledStart.y);
	                }
	                transform.scale(scale, scale);

	                this.transform(transform);
	            }
	        }
	    }, {
	        key: '_initGroups',
	        value: function _initGroups() {
	            var options = this.options;
	            var children = this.children;
	            var lineSpacing = options.lineSpacing;
	            var wrap = options.wrap;
	            var spacing = options.spacing;

	            var sizeField = this._fieldMap.sizeField;
	            var group = this._newGroup();
	            var groups = [];
	            var addGroup = function addGroup() {
	                groups.push(group);
	                groupsSize += group.lineSize + lineSpacing;
	            };
	            var groupsSize = -lineSpacing;

	            for (var idx = 0; idx < children.length; idx++) {
	                var element = children[idx];
	                var bbox = children[idx].clippedBBox();
	                if (element.visible() && bbox) {
	                    if (wrap && group.size + bbox.size[sizeField] + spacing > this._rect.size[sizeField]) {
	                        if (group.bboxes.length === 0) {
	                            this._addToGroup(group, bbox, element);
	                            addGroup();
	                            group = this._newGroup();
	                        } else {
	                            addGroup();
	                            group = this._newGroup();
	                            this._addToGroup(group, bbox, element);
	                        }
	                    } else {
	                        this._addToGroup(group, bbox, element);
	                    }
	                }
	            }

	            if (group.bboxes.length) {
	                addGroup();
	            }

	            return {
	                groups: groups,
	                groupsSize: groupsSize
	            };
	        }
	    }, {
	        key: '_addToGroup',
	        value: function _addToGroup(group, bbox, element) {
	            group.size += bbox.size[this._fieldMap.sizeField] + this.options.spacing;
	            group.lineSize = Math.max(bbox.size[this._fieldMap.groupsSizeField], group.lineSize);
	            group.bboxes.push(bbox);
	            group.elements.push(element);
	        }
	    }, {
	        key: '_newGroup',
	        value: function _newGroup() {
	            return {
	                lineSize: 0,
	                size: -this.options.spacing,
	                bboxes: [],
	                elements: []
	            };
	        }
	    }]);

	    return Layout;
	}(_group2.default);

	exports.default = Layout;

/***/ },

/***/ 276:
/***/ function(module, exports) {

	module.exports = require("./group");

/***/ },

/***/ 277:
/***/ function(module, exports) {

	module.exports = require("../geometry/size");

/***/ },

/***/ 278:
/***/ function(module, exports) {

	module.exports = require("../alignment/translate-to-point");

/***/ },

/***/ 279:
/***/ function(module, exports) {

	module.exports = require("../alignment/align-start");

/***/ }

/******/ });