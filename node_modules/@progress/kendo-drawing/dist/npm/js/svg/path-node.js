module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(336);


/***/ },

/***/ 3:
/***/ function(module, exports) {

	module.exports = require("../common/defined");

/***/ },

/***/ 59:
/***/ function(module, exports) {

	module.exports = require("./node-map");

/***/ },

/***/ 67:
/***/ function(module, exports) {

	module.exports = require("./node");

/***/ },

/***/ 76:
/***/ function(module, exports) {

	module.exports = require("../common/is-transparent");

/***/ },

/***/ 80:
/***/ function(module, exports) {

	module.exports = require("../core/constants");

/***/ },

/***/ 159:
/***/ function(module, exports) {

	module.exports = require("./constants");

/***/ },

/***/ 322:
/***/ function(module, exports) {

	module.exports = require("./utils/render-all-attributes");

/***/ },

/***/ 324:
/***/ function(module, exports) {

	module.exports = require("./utils/render-attribute");

/***/ },

/***/ 336:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _node = __webpack_require__(67);

	var _node2 = _interopRequireDefault(_node);

	var _defined = __webpack_require__(3);

	var _defined2 = _interopRequireDefault(_defined);

	var _constants = __webpack_require__(80);

	var _constants2 = __webpack_require__(159);

	var _isTransparent = __webpack_require__(76);

	var _isTransparent2 = _interopRequireDefault(_isTransparent);

	var _renderAllAttributes = __webpack_require__(322);

	var _renderAllAttributes2 = _interopRequireDefault(_renderAllAttributes);

	var _renderAttribute = __webpack_require__(324);

	var _renderAttribute2 = _interopRequireDefault(_renderAttribute);

	var _nodeMap = __webpack_require__(59);

	var _nodeMap2 = _interopRequireDefault(_nodeMap);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ATTRIBUTE_MAP = {
	    "fill.opacity": "fill-opacity",
	    "stroke.color": "stroke",
	    "stroke.width": "stroke-width",
	    "stroke.opacity": "stroke-opacity"
	};
	var SPACE = " ";

	var PathNode = function (_Node) {
	    _inherits(PathNode, _Node);

	    function PathNode() {
	        _classCallCheck(this, PathNode);

	        return _possibleConstructorReturn(this, (PathNode.__proto__ || Object.getPrototypeOf(PathNode)).apply(this, arguments));
	    }

	    _createClass(PathNode, [{
	        key: 'geometryChange',
	        value: function geometryChange() {
	            this.attr("d", this.renderData());
	            this.invalidate();
	        }
	    }, {
	        key: 'optionsChange',
	        value: function optionsChange(e) {
	            switch (e.field) {
	                case "fill":
	                    if (e.value) {
	                        this.allAttr(this.mapFill(e.value));
	                    } else {
	                        this.removeAttr("fill");
	                    }
	                    break;

	                case "fill.color":
	                    this.allAttr(this.mapFill({ color: e.value }));
	                    break;

	                case "stroke":
	                    if (e.value) {
	                        this.allAttr(this.mapStroke(e.value));
	                    } else {
	                        this.removeAttr("stroke");
	                    }
	                    break;

	                case "transform":
	                    this.transformChange(e.value);
	                    break;

	                default:
	                    var name = ATTRIBUTE_MAP[e.field];
	                    if (name) {
	                        this.attr(name, e.value);
	                    }
	                    break;
	            }

	            _get(PathNode.prototype.__proto__ || Object.getPrototypeOf(PathNode.prototype), 'optionsChange', this).call(this, e);
	        }
	    }, {
	        key: 'content',
	        value: function content() {
	            if (this.element) {
	                this.element.textContent = this.srcElement.content();
	            }
	        }
	    }, {
	        key: 'renderData',
	        value: function renderData() {
	            return this.printPath(this.srcElement);
	        }
	    }, {
	        key: 'printPath',
	        value: function printPath(path) {
	            var segments = path.segments;
	            var length = segments.length;
	            if (length > 0) {
	                var parts = [];
	                var output = void 0,
	                    currentType = void 0;

	                for (var i = 1; i < length; i++) {
	                    var segmentType = this.segmentType(segments[i - 1], segments[i]);
	                    if (segmentType !== currentType) {
	                        currentType = segmentType;
	                        parts.push(segmentType);
	                    }

	                    if (segmentType === "L") {
	                        parts.push(this.printPoints(segments[i].anchor()));
	                    } else {
	                        parts.push(this.printPoints(segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()));
	                    }
	                }

	                output = "M" + this.printPoints(segments[0].anchor()) + SPACE + parts.join(SPACE);
	                if (path.options.closed) {
	                    output += "Z";
	                }

	                return output;
	            }
	        }
	    }, {
	        key: 'printPoints',
	        value: function printPoints() {
	            var points = arguments;
	            var length = points.length;
	            var result = [];

	            for (var i = 0; i < length; i++) {
	                result.push(points[i].toString(3));
	            }

	            return result.join(" ");
	        }
	    }, {
	        key: 'segmentType',
	        value: function segmentType(segmentStart, segmentEnd) {
	            return segmentStart.controlOut() && segmentEnd.controlIn() ? "C" : "L";
	        }
	    }, {
	        key: 'mapStroke',
	        value: function mapStroke(stroke) {
	            var attrs = [];

	            if (stroke && !(0, _isTransparent2.default)(stroke.color)) {
	                attrs.push(["stroke", stroke.color]);
	                attrs.push(["stroke-width", stroke.width]);
	                attrs.push(["stroke-linecap", this.renderLinecap(stroke)]);
	                attrs.push(["stroke-linejoin", stroke.lineJoin]);

	                if ((0, _defined2.default)(stroke.opacity)) {
	                    attrs.push(["stroke-opacity", stroke.opacity]);
	                }

	                if ((0, _defined2.default)(stroke.dashType)) {
	                    attrs.push(["stroke-dasharray", this.renderDashType(stroke)]);
	                }
	            } else {
	                attrs.push(["stroke", _constants2.NONE]);
	            }

	            return attrs;
	        }
	    }, {
	        key: 'renderStroke',
	        value: function renderStroke() {
	            return (0, _renderAllAttributes2.default)(this.mapStroke(this.srcElement.options.stroke));
	        }
	    }, {
	        key: 'renderDashType',
	        value: function renderDashType(stroke) {
	            var dashType = stroke.dashType;
	            var _stroke$width = stroke.width;
	            var width = _stroke$width === undefined ? 1 : _stroke$width;


	            if (dashType && dashType !== _constants.SOLID) {
	                var dashArray = _constants.DASH_ARRAYS[dashType.toLowerCase()];
	                var result = [];

	                for (var i = 0; i < dashArray.length; i++) {
	                    result.push(dashArray[i] * width);
	                }

	                return result.join(" ");
	            }
	        }
	    }, {
	        key: 'renderLinecap',
	        value: function renderLinecap(stroke) {
	            var dashType = stroke.dashType;
	            var lineCap = stroke.lineCap;


	            return dashType && dashType !== "solid" ? _constants.BUTT : lineCap;
	        }
	    }, {
	        key: 'mapFill',
	        value: function mapFill(fill) {
	            var attrs = [];
	            if (!(fill && fill.nodeType === "Gradient")) {
	                if (fill && !(0, _isTransparent2.default)(fill.color)) {
	                    attrs.push(["fill", fill.color]);

	                    if ((0, _defined2.default)(fill.opacity)) {
	                        attrs.push(["fill-opacity", fill.opacity]);
	                    }
	                } else {
	                    attrs.push(["fill", _constants2.NONE]);
	                }
	            }

	            return attrs;
	        }
	    }, {
	        key: 'renderFill',
	        value: function renderFill() {
	            return (0, _renderAllAttributes2.default)(this.mapFill(this.srcElement.options.fill));
	        }
	    }, {
	        key: 'template',
	        value: function template() {
	            return '<path ' + this.renderStyle() + ' ' + this.renderOpacity() + '\n                    ' + (0, _renderAttribute2.default)('d', this.renderData()) + '\n                    ' + this.renderStroke() + '\n                    ' + this.renderFill() + '\n                    ' + this.renderDefinitions() + '\n                    ' + this.renderTransform() + '></path>';
	        }
	    }]);

	    return PathNode;
	}(_node2.default);

	_nodeMap2.default.Path = PathNode;

	exports.default = PathNode;

/***/ }

/******/ });