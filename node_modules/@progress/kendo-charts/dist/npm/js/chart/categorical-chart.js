module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(103);


/***/ },

/***/ 60:
/***/ function(module, exports) {

	module.exports = require("../common/constants");

/***/ },

/***/ 103:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _errorRangeCalculator = __webpack_require__(104);

	var _errorRangeCalculator2 = _interopRequireDefault(_errorRangeCalculator);

	var _categoricalErrorBar = __webpack_require__(105);

	var _categoricalErrorBar2 = _interopRequireDefault(_categoricalErrorBar);

	var _seriesBinder = __webpack_require__(106);

	var _seriesBinder2 = _interopRequireDefault(_seriesBinder);

	var _constants = __webpack_require__(107);

	var _evalOptions = __webpack_require__(108);

	var _evalOptions2 = _interopRequireDefault(_evalOptions);

	var _categoriesCount = __webpack_require__(109);

	var _categoriesCount2 = _interopRequireDefault(_categoriesCount);

	var _core = __webpack_require__(110);

	var _constants2 = __webpack_require__(60);

	var _setDefaultOptions = __webpack_require__(111);

	var _setDefaultOptions2 = _interopRequireDefault(_setDefaultOptions);

	var _deepExtend = __webpack_require__(112);

	var _deepExtend2 = _interopRequireDefault(_deepExtend);

	var _defined = __webpack_require__(113);

	var _defined2 = _interopRequireDefault(_defined);

	var _isNumber = __webpack_require__(114);

	var _isNumber2 = _interopRequireDefault(_isNumber);

	var _sparseArrayLimits = __webpack_require__(115);

	var _sparseArrayLimits2 = _interopRequireDefault(_sparseArrayLimits);

	var _autoFormat = __webpack_require__(116);

	var _autoFormat2 = _interopRequireDefault(_autoFormat);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CategoricalChart = function (_ChartElement) {
	    _inherits(CategoricalChart, _ChartElement);

	    function CategoricalChart(plotArea, options) {
	        _classCallCheck(this, CategoricalChart);

	        var _this = _possibleConstructorReturn(this, (CategoricalChart.__proto__ || Object.getPrototypeOf(CategoricalChart)).call(this, options));

	        _this.plotArea = plotArea;
	        _this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]);

	        // Value axis ranges grouped by axis name, e.g.:
	        // primary: { min: 0, max: 1 }
	        _this.valueAxisRanges = {};

	        _this.points = [];
	        _this.categoryPoints = [];
	        _this.seriesPoints = [];
	        _this.seriesOptions = [];
	        _this._evalSeries = [];

	        _this.render();
	        return _this;
	    }

	    _createClass(CategoricalChart, [{
	        key: 'render',
	        value: function render() {
	            this.traverseDataPoints(this.addValue.bind(this));
	        }
	    }, {
	        key: 'pointOptions',
	        value: function pointOptions(series, seriesIx) {
	            var options = this.seriesOptions[seriesIx];
	            if (!options) {
	                var defaults = this.pointType().prototype.defaults;
	                this.seriesOptions[seriesIx] = options = (0, _deepExtend2.default)({}, defaults, {
	                    vertical: !this.options.invertAxes
	                }, series);
	            }

	            return options;
	        }
	    }, {
	        key: 'plotValue',
	        value: function plotValue(point) {
	            if (!point) {
	                return 0;
	            }

	            if (this.options.isStacked100 && (0, _isNumber2.default)(point.value)) {
	                var categoryIx = point.categoryIx;
	                var categoryPoints = this.categoryPoints[categoryIx];
	                var otherValues = [];
	                var categorySum = 0;

	                for (var i = 0; i < categoryPoints.length; i++) {
	                    var other = categoryPoints[i];
	                    if (other) {
	                        var stack = point.series.stack;
	                        var otherStack = other.series.stack;

	                        if (stack && otherStack && stack.group !== otherStack.group) {
	                            continue;
	                        }

	                        if ((0, _isNumber2.default)(other.value)) {
	                            categorySum += Math.abs(other.value);
	                            otherValues.push(Math.abs(other.value));
	                        }
	                    }
	                }

	                if (categorySum > 0) {
	                    return point.value / categorySum;
	                }
	            }

	            return point.value;
	        }
	    }, {
	        key: 'plotRange',
	        value: function plotRange(point) {
	            var startValue = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	            var categoryPoints = this.categoryPoints[point.categoryIx];

	            if (this.options.isStacked) {
	                var plotValue = this.plotValue(point);
	                var positive = plotValue >= 0;
	                var prevValue = startValue;
	                var isStackedBar = false;

	                for (var i = 0; i < categoryPoints.length; i++) {
	                    var other = categoryPoints[i];

	                    if (point === other) {
	                        break;
	                    }

	                    var stack = point.series.stack;
	                    var otherStack = other.series.stack;
	                    if (stack && otherStack) {
	                        if ((typeof stack === 'undefined' ? 'undefined' : _typeof(stack)) === _constants2.STRING && stack !== otherStack) {
	                            continue;
	                        }

	                        if (stack.group && stack.group !== otherStack.group) {
	                            continue;
	                        }
	                    }

	                    var otherValue = this.plotValue(other);
	                    if (otherValue >= 0 && positive || otherValue < 0 && !positive) {
	                        prevValue += otherValue;
	                        plotValue += otherValue;
	                        isStackedBar = true;

	                        if (this.options.isStacked100) {
	                            plotValue = Math.min(plotValue, 1);
	                        }
	                    }
	                }

	                if (isStackedBar) {
	                    prevValue -= startValue;
	                }

	                return [prevValue, plotValue];
	            }

	            var series = point.series;
	            var valueAxis = this.seriesValueAxis(series);
	            var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);

	            return [axisCrossingValue, point.value || axisCrossingValue];
	        }
	    }, {
	        key: 'stackLimits',
	        value: function stackLimits(axisName, stackName) {
	            var min = _constants2.MAX_VALUE;
	            var max = _constants2.MIN_VALUE;

	            for (var i = 0; i < this.categoryPoints.length; i++) {
	                var categoryPoints = this.categoryPoints[i];
	                if (!categoryPoints) {
	                    continue;
	                }

	                for (var pIx = 0; pIx < categoryPoints.length; pIx++) {
	                    var point = categoryPoints[pIx];
	                    if (point) {
	                        if (point.series.stack === stackName || point.series.axis === axisName) {
	                            var to = this.plotRange(point, 0)[1];
	                            if ((0, _defined2.default)(to) && isFinite(to)) {
	                                max = Math.max(max, to);
	                                min = Math.min(min, to);
	                            }
	                        }
	                    }
	                }
	            }

	            return { min: min, max: max };
	        }
	    }, {
	        key: 'updateStackRange',
	        value: function updateStackRange() {
	            var _options = this.options;
	            var isStacked = _options.isStacked;
	            var chartSeries = _options.series;

	            var limitsCache = {};

	            if (isStacked) {
	                for (var i = 0; i < chartSeries.length; i++) {
	                    var series = chartSeries[i];
	                    var axisName = series.axis;
	                    var key = axisName + series.stack;

	                    var limits = limitsCache[key];
	                    if (!limits) {
	                        limits = this.stackLimits(axisName, series.stack);

	                        var errorTotals = this.errorTotals;
	                        if (errorTotals) {
	                            if (errorTotals.negative.length) {
	                                limits.min = Math.min(limits.min, (0, _sparseArrayLimits2.default)(errorTotals.negative).min);
	                            }
	                            if (errorTotals.positive.length) {
	                                limits.max = Math.max(limits.max, (0, _sparseArrayLimits2.default)(errorTotals.positive).max);
	                            }
	                        }

	                        if (limits.min !== _constants2.MAX_VALUE || limits.max !== _constants2.MIN_VALUE) {
	                            limitsCache[key] = limits;
	                        } else {
	                            limits = null;
	                        }
	                    }

	                    if (limits) {
	                        this.valueAxisRanges[axisName] = limits;
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'addErrorBar',
	        value: function addErrorBar(point, data, categoryIx) {
	            var value = point.value;
	            var series = point.series;
	            var seriesIx = point.seriesIx;

	            var errorBars = point.options.errorBars;
	            var lowValue = data.fields[_constants.ERROR_LOW_FIELD];
	            var highValue = data.fields[_constants.ERROR_HIGH_FIELD];
	            var errorRange = void 0;

	            if ((0, _isNumber2.default)(lowValue) && (0, _isNumber2.default)(highValue)) {
	                errorRange = { low: lowValue, high: highValue };
	            } else if (errorBars && (0, _defined2.default)(errorBars.value)) {
	                this.seriesErrorRanges = this.seriesErrorRanges || [];
	                this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] || new _errorRangeCalculator2.default(errorBars.value, series, _constants2.VALUE);

	                errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value, errorBars.value);
	            }

	            if (errorRange) {
	                point.low = errorRange.low;
	                point.high = errorRange.high;
	                this.addPointErrorBar(point, categoryIx);
	            }
	        }
	    }, {
	        key: 'addPointErrorBar',
	        value: function addPointErrorBar(point, categoryIx) {
	            var isVertical = !this.options.invertAxes;
	            var options = point.options.errorBars;
	            var series = point.series;
	            var low = point.low;
	            var high = point.high;


	            if (this.options.isStacked) {
	                var stackedErrorRange = this.stackedErrorRange(point, categoryIx);
	                low = stackedErrorRange.low;
	                high = stackedErrorRange.high;
	            } else {
	                var fields = { categoryIx: categoryIx, series: series };
	                this.updateRange({ value: low }, fields);
	                this.updateRange({ value: high }, fields);
	            }

	            var errorBar = new _categoricalErrorBar2.default(low, high, isVertical, this, series, options);
	            point.errorBars = [errorBar];
	            point.append(errorBar);
	        }
	    }, {
	        key: 'stackedErrorRange',
	        value: function stackedErrorRange(point, categoryIx) {
	            var plotValue = this.plotRange(point, 0)[1] - point.value;
	            var low = point.low + plotValue;
	            var high = point.high + plotValue;

	            this.errorTotals = this.errorTotals || { positive: [], negative: [] };

	            if (low < 0) {
	                this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);
	            }

	            if (high > 0) {
	                this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);
	            }

	            return { low: low, high: high };
	        }
	    }, {
	        key: 'addValue',
	        value: function addValue(data, fields) {
	            var categoryIx = fields.categoryIx;
	            var series = fields.series;
	            var seriesIx = fields.seriesIx;


	            var categoryPoints = this.categoryPoints[categoryIx];
	            if (!categoryPoints) {
	                this.categoryPoints[categoryIx] = categoryPoints = [];
	            }

	            var seriesPoints = this.seriesPoints[seriesIx];
	            if (!seriesPoints) {
	                this.seriesPoints[seriesIx] = seriesPoints = [];
	            }

	            var point = this.createPoint(data, fields);
	            if (point) {
	                Object.assign(point, fields);

	                point.owner = this;
	                point.dataItem = series.data[categoryIx];
	                point.noteText = data.fields.noteText;
	                this.addErrorBar(point, data, categoryIx);
	            }

	            this.points.push(point);
	            seriesPoints.push(point);
	            categoryPoints.push(point);

	            this.updateRange(data.valueFields, fields);
	        }
	    }, {
	        key: 'evalPointOptions',
	        value: function evalPointOptions(options, value, category, categoryIx, series, seriesIx) {
	            var state = { defaults: series._defaults, excluded: ["data", "aggregate", "_events", "tooltip", "template", "visual", "toggle", "_outOfRangeMinPoint", "_outOfRangeMaxPoint"] };

	            var doEval = this._evalSeries[seriesIx];
	            if (!(0, _defined2.default)(doEval)) {
	                this._evalSeries[seriesIx] = doEval = (0, _evalOptions2.default)(options, {}, state, true);
	            }

	            var pointOptions = options;
	            if (doEval) {
	                pointOptions = (0, _deepExtend2.default)({}, pointOptions);
	                (0, _evalOptions2.default)(pointOptions, {
	                    value: value,
	                    category: category,
	                    index: categoryIx,
	                    series: series,
	                    dataItem: series.data[categoryIx]
	                }, state);
	            }

	            return pointOptions;
	        }
	    }, {
	        key: 'updateRange',
	        value: function updateRange(data, fields) {
	            var axisName = fields.series.axis;
	            var value = data.value;
	            var axisRange = this.valueAxisRanges[axisName];

	            if (isFinite(value) && value !== null) {
	                axisRange = this.valueAxisRanges[axisName] = axisRange || { min: _constants2.MAX_VALUE, max: _constants2.MIN_VALUE };

	                axisRange.min = Math.min(axisRange.min, value);
	                axisRange.max = Math.max(axisRange.max, value);
	            }
	        }
	    }, {
	        key: 'seriesValueAxis',
	        value: function seriesValueAxis(series) {
	            var plotArea = this.plotArea;
	            var axisName = series.axis;
	            var axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;

	            if (!axis) {
	                throw new Error("Unable to locate value axis with name " + axisName);
	            }

	            return axis;
	        }
	    }, {
	        key: 'reflow',
	        value: function reflow(targetBox) {
	            var _this2 = this;

	            var categorySlots = this.categorySlots = [];
	            var chartPoints = this.points;
	            var categoryAxis = this.categoryAxis;
	            var pointIx = 0;

	            this.traverseDataPoints(function (data, fields) {
	                var categoryIx = fields.categoryIx;
	                var currentSeries = fields.series;


	                var valueAxis = _this2.seriesValueAxis(currentSeries);
	                var point = chartPoints[pointIx++];

	                var categorySlot = categorySlots[categoryIx];
	                if (!categorySlot) {
	                    categorySlots[categoryIx] = categorySlot = _this2.categorySlot(categoryAxis, categoryIx, valueAxis);
	                }

	                if (point) {
	                    var plotRange = _this2.plotRange(point, valueAxis.startValue());
	                    var valueSlot = valueAxis.getSlot(plotRange[0], plotRange[1], !_this2.options.clip);
	                    if (valueSlot) {
	                        var pointSlot = _this2.pointSlot(categorySlot, valueSlot);

	                        point.aboveAxis = _this2.aboveAxis(point, valueAxis);
	                        point.stackValue = plotRange[1];

	                        if (_this2.options.isStacked100) {
	                            point.percentage = _this2.plotValue(point);
	                        }

	                        _this2.reflowPoint(point, pointSlot);
	                    } else {
	                        point.visible = false;
	                    }
	                }
	            });

	            this.reflowCategories(categorySlots);

	            this.box = targetBox;
	        }
	    }, {
	        key: 'aboveAxis',
	        value: function aboveAxis(point, valueAxis) {
	            var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
	            var value = point.value;

	            return valueAxis.options.reverse ? value < axisCrossingValue : value >= axisCrossingValue;
	        }
	    }, {
	        key: 'categoryAxisCrossingValue',
	        value: function categoryAxisCrossingValue(valueAxis) {
	            var categoryAxis = this.categoryAxis;
	            var options = valueAxis.options;
	            var crossingValues = [].concat(options.axisCrossingValues || options.axisCrossingValue);

	            return crossingValues[categoryAxis.axisIndex || 0] || 0;
	        }
	    }, {
	        key: 'reflowPoint',
	        value: function reflowPoint(point, pointSlot) {
	            point.reflow(pointSlot);
	        }
	    }, {
	        key: 'reflowCategories',
	        value: function reflowCategories() {}
	    }, {
	        key: 'pointSlot',
	        value: function pointSlot(categorySlot, valueSlot) {
	            var options = this.options;
	            var invertAxes = options.invertAxes;
	            var slotX = invertAxes ? valueSlot : categorySlot;
	            var slotY = invertAxes ? categorySlot : valueSlot;

	            return new _core.Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
	        }
	    }, {
	        key: 'categorySlot',
	        value: function categorySlot(categoryAxis, categoryIx) {
	            return categoryAxis.getSlot(categoryIx);
	        }
	    }, {
	        key: 'traverseDataPoints',
	        value: function traverseDataPoints(callback) {
	            var series = this.options.series;
	            var categories = this.categoryAxis.options.categories || [];
	            var count = (0, _categoriesCount2.default)(series);
	            var seriesCount = series.length;

	            for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
	                this._outOfRangeCallback(series[seriesIx], "_outOfRangeMinPoint", seriesIx, callback);
	            }

	            for (var categoryIx = 0; categoryIx < count; categoryIx++) {
	                for (var _seriesIx = 0; _seriesIx < seriesCount; _seriesIx++) {
	                    var currentSeries = series[_seriesIx];
	                    var currentCategory = categories[categoryIx];
	                    var pointData = this._bindPoint(currentSeries, _seriesIx, categoryIx);

	                    callback(pointData, {
	                        category: currentCategory,
	                        categoryIx: categoryIx,
	                        series: currentSeries,
	                        seriesIx: _seriesIx
	                    });
	                }
	            }

	            for (var _seriesIx2 = 0; _seriesIx2 < seriesCount; _seriesIx2++) {
	                this._outOfRangeCallback(series[_seriesIx2], "_outOfRangeMaxPoint", _seriesIx2, callback);
	            }
	        }
	    }, {
	        key: '_outOfRangeCallback',
	        value: function _outOfRangeCallback(series, field, seriesIx, callback) {
	            var outOfRangePoint = series[field];
	            if (outOfRangePoint) {
	                var categoryIx = outOfRangePoint.categoryIx;
	                var pointData = this._bindPoint(series, seriesIx, categoryIx, outOfRangePoint.item);

	                callback(pointData, {
	                    category: outOfRangePoint.category,
	                    categoryIx: categoryIx,
	                    series: series,
	                    seriesIx: seriesIx
	                });
	            }
	        }
	    }, {
	        key: '_bindPoint',
	        value: function _bindPoint(series, seriesIx, categoryIx, item) {
	            if (!this._bindCache) {
	                this._bindCache = [];
	            }

	            var bindCache = this._bindCache[seriesIx];
	            if (!bindCache) {
	                bindCache = this._bindCache[seriesIx] = [];
	            }

	            var data = bindCache[categoryIx];
	            if (!data) {
	                data = bindCache[categoryIx] = _seriesBinder2.default.current.bindPoint(series, categoryIx, item);
	            }

	            return data;
	        }
	    }, {
	        key: 'formatPointValue',
	        value: function formatPointValue(point, format) {
	            if (point.value === null) {
	                return "";
	            }

	            return (0, _autoFormat2.default)(format, point.value);
	        }
	    }, {
	        key: 'pointValue',
	        value: function pointValue(data) {
	            return data.valueFields.value;
	        }
	    }]);

	    return CategoricalChart;
	}(_core.ChartElement);

	(0, _setDefaultOptions2.default)(CategoricalChart.prototype, {
	    series: [],
	    invertAxes: false,
	    isStacked: false,
	    clip: true
	});

	exports.default = CategoricalChart;

/***/ },

/***/ 104:
/***/ function(module, exports) {

	module.exports = require("./error-bars/error-range-calculator");

/***/ },

/***/ 105:
/***/ function(module, exports) {

	module.exports = require("./error-bars/categorical-error-bar");

/***/ },

/***/ 106:
/***/ function(module, exports) {

	module.exports = require("./series-binder");

/***/ },

/***/ 107:
/***/ function(module, exports) {

	module.exports = require("./constants");

/***/ },

/***/ 108:
/***/ function(module, exports) {

	module.exports = require("./utils/eval-options");

/***/ },

/***/ 109:
/***/ function(module, exports) {

	module.exports = require("./utils/categories-count");

/***/ },

/***/ 110:
/***/ function(module, exports) {

	module.exports = require("../core");

/***/ },

/***/ 111:
/***/ function(module, exports) {

	module.exports = require("../common/set-default-options");

/***/ },

/***/ 112:
/***/ function(module, exports) {

	module.exports = require("../common/deep-extend");

/***/ },

/***/ 113:
/***/ function(module, exports) {

	module.exports = require("../common/defined");

/***/ },

/***/ 114:
/***/ function(module, exports) {

	module.exports = require("../common/is-number");

/***/ },

/***/ 115:
/***/ function(module, exports) {

	module.exports = require("../common/sparse-array-limits");

/***/ },

/***/ 116:
/***/ function(module, exports) {

	module.exports = require("../common/auto-format");

/***/ }

/******/ });