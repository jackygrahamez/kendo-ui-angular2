import { drawing as draw } from '@progress/kendo-drawing';

import { RootElement, Box } from '../../src/core';
import categoriesCount from '../../src/chart/utils/categories-count';
import CategoricalPlotArea from '../../src/chart/plotarea/categorical-plotarea';
import LineSegment from '../../src/chart/line-chart/line-segment';
import ClipAnimation from '../../src/chart/animations/clip-animation';

import { deepExtend, grep, map } from '../../src/common';

import { ok, equal, close, createSpy, mapSegments, sameBox, sameLinePath } from '../../test/test-helpers';
import { createChart, destroyChart }  from '../test-helpers';

export default function baseLineChartTests(seriesName, TChart) {
    const chartBox = new Box(0, 0, 800, 600);
    const TOLERANCE = 1;
    let chart, root, pointCoordinates;

    const chartName = seriesName.substring(0, 1).toUpperCase() + seriesName.substring(1, seriesName.length);

    function pathSegments(chart) {
        const visual = chart._segments[0].visual;
        return (visual.children ? visual.children[0] : visual).segments;
    }

    function setupChart(plotArea, options, rootOptions) {
        const box = chartBox.clone();
        chart = new TChart(plotArea, options);

        root = new RootElement(rootOptions);
        root.append(chart);

        root.reflow();
        root.renderVisual();
        pointCoordinates = mapSegments(pathSegments(chart));
    }

    function stubPlotArea(getCategorySlot, getValueSlot, options) {
        return new function() {
            this.categoryAxis = this.primaryCategoryAxis = {
                getSlot: getCategorySlot,
                lineBox: function() {
                    return new Box(0,2,2,2);
                },
                options: {
                    categories: ["A", "B"]
                }
            };

            this.valueAxis = {
                getSlot: getValueSlot,
                lineBox: function() {
                    return new Box(0,0,0,2);
                },
                options: {},
                startValue: function() {
                    return 0;
                }
            };

            this.namedCategoryAxes = {};
            this.namedValueAxes = {};

            this.seriesCategoryAxis = function(series) {
                return series.categoryAxis ?
                    this.namedCategoryAxes[series.categoryAxis] : this.primaryCategoryAxis;
            };

            this.options = options;
        };
    }

    (function() {
        const plotArea = stubPlotArea(
            function(categoryIndex) {
                return new Box();
            },
            function(value) {
                return new Box();
            },
            {
                categoryAxis: { }
            }
        );

        function createChart(options) {
            setupChart(plotArea, options || {
                series: [{
                    data: [0, 1]
                }]
            });
        }

        // ------------------------------------------------------------
        describe(chartName + " / Rendering", () => {
            beforeEach(() => {
                createChart();
            });

            it("creates visual", () => {
                ok(chart.visual);
            });

            it("creates clip animation", () => {
                ok(chart.animation);
                ok(chart.animation instanceof ClipAnimation);
                sameBox(chart.animation.options.box, root.box);
                sameLinePath(chart.animation.element, draw.Path.fromRect(root.box.toRect()));
            });

            it("does not create clip animation if transitions are disabled", () => {
                setupChart(plotArea, {
                    series: [{
                        data: [0, 1]
                    }]
                }, {
                    transitions: false
                });
                ok(!chart.animation);
                ok(!chart.visual.clip());
            });

            it("does not set clip on segments by default", () => {
                const segments = chart._segments;
                for (let idx = 0; idx < segments.length; idx++) {
                    ok(!segments[idx].visual.clip());
                }
            });

            it("sets animation clip path to segments with zIndex", () => {
                createChart({
                    series: [{
                        data: [0, 1]
                    }, {
                        data: [1, 2],
                        zIndex: 1
                    }]
                });

                const clip = chart._segments[1].visual.clip();
                ok(!chart._segments[0].visual.clip());
                ok(clip);
                ok(clip === chart.animation.element);
            });

            it("sets animation clip path to points markers", () => {
                createChart({
                    series: [{
                        data: [0, 1]
                    }, {
                        data: [1, null, 2],
                        zIndex: 1,
                        markers: {
                            visible: true
                        }
                    }]
                });

                const points = chart.points;
                for (let idx = 0; idx < points.length; idx++) {
                    if (points[idx]) {
                        const clip = points[idx].marker.visual.clip();
                        if (points[idx].options.zIndex) {
                            ok(clip);
                            ok(clip === chart.animation.element);
                        } else {
                            ok(!clip);
                        }
                    }
                }
            });

            it("renders segments in the order specified with the series configuration", () => {
                createChart({
                    series: [{
                        name: "foo",
                        data: [0, 1]
                    }, {
                        name: "bar",
                        data: [1, 2]
                    }]
                });

                const segments = grep(chart.children, function(item) {
                    return item instanceof LineSegment;
                });
                equal(segments[0].series.name, "foo");
                equal(segments[1].series.name, "bar");
            });
        });

    })();

    (function() {
        const positiveSeries = { data: [1, 2], labels: {} };
        const negativeSeries = { data: [-1, -2], labels: {} };
        const sparseSeries = { data: [1, 2, undefined, 2], width: 0 };
        const VALUE_AXIS_MAX = 2;
        const CATEGORY_AXIS_Y = 2;

        const getCategorySlot = function(categoryIndex) {
            return new Box(categoryIndex, CATEGORY_AXIS_Y, categoryIndex + 1, CATEGORY_AXIS_Y);
        };

        const getValueSlot = function(value = 0) {
            const valueY = VALUE_AXIS_MAX - value;
            const slotTop = Math.min(CATEGORY_AXIS_Y, valueY);
            const slotBottom = Math.max(CATEGORY_AXIS_Y, valueY);

            return new Box(0, slotTop, 0, slotBottom);
        };

        const plotArea = stubPlotArea(getCategorySlot, getValueSlot);

        // ------------------------------------------------------------
        describe(chartName + " / Positive Values", () => {
            beforeEach(() => {
                setupChart(plotArea, { series: [ positiveSeries ] });
            });

            it("Creates points for data points", () => {
                equal(chart.points.length, positiveSeries.data.length);
            });

            it("Reports minimum series value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].min, positiveSeries.data[0]);
            });

            it("Reports maximum series value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].max, positiveSeries.data[1]);
            });

            it("Reports number of categories", () => {
                setupChart(plotArea, {series: [ positiveSeries ]});
                equal(categoriesCount(chart.options.series), positiveSeries.data.length);
            });

            it("points are distributed across category axis", () => {
                const pointsX = map(chart.points, function(point) {
                    return point.box.x1;
                });

                equal(pointsX, [0, 1]);
            });

            it("points are aligned to category axis", () => {
                const pointsY = map(chart.points, function(point) {
                    return point.box.y2;
                });

                equal(pointsY, [CATEGORY_AXIS_Y, CATEGORY_AXIS_Y]);
            });

            it("points have set width", () => {
                for (let idx = 0; idx < chart.points.length; idx++) {
                    equal(chart.points[idx].box.width(), 1);
                }
            });

            it("points have set height according to value", () => {
                const pointHeights = map(chart.points, function(point) {
                    return point.box.height();
                });

                equal(pointHeights, [1, 2]);
            });

            it("getNearestPoint returns nearest series point", () => {
                const point = chart.points[1];
                const result = chart.getNearestPoint(point.box.x2 + 100, point.box.y2, 0);

                ok(result === point);
            });

            it("sets point owner", () => {
                ok(chart.points[0].owner === chart);
            });

            it("sets point series", () => {
                ok(chart.points[0].series === positiveSeries);
            });

            it("sets point series index", () => {
                ok(chart.points[0].seriesIx === 0);
            });

            it("sets point category", () => {
                equal(chart.points[0].category, "A");
            });

            it("sets point stackValue to be the same as value", () => {
                equal(chart.points[0].stackValue, 1);
            });

            it("sets correct category if multiple categoryAxis are used", () => {
                const plotArea = new CategoricalPlotArea([{
                    type: seriesName,
                    categoryAxis: "A",
                    data: [1, 2]
                }, {
                    type: seriesName,
                    categoryAxis: "B",
                    data: [3, 4]
                }], {
                    categoryAxis: [{
                        name: "A",
                        categories: [1, 2]
                    }, {
                        name: "B",
                        categories: [3, 4]
                    }]
                });

                for (let chartIdx = 0; chartIdx < plotArea.charts.length; chartIdx++) {
                    const chart = plotArea.charts[chartIdx];
                    for (let idx = 0; idx < chart.points.length; idx++) {
                        equal(chart.points[idx].category, chart.points[idx].value);
                    }
                }
            });

            it("sets point dataItem", () => {
                equal(typeof chart.points[0].dataItem, "number");
            });

            it("Throws error when unable to locate value axis", () => {
                expect(function() {
                    setupChart(plotArea, {
                        series: [{ axis: "b", data: [1] }]
                    });
                }).toThrowError(/Unable to locate value axis with name b/);
            });
        });

        // ------------------------------------------------------------
        describe(chartName + " / Negative Values", () => {
            beforeEach(() => {
                setupChart(plotArea, { series: [ negativeSeries ] });
            });

            it("Reports minimum series value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].min, negativeSeries.data[1]);
            });

            it("Reports maximum series value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].max, negativeSeries.data[0]);
            });

            it("point tops are aligned to category axis", () => {
                const pointsY = map(chart.points, function(point) {
                    return point.box.y1;
                });

                equal(pointsY, [CATEGORY_AXIS_Y, CATEGORY_AXIS_Y]);
            });

            it("points have set height according to value", () => {
                const pointHeights = map(chart.points, function(point) {
                    return point.box.height();
                });

                equal(pointHeights, [1, 2]);
            });

            it("getNearestPoint returns nearest series point", () => {
                const point = chart.points[1],
                    result = chart.getNearestPoint(point.box.x2 + 100, point.box.y2, 0);

                ok(result === point);
            });
        });

        // ------------------------------------------------------------
        describe(chartName + " / Mismatched series", () => {
            beforeEach(() => {
                setupChart(plotArea, {
                series: [ { data: [1, 2, 3] },
                          positiveSeries
                    ]
                });
            });

            it("Reports minimum series value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].min, 1);
            });

            it("Reports maximum series value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].max, 3);
            });

            it("Reports number of categories", () => {
                equal(categoriesCount(chart.options.series), 3);
            });
        });

        // ------------------------------------------------------------
        describe(chartName + " / Missing values", () => {
            beforeEach(() => {
                setupChart(plotArea, {
                    series: [ sparseSeries ]
                });
            });

            it("reports minimum series value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].min, 1);
            });

            it("reports maximum series value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].max, 2);
            });

            it("omits missing points when interpolating", () => {
                setupChart(plotArea, {
                    series: [
                        deepExtend({ missingValues: "interpolate" }, sparseSeries)
                    ]
                });

                equal(chart.points[2], null);
            });
        });

        // ------------------------------------------------------------
        describe(chartName + " / Stack / Positive Values", () => {
            beforeEach(() => {
                setupChart(plotArea, {
                    series: [ positiveSeries, positiveSeries, positiveSeries ],
                    isStacked: true }
                );
            });

            it("reports stacked minumum value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].min, 1);
            });

            it("reports stacked maximum value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].max, 6);
            });

            it("point plot values are stacked", () => {
                equal(
                    map(chart.points, function(point) { return chart.plotRange(point)[0] }),
                    [1, 2, 3, 2, 4, 6]
                );
            });

            it("sets point stackValue", () => {
                equal(chart.points[0].stackValue, 1);
                equal(chart.points[1].stackValue, 2);
                equal(chart.points[2].stackValue, 3);
            });
        });

        // ------------------------------------------------------------
        describe(chartName + " / Stack / Negative Values", () => {
            beforeEach(() => {
                setupChart(plotArea, {
                    series: [ negativeSeries, negativeSeries, negativeSeries ],
                    isStacked: true
                });
            });

            it("reports stacked minumum value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].min, -6);
            });

            it("reports stacked maximum value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].max, -1);
            });

            it("point plot values are stacked", () => {
                equal(
                    map(chart.points, function(point) { return chart.plotRange(point)[0] }),
                    [-1, -2, -3, -2, -4, -6]
                );
            });

            it("sets point stackValue", () => {
                equal(chart.points[0].stackValue, -1);
                equal(chart.points[1].stackValue, -2);
                equal(chart.points[2].stackValue, -3);
            });
        });

        // ------------------------------------------------------------
        describe(chartName + " / Stack / Mixed Values", () => {
            beforeEach(() => {
                setupChart(plotArea, {
                    series: [{
                        data: [2, 2],
                        labels: {}
                    }, {
                        data: [-1, -1],
                        labels: {}
                    }],
                    isStacked: true
                });
            });

            it("reports stacked minumum value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].min, 1);
            });

            it("reports stacked maximum value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].max, 2);
            });

            it("points have set height according to stack value", () => {
                const pointHeights = map(chart.points, function(point) {
                    return point.box.height();
                });

                equal(pointHeights, [2, 1, 2, 1]);
            });

            it("sets point stackValue", () => {
                equal(chart.points[0].stackValue, 2);
                equal(chart.points[1].stackValue, 1);
            });
        });

        // ------------------------------------------------------------
        describe(chartName + " / Stack / Mixed Series", () => {
            beforeEach(() => {
                plotArea.namedValueAxes.a = plotArea.valueAxis;
                plotArea.namedValueAxes.b = plotArea.valueAxis;

                setupChart(plotArea, {
                    series: [
                        // Both axes should be on same axis.
                        // This rule is intentionally broken for the tests.
                        deepExtend({ axis: "a" }, positiveSeries),
                        deepExtend({ axis: "b" }, negativeSeries)
                    ],
                    isStacked: true
                });
            });

            it("reports stacked minumum value for default axis", () => {
                equal(chart.valueAxisRanges.a.min, 0);
            });

            it("reports stacked maximum value for default axis", () => {
                equal(chart.valueAxisRanges.a.max, 2);
            });
        });

        // ------------------------------------------------------------
        describe(chartName + " / Stack / Missing values", () => {
            beforeEach(() => {
                setupChart(plotArea, {
                    series: [ sparseSeries, sparseSeries ],
                    isStacked: true
                });
            });

            it("Reports minimum series value", () => {
                equal(chart.valueAxisRanges[undefined].min, 0);
            });

            it("Reports minimum series value (interpolated)", () => {
                setupChart(plotArea, {
                    series: [
                        deepExtend({ missingValues: "interpolate" }, sparseSeries)
                    ],
                    isStacked: true
                });
                equal(chart.valueAxisRanges[undefined].min, 1);
            });

            it("Reports maximum series value", () => {
                equal(chart.valueAxisRanges[undefined].max, 4);
            });

            it("missing points are assumed to be 0 by default", () => {
                equal(chart.points[4].value, 0);
            });

            it("missing points are skipped", () => {
                setupChart(plotArea, {
                    series: [
                        deepExtend({ missingValues: "gap" }, sparseSeries)
                    ],
                    isStacked: true
                });

                equal(chart.points[2], null);
            });
        });

        // ------------------------------------------------------------
        describe(chartName + " / 100% Stacked / Positive Values", () => {
            beforeEach(() => {
                setupChart(plotArea, {
                    series: [ positiveSeries, positiveSeries ],
                    isStacked: true, isStacked100: true }
                );
            });

            it("reports minumum value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].min, 0.5);
            });

            it("reports maximum value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].max, 1);
            });
        });

        // ------------------------------------------------------------
        describe(chartName + " / 100% Stacked / Negative Values", () => {
            beforeEach(() => {
                setupChart(plotArea, {
                    series: [ negativeSeries, negativeSeries ],
                    isStacked: true, isStacked100: true }
                );
            });

            it("reports minumum value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].min, -1);
            });

            it("reports maximum value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].max, -0.5);
            });
        });

        // ------------------------------------------------------------
        describe(chartName + " / 100% Stacked / Mixed Values", () => {
            beforeEach(() => {
                setupChart(plotArea, {
                    series: [{
                        data: [2, 2],
                        labels: {}
                    }, {
                        data: [-1, -1],
                        labels: {}
                    }],
                    isStacked: true, isStacked100: true }
                );
            });

            it("reports minumum value for default axis", () => {
                equal(chart.valueAxisRanges[undefined].min, 1/3);
            });

            it("reports maximum value for default axis", () => {
                close(chart.valueAxisRanges[undefined].max, 2/3);
            });
        });

        // ------------------------------------------------------------
        describe(chartName + " / Stack / Panes", () => {
            afterEach(() => {
                destroyChart(chart);
            });

            it("charts in different panes are not stacked", () => {

                chart = createChart({
                    series: [{
                        stack: true,
                        type: seriesName,
                        data: [1]
                    }, {
                        type: seriesName,
                        data: [2],
                        axis: "b"
                    }],
                    panes: [{
                        name: "top"
                    }, {
                        name: "bottom"
                    }],
                    valueAxis: [{
                    }, {
                        name: "b",
                        pane: "bottom"
                    }],
                    categoryAxis: {
                        categories: ["A"]
                    }
                });

                const charts = chart._model._plotArea.charts;
                equal(charts[0].points[0].plotValue, undefined);
                equal(charts[1].points[0].plotValue, undefined);
            });
        });
    })();

    (function() {
        const MARGIN = 5;
        const PADDING = 5;
        const BORDER = 5;
        let chart, linePoint;

        const plotArea = stubPlotArea(
            function(categoryIndex) {
                return new Box();
            },
            function(value) {
                return new Box();
            },
            {
                categoryAxis: { }
            }
        );

        function createCustomChart(options) {
            chart = new TChart(plotArea, {
                series: [deepExtend({
                    data: [0, 1],
                    color: "#f00",
                    markers: {
                        visible: false,
                        size: 10,
                        type: "triangle",
                        border: {
                            width: BORDER
                        },
                        opacity: 0.2
                    },
                    labels: {
                        visible: false,
                        color: "labels-color",
                        background: "labels-background",
                        border: {
                            color: "labels-border",
                            width: BORDER
                        },
                        margin: MARGIN,
                        padding: PADDING
                    },
                    opacity: 0.5,
                    dashType: "dot"
                }, options)]
            });
            linePoint = chart.points[0];
            chart.reflow(chartBox);
        }

        // ------------------------------------------------------------
        describe(chartName + " / Configuration", () => {
            beforeEach(() => {
                createCustomChart();
            });

            it("remove series if visible is set to false", () => {
                const chart = createChart({
                    seriesDefaults: {
                        type: seriesName
                    },
                    series: [{
                        data: [1],
                        visible: false
                    },{
                        data: [1]
                    }]
                });

                const points = chart._model._plotArea.charts[0].points;

                ok(points.length === 1);
                destroyChart(chart);
            });

            it("applies visible to point markers", () => {
                equal(linePoint.options.markers.visible, false);
            });

            it("applies series color to point markers border", () => {
                createCustomChart({ markers: { visible: true } });
                equal(linePoint.marker.options.border.color, "#f00");
            });

            it("applies opacity to point markers", () => {
                equal(linePoint.options.markers.opacity, 0.2);
            });

            it("applies size to point markers", () => {
                equal(linePoint.options.markers.size, 10);
            });

            it("applies type to point markers", () => {
                equal(linePoint.options.markers.type, "triangle");
            });

            it("applies border color to point markers", () => {
                createCustomChart({ markers: { border: { color: "marker-border" } } });
                equal(linePoint.options.markers.border.color, "marker-border");
            });

            it("applies border width to point markers.", () => {
                equal(linePoint.options.markers.border.width, BORDER);
            });

            it("applies visible to point labels", () => {
                equal(linePoint.options.labels.visible, false);
            });

            it("applies color to point labels", () => {
                equal(linePoint.options.labels.color, "labels-color");
            });

            it("applies background to point labels", () => {
                equal(linePoint.options.labels.background, "labels-background");
            });

            it("applies border color to point labels", () => {
                equal(linePoint.options.labels.border.color, "labels-border");
            });

            it("applies border width to point labels", () => {
                equal(linePoint.options.labels.border.width, BORDER);
            });

            it("applies padding to point labels", () => {
                equal(linePoint.options.labels.padding, PADDING);
            });

            it("applies margin to point labels", () => {
                equal(linePoint.options.labels.margin, MARGIN);
            });

            it("applies dashType", () => {
                equal(linePoint.options.dashType, "dot");
            });

            it("binds point color", () => {
                createCustomChart({
                    type: seriesName,
                    data: [{
                        color: "red", value: 1
                    }, {
                        color: "green", value: 2
                    }],
                    field: "value",
                    colorField: "color"
                });

                equal(chart.points[0].color, "red");
                equal(chart.points[1].color, "green");
            });

            it("applies color function", () => {
                createCustomChart({
                    markers: { visible: true },
                    color: function(point) { return "#f00" }
                });

                equal(linePoint.marker.options.border.color, "#f00");
            });

            it("applies color function for each point", () => {
                const options = createSpy({
                    markers: { visible: true },
                    color: function() { ok(true) }
                }, "color");
                createCustomChart(options);
                expect(options.color).toHaveBeenCalledTimes(2);
            });

            it("color fn argument contains value", () => {
                const options = createSpy({
                    data: [1],
                    color: function(point) { equal(point.value, 1); }
                }, "color");
                createCustomChart(options);
                expect(options.color).toHaveBeenCalledTimes(1);
            });

            it("color fn argument contains category", () => {
                const options = createSpy({
                    data: [1],
                    color: function(point) { equal(point.category, "A"); }
                }, "color");
                createCustomChart(options);
                expect(options.color).toHaveBeenCalledTimes(1);
            });

            it("color fn argument contains series", () => {
                const options = createSpy({
                    name: "series 1",
                    data: [1],
                    color: function(point) { equal(point.series.name, "series 1"); }
                }, "color");
                createCustomChart(options);
                expect(options.color).toHaveBeenCalledTimes(1);
            });
        });

    })();

    (function() {
        const data = [{
            name: "Category A",
            text: "Alpha",
            value: 0
        }];
        let chart, label;

        // ------------------------------------------------------------
        describe(chartName + " / Integration", () => {
            beforeEach(() => {
                chart = createChart({
                    seriesDefaults: {
                        labels: {
                            visible: true,
                            template: "${dataItem.text}"
                        }
                    },
                    series: [{
                        data: data,
                        name: "Value",
                        type: seriesName,
                        field: "value"
                    }],
                    categoryAxis: {
                        field: "name"
                    }
                });

                label = chart._plotArea.charts[0].points[0].label;
            });

            afterEach(() => {
                destroyChart(chart);
            });

            it("dataItem sent to label template", () => {
                equal(label.content, "Alpha");
            });
        });

    })();

    (function() {
        const box = new Box(0, 0, 100, 100);
        let point;

        function setupChart(options) {
            chart = createChart({
                series: [deepExtend({
                    name: "Value",
                    type: seriesName,
                    data: [{ value: 10, noteText: "A" }]
                }, options)]
            });

            point = chart._plotArea.charts[0].points[0];
        }

         describe(chartName + " / Note", () => {
            afterEach(() => {
                destroyChart(chart);
            });

            it("reflows note in marker box", () => {
                setupChart({
                    markers: {
                        visible: true
                    }
                });
                point.note.reflow = function(targetBox) {
                    equal(point.markerBox().getHash(), targetBox.getHash());
                };
                point.reflow(box);
            });

            it("reflows note in marker center box if markers are not visible", () => {
                setupChart({
                    markers: {
                        visible: false
                    }
                });
                point.note.reflow = function(targetBox) {
                    const center = point.markerBox().center();

                    equal(new Box(center.x, center.y, center.x, center.y).getHash(), targetBox.getHash());
                };
                point.reflow(box);
            });
         });


    })();

    (function() {
        const CATEGORY_AXIS_Y = 2;
        const getCategorySlot = function(categoryIndex) {
            return new Box(categoryIndex, 0,
                             categoryIndex, 0);
        };
        const getValueSlot = function(value) {
            return new Box(0, value, 0, value);
        };
        const plotArea = stubPlotArea(
            getCategorySlot,
            getValueSlot,
            {
                categoryAxis: {

                }
            }
        );
        let points;

        function setupChart(minPoint, maxPoint) {
            chart = new TChart(plotArea, {
                series: [{
                    data: [1, 2],
                    _outOfRangeMinPoint: minPoint,
                    _outOfRangeMaxPoint: maxPoint
                }]
            });
            chart.reflow(chartBox);
            points = chart.points;
        }
        // ------------------------------------------------------------
        describe(chartName + " / out of range points", () => {

            it("creates out of range points", () => {
                setupChart({
                    categoryIx: -1,
                    category: "foo",
                    item: 0
                }, {
                    categoryIx: 2,
                    category: "bar",
                    item: 3
                });

                equal(points.length, 4);
                equal(points[0].category, "foo");
                equal(points[0].categoryIx, -1);
                equal(points[0].value, 0);

                equal(points[3].category, "bar");
                equal(points[3].categoryIx, 2);
                equal(points[3].value, 3);
            });

            it("reflows out of range points", () => {
                setupChart({
                    categoryIx: -1,
                    category: "foo",
                    item: 5
                }, {
                    categoryIx: 2,
                    category: "bar",
                    item: 10
                });


                sameBox(points[0].box, new Box(-1, 5, -1, 5));
                sameBox(points[3].box, new Box(2, 10, 2, 10));

            });
        });

    })();
}
