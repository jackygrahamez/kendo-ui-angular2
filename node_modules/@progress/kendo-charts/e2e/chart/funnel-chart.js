import 'core-js/es6';
import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';

import { RootElement, Box } from '../../src/core';
import FunnelChart from '../../src/chart/funnel-chart/funnel-chart';
import FunnelSegment from '../../src/chart/funnel-chart/funnel-segment';

import { deepExtend, map } from '../../src/common';

import { ok, equal, close, arrayClose, sameLinePath } from '../../test/test-helpers';
import { clickChart, triggerEvent, createChart, destroyChart, getChartDomElement }  from '../test-helpers';
import '../../test/text-measure';

const TOLERANCE = 1;
const box = new Box(0, 0, 800, 600);
let chart;

function mapPoints(points) {
    return map(points, function(p) { return [p.x, p.y] });
}

function createFunnelChart(options) {
    const plotArea = {
        options: {
            seriesColors: ["red", "green", "blue"],
            legend:{
                visible:false
            }
        }
    };

    chart = new FunnelChart(plotArea, options);
    chart.reflow(box);
}

// ------------------------------------------------------------
describe('dynamicSlope false', () => {
    beforeEach(() => {
        createFunnelChart({
            dynamicHeight:false,
            series: [{
                data: [{
                    value: 1,
                    category: "A",
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 3,
                    category: "C"
                }]
            }]
        });
    });

    it("First segment position", () => {
        arrayClose(mapPoints(chart.points[0].points), [
            [0, 0], [800, 0], [707, 200], [93, 200]
        ], TOLERANCE);
    });

    it("Second segment position", () => {
        arrayClose(mapPoints(chart.points[1].points), [
            [93, 200], [706, 200], [613, 400], [186, 400]
        ], TOLERANCE);
    });

    it("Third segment position", () => {
        arrayClose(mapPoints(chart.points[2].points), [
            [186,400], [613, 400], [520, 600], [280, 600]
        ], TOLERANCE);
    });


    it("Creates segments for data points", () => {
        equal(chart.points.length, chart.options.series[0].data.length);
    });
});

describe('null/undefined cases', () => {


    it("does not render segments for null", () => {
        createFunnelChart({
            dynamicHeight: false,
            series: [{
                data: [{
                    value: null,
                    category: "A",
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 3,
                    category: "C"
                }]
            }]
        });

        equal(chart.points.length, 2);
    });

    it("does not render segments for undefined", () => {
        createFunnelChart({
            dynamicHeight: false,
            series: [{
                data: [{
                    value: undefined,
                    category: "A",
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 3,
                    category: "C"
                }]
            }]
        });

        equal(chart.points.length, 2);
    });

    it("does not render label for undefined", () => {
        createFunnelChart({
            dynamicHeight: false,
            labels: {
                visible: true
            },
            series: [{
                data: [{
                    value: undefined,
                    category: "A",
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 3,
                    category: "C"
                }]
            }]
        });

        equal(chart.labels.length, 2);
    });

    it("does not render label for null", () => {
        createFunnelChart({
            dynamicHeight: false,
            labels: {
                visible: true
            },
            series: [{
                data: [{
                    value: null,
                    category: "A",
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 3,
                    category: "C"
                }]
            }]
        });

        equal(chart.labels.length, 2);
    });

    it("renders segment for 0", () => {
        createFunnelChart({
            dynamicHeight: false,
            series: [{
                data: [{
                    value: 0,
                    category: "A",
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 3,
                    category: "C"
                }]
            }]
        });

        equal(chart.points.length, 3);
    });

    it("renders label for 0", () => {
        createFunnelChart({
            dynamicHeight: false,
            labels: {
                visible: true
            },
            series: [{
                data: [{
                    value: 0,
                    category: "A",
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 3,
                    category: "C"
                }]
            }]
        });

        equal(chart.labels.length, 3);
    });

    it("renders segment for negative values", () => {
        createFunnelChart({
            dynamicHeight: false,
            series: [{
                data: [{
                    value: -1,
                    category: "A",
                }, {
                    value: 1,
                    category: "B"
                }]
            }]
        });

        equal(chart.points[0].percentage, 0.5);
    });
});

describe('dynamicSlope false', () => {
    beforeEach(() => {
        createFunnelChart({
            dynamicSlope:false,
            series: [{
                data: [{
                    value: 1,
                    category: "A",
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 3,
                    category: "C"
                }]
            }]
        });
    });

    it("First segment position", () => {
        arrayClose(mapPoints(chart.points[0].points), [
            [0, 0], [800, 0], [753, 100], [46, 100]
        ], TOLERANCE);
    });

    it("Second segment position", () => {
        arrayClose(mapPoints(chart.points[1].points), [
            [46, 100], [753, 100], [660, 300], [140, 300]
        ], TOLERANCE);
    });

    it("Third segment position", () => {
        arrayClose(mapPoints(chart.points[2].points), [
            [140,300], [660, 300], [520, 600], [280, 600]
        ], TOLERANCE);
    });
});

describe('max neckRatio', () => {
    beforeEach(() => {
        createFunnelChart({
            dynamicSlope:false,
            neckRatio: 1,
            series: [{
                data: [{
                    value: 1,
                    category: "A",
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 3,
                    category: "C"
                }]
            }]
        });
    });

    it("First segment position", () => {
        arrayClose(mapPoints(chart.points[0].points), [
            [0, 0], [800, 0], [800, 100], [0, 100]
        ], TOLERANCE);
    });

    it("Second segment position", () => {
        arrayClose(mapPoints(chart.points[1].points), [
            [0, 100], [800, 100], [800, 300], [0, 300]
        ], TOLERANCE);
    });

    it("Third segment position", () => {
        arrayClose(mapPoints(chart.points[2].points), [
            [0, 300], [800, 300], [800, 600], [0, 600]
        ], TOLERANCE);
    });
});

describe('min neckRatio', () => {
    beforeEach(() => {
        createFunnelChart({
            dynamicSlope:false,
            neckRatio: 0,
            series: [{
                data: [{
                    value: 1,
                    category: "A",
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 3,
                    category: "C"
                }]
            }]
        });
    });

    it("First segment position", () => {
        arrayClose(mapPoints(chart.points[0].points), [
            [0, 0], [800, 0], [733, 100], [66, 100]
        ], TOLERANCE);
    });

    it("Second segment position", () => {
        arrayClose(mapPoints(chart.points[1].points), [
            [66, 100], [733, 100], [600, 300], [200, 300]
        ], TOLERANCE);
    });

    it("Third segment position", () => {
        arrayClose(mapPoints(chart.points[2].points), [
            [200, 300], [600, 300], [400, 600], [400, 600]
        ], TOLERANCE);
    });
});

describe('Series setup', () => {
    beforeEach(() => {
        createFunnelChart({
            series: [{
                type: "funnel",
                opacity:0.3,
                data: [{
                    value: 1,
                    category: "A",
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 3,
                    category: "C"
                }]
            }]
        });
    });

    it("sets point owner", () => {
        ok(chart.points[0].owner === chart);
    });

    it("sets point series", () => {
        equal(chart.points[0].series.type, "funnel");
    });

    it("sets point category", () => {
        equal(chart.points[0].category, "A");
    });

    it("sets point dataItem", () => {
        equal(typeof chart.points[0].dataItem, "object");
    });
});

describe('Series with empty data', () => {
    beforeEach(() => {
        createFunnelChart({
            series: [{
                type: "funnel",
                data: []
            }]
        });
    });

    it("sets point dataItem", () => {
        ok(true);
    });
});

describe('Series with no data', () => {
    beforeEach(() => {
        createFunnelChart({
            series: [{
                type: "funnel",
                dynamicSlope:true,
            }]
        });
    });

    it("sets point dataItem", function() {
        ok(true);
    });
});

describe('dynamicSlope false with spacing', () => {
    beforeEach(() => {
        createFunnelChart({
            dynamicSlope:false,
            segmentSpacing:30,
            neckRatio: 0,
            series: [{
                data: [{
                    value: 1,
                    category: "A",
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 7,
                    category: "C"
                }]
            }]
        });
    });

    it("First segment position", () => {
        arrayClose(mapPoints(chart.points[0].points), [
            [0, 0], [800, 0], [760, 54], [40, 54]
        ], TOLERANCE);
    });

    it("Second segment position", () => {
        arrayClose(mapPoints(chart.points[1].points), [
            [40, 84], [760, 84], [680, 192], [120, 192]
        ], TOLERANCE);
    });

    it("Third segment position", () => {
        arrayClose(mapPoints(chart.points[2].points), [
            [120, 222], [680, 222], [400, 600], [400, 600]
        ], TOLERANCE);
    });
});

describe('dynamicSlope false with spacing', () => {
    beforeEach(() => {
        createFunnelChart({
            dynamicSlope:false,
            segmentSpacing:33,
            neckRatio: 0,
            series: [{
                segmentSpacing:33,
                data: [{
                    value: 1,
                    category: "A",
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 7,
                    category: "C"
                }]
            }]
        });
    });

    it("First segment position", () => {
        arrayClose(mapPoints(chart.points[0].points), [
            [0, 0], [800, 0], [760, 53], [40, 53]
        ], TOLERANCE);
    });

    it("Second segment position", () => {
        arrayClose(mapPoints(chart.points[1].points), [
            [40, 86], [760, 86], [680, 193], [120, 193]
        ], TOLERANCE);
    });

    it("Third segment position", () => {
        arrayClose(mapPoints(chart.points[2].points), [
            [120, 226], [680, 226], [400, 600], [400, 600]
        ], TOLERANCE);
    });
});

describe('dynamicSlope true', () => {
    beforeEach(() => {
        createFunnelChart({
            dynamicSlope:true,
            series: [{
                data: [{
                    value: 7,
                    category: "A",
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 7,
                    category: "C"
                }]
            }]
        });
    });

    it("First segment position", () => {
        arrayClose(mapPoints(chart.points[0].points), [
            [0, 0], [800, 0], [514, 262], [285, 262]
        ], TOLERANCE);
    });

    it("Second segment position", () => {
        arrayClose(mapPoints(chart.points[1].points), [
            [285, 262], [514, 262], [800, 337], [0, 337]
        ], TOLERANCE);
    });

    it("Third segment position", () => {
        arrayClose(mapPoints(chart.points[2].points), [
            [0, 337], [800, 337], [800, 600], [0, 600]
        ], TOLERANCE);
    });
});

describe('dynamicSlope true with spacing', () => {
    beforeEach(() => {
        createFunnelChart({
            segmentSpacing : 22,
            dynamicSlope:true,
            series: [{
                data: [{
                    value: 7,
                    category: "A",
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 7,
                    category: "C"
                }]
            }]
        });
    });

    it("First segment position", () => {
        arrayClose(mapPoints(chart.points[0].points), [
            [0, 0], [800, 0], [514, 243], [285, 243]
        ], TOLERANCE);
    });

    it("Second segment position", () => {
        arrayClose(mapPoints(chart.points[1].points), [
            [285, 265], [514, 265], [800, 334], [0, 334]
        ], TOLERANCE);
    });

    it("Third segment position", () => {
        arrayClose(mapPoints(chart.points[2].points), [
            [0, 356], [800, 356], [800, 600], [0, 600]
        ], TOLERANCE);
    });
});

describe('dynamicSlope / zero values', () => {
    beforeEach(() => {
        createFunnelChart({
            dynamicSlope:true,
            series: [{
                data: [7, 0, 1, 0, 0, 1]
            }]
        });
    });

    it("zero segment has max width", () => {
        const points = chart.points[1].points;
        equal(points[2].x, 800);
        equal(points[3].x, 0);
    });

    it("zero segment has zero width if the next segment is also zero", () => {
        const points = chart.points[3].points;
        equal(points[2].x, 400);
        equal(points[3].x, 400);
    });
});

describe('using label with template', () => {
    beforeEach(() => {
        createFunnelChart({
            segmentSpacing : 22,
            dynamicSlope:true,
            labels: {
                visible:true,
                align: function(context) { return context.index % 2 === 0 ? "left" : "right"; },
                color:'red',
                margin: 5,
                template: "My Template #=value#"
            },
            series: [{
                data: [{
                    value: 7,
                    category: "A",
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 7,
                    category: "C"
                }]
            }]
        });
    });


    it("sets template options for the labels", () => {
        ok(chart.labels[0].options.template === "My Template #=value#");
    });

    it("sets margin options for the labels", () => {
        equal(chart.labels[0].options.margin, {
            left: 5,
            top: 5,
            bottom: 5,
            right: 5
        });
    });

    it("sets default options for the labels", () => {
        const padding = chart.labels[0].options.padding;
        ok(padding !== null && padding !== undefined);
        ok(Object.keys(padding).length > 0);
    });

    it("sets color for the labels", () => {
        const options = chart.labels[0].options;
        ok(options.color === 'red')
    });

    it("First label text position", () => {
        const textBox = chart.labels[0].children[0].box;
        close(textBox.x1,5,TOLERANCE);
        close(textBox.x2,109,TOLERANCE);
        close(textBox.y1,114,TOLERANCE);
        close(textBox.y2,129,TOLERANCE);
    });

    it("Second label text position", () => {
        const textBox = chart.labels[1].children[0].box;
        close(textBox.x1,691,TOLERANCE);
        close(textBox.x2,795,TOLERANCE);
        close(textBox.y1,292,TOLERANCE);
        close(textBox.y2,307,TOLERANCE);
    });

    it("Third label text position", () => {
        const textBox = chart.labels[2].children[0].box;
        close(textBox.x1,5,TOLERANCE);
        close(textBox.x2,109,TOLERANCE);
        close(textBox.y1,470,TOLERANCE);
        close(textBox.y2,485,TOLERANCE);
    });

    it("First label box position", () => {
        const textBox = chart.labels[0].box;
        close(textBox.x1,0,TOLERANCE);
        close(textBox.x2,114,TOLERANCE);
        close(textBox.y1,109,TOLERANCE);
        close(textBox.y2,134,TOLERANCE);
    });

    it("Second label bx position", () => {
        const textBox = chart.labels[1].box;
        close(textBox.x1,686,TOLERANCE);
        close(textBox.x2,800,TOLERANCE);
        close(textBox.y1,287,TOLERANCE);
        close(textBox.y2,312,TOLERANCE);
    });

    it("Third label box position", () => {
        const textBox = chart.labels[2].box;
        close(textBox.x1,0,TOLERANCE);
        close(textBox.x2,114,TOLERANCE);
        close(textBox.y1,465,TOLERANCE);
        close(textBox.y2,490,TOLERANCE);
    });

    it("First segment position", () => {
        arrayClose(mapPoints(chart.points[0].points), [
            [114, 0], [686, 0], [481.7, 243], [318, 243]
        ], TOLERANCE);
    });

    it("Second segment position", () => {
        arrayClose(mapPoints(chart.points[1].points), [
            [318, 265], [481, 265], [686, 334], [114, 334]
        ], TOLERANCE);
    });

    it("Third segment position", () => {
        arrayClose(mapPoints(chart.points[2].points), [
            [114, 356], [686, 356], [686, 600], [114, 600]
        ], TOLERANCE);
    });
});

(function() {
    let chart, segment, segmentElement, plotArea;

    function createFunnelChart(options) {
        chart = createChart(deepExtend({
            series: [{
                type: "funnel",
                labels:{
                    visible:true
                },
                data: [{ value: 1, category: "A" }]
            }]
        }, options));

        plotArea = chart._plotArea;
        segment = plotArea.charts[0].points[0];
        segmentElement = getChartDomElement(segment);
    }

    function segmentClick(callback) {
        createFunnelChart({
            seriesClick: callback
        });

        clickChart(chart, segmentElement);
    }

    function segmentHover(callback) {
        createFunnelChart({
            seriesHover: callback
        });

        triggerEvent("mouseover", segmentElement);
    }

    // ------------------------------------------------------------
    describe('Funnel Chart / Events / seriesClick', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when clicking segments", 1, () => {
            segmentClick(function() { ok(true); });
        });

        it("fires on subsequent click", 2, () => {
            segmentClick(function() { ok(true); });
            clickChart(chart, segmentElement);
        });

        it("fires when clicking segment labels", 1, () => {
            createFunnelChart({
                seriesClick: function() { ok(true); }
            });
            const label = plotArea.charts[0].labels[0];
            clickChart(chart, getChartDomElement(label));
        });

        it("event arguments contain value", 1, () => {
            segmentClick(function(e) { equal(e.value, 1); });
        });

        it("event arguments contain category", 1, () => {
            segmentClick(function(e) { equal(e.category, "A"); });
        });

        it("event arguments contain series", 1, () => {
            segmentClick(function(e) {
                equal(e.series, chart.options.series[0]);
            });
        });

        it("event arguments contain jQuery element", 1, () => {
            segmentClick(function(e) {
                equal(e.element[0], getChartDomElement(segment)[0]);
            });
        });
    });

    // ------------------------------------------------------------
    describe('Funnel Chart / Events / seriesHover', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when hovering segments", 1, () => {
            segmentHover(function() { ok(true); });
        });

        it("fires on tap", 1, () => {
            createFunnelChart({
                seriesHover: function() {
                    ok(true);
                }
            });

            clickChart(chart, segmentElement);
        });

        it("fires when hovering segment labels", 1, () => {
            createFunnelChart({
                seriesHover: function() { ok(true); }
            });
            const label = plotArea.charts[0].labels[0];
            triggerEvent("mouseover", getChartDomElement(label));
        });

        it("event arguments contain value", 1, () => {
            segmentHover(function(e) { equal(e.value, 1); });
        });

        it("event arguments contain category", 1, () => {
            segmentHover(function(e) { equal(e.category, "A"); });
        });

        it("event arguments contain series", 1, () => {
            segmentHover(function(e) {
                equal(e.series, chart.options.series[0]);
            });
        });

        it("event arguments contain jQuery element", 1, () => {
            segmentHover(function(e) {
                equal(e.element[0], getChartDomElement(segment)[0]);
            });
        });
    });

})();

(function() {
    const Point = geom.Point;
    const VALUE = 1;
    const CATEGORY = "A";
    const PERCENTAGE = 0.5;
    const SERIES_NAME = "series";
    let segment, box, root;

    function createFunnelSegment(options, index) {
       segment = new FunnelSegment(
            VALUE,
            options, {
                index: index || 0
            }
        );

        segment.percentage = PERCENTAGE;
        segment.category = CATEGORY;
        segment.series = { name: SERIES_NAME };
        segment.dataItem = { value: VALUE };
        segment.points = [new Point(0, 0), new Point(100, 0), new Point(100, 100), new Point(0, 100)];

        box = new Box(0, 0, 100, 100);
        segment.reflow(box);


        root = new RootElement();
        root.box = box;
        root.append(segment);
        root.renderVisual();
    }

    describe('Funnel Segment / Highlight', () => {
        beforeEach(() => {
            createFunnelSegment();
        });

        it("highlightVisual returns segment visual path", () => {
            const visual = segment.highlightVisual();

            ok(visual instanceof draw.Path);
            ok(visual === segment.visual.children[0]);
        });

        it("highlightVisualArgs returns an object with the options and the path", () => {
            const result = segment.highlightVisualArgs();
            equal(result.options, segment.options);
            sameLinePath(segment.visual.children[0], result.path);
        });
    });


    // ------------------------------------------------------------
    describe('Funnel Segment / custom visual', () => {

        it("adds custom visual", () => {
            let visual;
            createFunnelSegment({
                visual: function(e) {
                    visual = new draw.Path();
                    return visual;
                }
            });
            equal(segment.visual.children.length, 1);
            ok(segment.visual.children[0] === visual);
        });

        it("doesn't add visual  if custom visual function returns undefined", () => {
            createFunnelSegment({
                visual: function() {}
            });
            equal(segment.visual.children.length, 0);
        });

        it("passes options to custom visual function", () => {
            createFunnelSegment({
                visual: function(e) {
                   equal(segment.options, e.options);
                }
            });
        });

        it("passes category, dataItem, value, series and percentage to custom visual function", () => {
            createFunnelSegment({
                visual: function(e) {
                   equal(segment.category, CATEGORY);
                   equal(segment.dataItem.value, VALUE);
                   equal(segment.value, VALUE);
                   equal(e.series.name, SERIES_NAME);
                   equal(e.percentage, PERCENTAGE);
                }
            });
        });

        it("passes points to custom visual function", () => {
            createFunnelSegment({
                visual: function(e) {
                   equal(e.points, segment.points);
                }
            });
        });

        it("createVisual creates default visual", () => {
            createFunnelSegment({
                visual: function(e) {
                   ok(e.createVisual() instanceof draw.Path);
                }
            });
        });
    });

})();
