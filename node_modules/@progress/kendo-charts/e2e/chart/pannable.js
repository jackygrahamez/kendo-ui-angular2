import 'core-js/es6';

import Pannable from '../../src/chart/pan-and-zoom/pannable';
import { deepExtend } from '../../src/common';

import { ok, equal } from '../../test/test-helpers';
import { createChart, destroyChart }  from '../test-helpers';

const chartOptions = {
    categoryAxis: {
        categories: ["A", "B", "C", "D"],
        name: "foo",
        min: 1,
        max: 2
    }
};
let chart, plotArea, pane, pannable, panePoint;

function noop() {}

function createEventArg(options) {
    return deepExtend({
        preventDefault: noop,
        originalEvent: { },
        x: {
            startLocation: 0
        },
        y: {
            startLocation: 0            
        },
        pageX: panePoint.x,
        pageY: panePoint.y
    }, options);
}

function setup(options, panOptions){
    chart = createChart(options || chartOptions);

    plotArea = chart._plotArea;
    pane = plotArea.panes[0];

    pannable = new Pannable(plotArea, deepExtend(panOptions));
    panePoint = pane.chartsBox().center();
}

// ------------------------------------------------------------
describe('Pannable / start', () => {
    afterEach(() => {
        destroyChart(chart);
    });

    it("activates panning if no key is pressed by default", () => {  
        setup();
        pannable.start(createEventArg());
        equal(pannable._active, true);
    });

    it("does not activate panning if the cursor is not inside the plotArea background", () => {  
        setup();
        pannable.start(createEventArg({
            x: {
                client: -10
            }
        }));
        equal(pannable._active, true);
    });

    it("does not activate panning if a key is pressed default", () => {  
        setup();
        pannable.start(createEventArg({
            originalEvent: {
                ctrlKey: true
            }
        }));
        ok(!pannable._active);
    });

    it("activates panning if the set key is pressed", () => {  
        setup(chartOptions, {
            key: "ctrl"
        });
        pannable.start(createEventArg({
            originalEvent: {
                ctrlKey: true
            }
        }));
        ok(pannable._active);
    });

    it("does not activate panning if the set key is not pressed", () => {  
        setup(chartOptions, {
            key: "ctrl"
        });
        pannable.start(createEventArg());
        ok(!pannable._active);
    });
});

// ------------------------------------------------------------
describe('Pannable / move', () => {

    afterEach(() => {
        destroyChart(chart);
    });

    it("returns updated ranges based on delta", () => {  
        setup();
        pannable.start(createEventArg());
        const range = pannable.move(createEventArg({
            x: {
                delta: 10
            }
        })).foo;
        const newAxisRange = plotArea.categoryAxis.pan(-10);
        equal(range.min, newAxisRange.min);
        equal(range.max, newAxisRange.max);
    });

    it("does not return range for locked axes", () => {  
        setup(chartOptions, {
            lock: "x"
        });
        pannable.start(createEventArg());
        const range = pannable.move(createEventArg({
            x: {
                delta: 10
            }
        })).foo;
        ok(!range);
    });
});

// ------------------------------------------------------------
describe('Pannable / pan', () => {
    beforeEach(() => {
        setup();
        pannable.start(createEventArg());
        const range = pannable.move(createEventArg({
            x: {
                delta: 10
            }
        })).foo;
    });
    
    afterEach(() => {
        destroyChart(chart);
    });

    it("redraws plotArea with the current ranges", 3, () => {  
        const newAxisRange = plotArea.categoryAxis.pan(-10);
        plotArea.redraw = function() {
            ok(true);
        };

        pannable.pan();

        equal(plotArea.options.categoryAxis.min, newAxisRange.min);
        equal(plotArea.options.categoryAxis.max, newAxisRange.max);
    });
});

// ------------------------------------------------------------
describe('Pannable / event handling', () => {
    beforeEach(() => {
        chart = createChart({
            series: [{ data: [1, 2, 3, 4] }],
            categoryAxis: {
                name: "category",
                max: 2
            },
            pannable: true
        });
        pannable = chart._pannable;
    });
    
    afterEach(() => {
        destroyChart(chart);
    });

    it("unsets active point on start", 1, () => {  
        chart._unsetActivePoint = function() {
            ok(true);
        };
        chart._start(createEventArg());

        chart._unsetActivePoint = noop;
    });

    it("does not unset active point if panning is not started", 0, () => {  
        pannable.start = function() {
            return false;
        };
        chart._unsetActivePoint = function() {
            ok(false);
        };
        chart._start(createEventArg());

        chart._unsetActivePoint = noop;
    });

    it("suspends surface tracking on start", 1, () => {  
        chart.surface.suspendTracking = function() {
            ok(true);
        };
        chart._start(createEventArg());

        chart._unsetActivePoint = noop;
    });

    it("does not unset active point if panning is not started", 0, () => {  
        pannable.start = function() {
            return false;
        };
        chart.surface.suspendTracking = function() {
            ok(false);
        };
        chart._start(createEventArg());

        chart._unsetActivePoint = noop;
    });

    it("resumes surface tracking on end", () => {  
        chart._start(createEventArg());
        chart.surface.resumeTracking = function() {
            ok(true);
        };
        chart._end(createEventArg());
    });

    it("does not resume surface tracking on end if panning wasn't started", 0, () => {  
        pannable.start = function() {
            return false;
        };
        chart._start(createEventArg());
        chart.surface.resumeTracking = function() {
            ok(false);
        };
        chart._end(createEventArg());
    });

    it("triggers dragEnd with current ranges", 2, () => {  
        chart.bind("dragEnd", function(e) {
            const range = e.axisRanges.category;
            ok(range.min > 0);
            ok(range.max > 2);
        });

        chart._start(createEventArg());
        chart._move(createEventArg({
            x: {
                delta: -100
            }
        }));

        chart._end(createEventArg());
    });

    it("triggers dragEnd with current ranges if the panning results in no valid range", 2, () => {  
        chart.bind("dragEnd", function(e) {
            const range = e.axisRanges.category;
            equal(range.min, 0);
            equal(range.max, 2);
        });

        chart._start(createEventArg());
        chart._move(createEventArg({
            x: {
                delta: 100
            }
        }));

        chart._end(createEventArg());
    });
});

// ------------------------------------------------------------
describe('Pannable / destroy', () => {
    it("removes plotArea reference", () => {  
        pannable = new Pannable({});
        pannable.destroy();
        ok(!pannable.plotArea);
    });
});