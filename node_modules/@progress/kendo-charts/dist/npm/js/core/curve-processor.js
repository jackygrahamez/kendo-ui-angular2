module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(478);


/***/ },

/***/ 23:
/***/ function(module, exports) {

	module.exports = require("@progress/kendo-drawing");

/***/ },

/***/ 60:
/***/ function(module, exports) {

	module.exports = require("../common/constants");

/***/ },

/***/ 205:
/***/ function(module, exports) {

	module.exports = require("../common/last");

/***/ },

/***/ 474:
/***/ function(module, exports) {

	module.exports = require("../common/round");

/***/ },

/***/ 478:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _kendoDrawing = __webpack_require__(23);

	var _constants = __webpack_require__(60);

	var _last = __webpack_require__(205);

	var _last2 = _interopRequireDefault(_last);

	var _round = __webpack_require__(474);

	var _round2 = _interopRequireDefault(_round);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var WEIGHT = 0.333;
	var EXTREMUM_ALLOWED_DEVIATION = 0.01;

	var CurveProcessor = function () {
	    function CurveProcessor(closed) {
	        _classCallCheck(this, CurveProcessor);

	        this.closed = closed;
	    }

	    _createClass(CurveProcessor, [{
	        key: 'process',
	        value: function process(dataPoints) {
	            var points = dataPoints.slice(0);
	            var segments = [];
	            var closed = this.closed;
	            var length = points.length;

	            if (length > 2) {
	                this.removeDuplicates(0, points);
	                length = points.length;
	            }

	            if (length < 2 || length === 2 && points[0].equals(points[1])) {
	                return segments;
	            }

	            var p0 = points[0];
	            var p1 = points[1];
	            var p2 = points[2];

	            segments.push(new _kendoDrawing.geometry.Segment(p0));

	            while (p0.equals(points[length - 1])) {
	                closed = true;
	                points.pop();
	                length--;
	            }

	            if (length === 2) {
	                var tangent = this.tangent(p0, p1, _constants.X, _constants.Y);

	                (0, _last2.default)(segments).controlOut(this.firstControlPoint(tangent, p0, p1, _constants.X, _constants.Y));

	                segments.push(new _kendoDrawing.geometry.Segment(p1, this.secondControlPoint(tangent, p0, p1, _constants.X, _constants.Y)));

	                return segments;
	            }

	            var initialControlPoint = void 0,
	                lastControlPoint = void 0;

	            if (closed) {
	                p0 = points[length - 1];p1 = points[0];p2 = points[1];
	                var controlPoints = this.controlPoints(p0, p1, p2);
	                initialControlPoint = controlPoints[1];
	                lastControlPoint = controlPoints[0];
	            } else {
	                var _tangent = this.tangent(p0, p1, _constants.X, _constants.Y);
	                initialControlPoint = this.firstControlPoint(_tangent, p0, p1, _constants.X, _constants.Y);
	            }

	            var cp0 = initialControlPoint;
	            for (var idx = 0; idx <= length - 3; idx++) {
	                this.removeDuplicates(idx, points);
	                length = points.length;
	                if (idx + 3 <= length) {
	                    p0 = points[idx];p1 = points[idx + 1];p2 = points[idx + 2];
	                    var _controlPoints = this.controlPoints(p0, p1, p2);

	                    (0, _last2.default)(segments).controlOut(cp0);
	                    cp0 = _controlPoints[1];

	                    var cp1 = _controlPoints[0];
	                    segments.push(new _kendoDrawing.geometry.Segment(p1, cp1));
	                }
	            }

	            if (closed) {
	                p0 = points[length - 2];p1 = points[length - 1];p2 = points[0];
	                var _controlPoints2 = this.controlPoints(p0, p1, p2);

	                (0, _last2.default)(segments).controlOut(cp0);
	                segments.push(new _kendoDrawing.geometry.Segment(p1, _controlPoints2[0]));

	                (0, _last2.default)(segments).controlOut(_controlPoints2[1]);
	                segments.push(new _kendoDrawing.geometry.Segment(p2, lastControlPoint));
	            } else {
	                var _tangent2 = this.tangent(p1, p2, _constants.X, _constants.Y);

	                (0, _last2.default)(segments).controlOut(cp0);
	                segments.push(new _kendoDrawing.geometry.Segment(p2, this.secondControlPoint(_tangent2, p1, p2, _constants.X, _constants.Y)));
	            }

	            return segments;
	        }
	    }, {
	        key: 'removeDuplicates',
	        value: function removeDuplicates(idx, points) {
	            while (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2])) {
	                points.splice(idx + 1, 1);
	            }
	        }
	    }, {
	        key: 'invertAxis',
	        value: function invertAxis(p0, p1, p2) {
	            var invertAxis = false;

	            if (p0.x === p1.x) {
	                invertAxis = true;
	            } else if (p1.x === p2.x) {
	                if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {
	                    invertAxis = true;
	                }
	            } else {
	                var fn = this.lineFunction(p0, p1);
	                var y2 = this.calculateFunction(fn, p2.x);
	                if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {
	                    invertAxis = true;
	                }
	            }

	            return invertAxis;
	        }
	    }, {
	        key: 'isLine',
	        value: function isLine(p0, p1, p2) {
	            var fn = this.lineFunction(p0, p1);
	            var y2 = this.calculateFunction(fn, p2.x);

	            return p0.x === p1.x && p1.x === p2.x || (0, _round2.default)(y2, 1) === (0, _round2.default)(p2.y, 1);
	        }
	    }, {
	        key: 'lineFunction',
	        value: function lineFunction(p1, p2) {
	            var a = (p2.y - p1.y) / (p2.x - p1.x);
	            var b = p1.y - a * p1.x;

	            return [b, a];
	        }
	    }, {
	        key: 'controlPoints',
	        value: function controlPoints(p0, p1, p2) {
	            var xField = _constants.X;
	            var yField = _constants.Y;
	            var restrict = false;
	            var switchOrientation = false;
	            var tangent = void 0;

	            if (this.isLine(p0, p1, p2)) {
	                tangent = this.tangent(p0, p1, _constants.X, _constants.Y);
	            } else {
	                var monotonic = {
	                    x: this.isMonotonicByField(p0, p1, p2, _constants.X),
	                    y: this.isMonotonicByField(p0, p1, p2, _constants.Y)
	                };

	                if (monotonic.x && monotonic.y) {
	                    tangent = this.tangent(p0, p2, _constants.X, _constants.Y);
	                    restrict = true;
	                } else {
	                    if (this.invertAxis(p0, p1, p2)) {
	                        xField = _constants.Y;
	                        yField = _constants.X;
	                    }

	                    if (monotonic[xField]) {
	                        tangent = 0;
	                    } else {
	                        var sign = void 0;
	                        if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {
	                            sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));
	                        } else {
	                            sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));
	                        }

	                        tangent = EXTREMUM_ALLOWED_DEVIATION * sign;
	                        switchOrientation = true;
	                    }
	                }
	            }

	            var secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);

	            if (switchOrientation) {
	                var oldXField = xField;
	                xField = yField;
	                yField = oldXField;
	            }

	            var firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);

	            if (restrict) {
	                this.restrictControlPoint(p0, p1, secondControlPoint, tangent);
	                this.restrictControlPoint(p1, p2, firstControlPoint, tangent);
	            }

	            return [secondControlPoint, firstControlPoint];
	        }
	    }, {
	        key: 'restrictControlPoint',
	        value: function restrictControlPoint(p1, p2, cp, tangent) {
	            if (p1.y < p2.y) {
	                if (p2.y < cp.y) {
	                    cp.x = p1.x + (p2.y - p1.y) / tangent;
	                    cp.y = p2.y;
	                } else if (cp.y < p1.y) {
	                    cp.x = p2.x - (p2.y - p1.y) / tangent;
	                    cp.y = p1.y;
	                }
	            } else {
	                if (cp.y < p2.y) {
	                    cp.x = p1.x - (p1.y - p2.y) / tangent;
	                    cp.y = p2.y;
	                } else if (p1.y < cp.y) {
	                    cp.x = p2.x + (p1.y - p2.y) / tangent;
	                    cp.y = p1.y;
	                }
	            }
	        }
	    }, {
	        key: 'tangent',
	        value: function tangent(p0, p1, xField, yField) {
	            var x = p1[xField] - p0[xField];
	            var y = p1[yField] - p0[yField];
	            var tangent = void 0;

	            if (x === 0) {
	                tangent = 0;
	            } else {
	                tangent = y / x;
	            }

	            return tangent;
	        }
	    }, {
	        key: 'isMonotonicByField',
	        value: function isMonotonicByField(p0, p1, p2, field) {
	            return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];
	        }
	    }, {
	        key: 'firstControlPoint',
	        value: function firstControlPoint(tangent, p0, p3, xField, yField) {
	            var t1 = p0[xField];
	            var t2 = p3[xField];
	            var distance = (t2 - t1) * WEIGHT;

	            return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);
	        }
	    }, {
	        key: 'secondControlPoint',
	        value: function secondControlPoint(tangent, p0, p3, xField, yField) {
	            var t1 = p0[xField];
	            var t2 = p3[xField];
	            var distance = (t2 - t1) * WEIGHT;

	            return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);
	        }
	    }, {
	        key: 'point',
	        value: function point(xValue, yValue, xField, yField) {
	            var controlPoint = new _kendoDrawing.geometry.Point();
	            controlPoint[xField] = xValue;
	            controlPoint[yField] = yValue;

	            return controlPoint;
	        }
	    }, {
	        key: 'calculateFunction',
	        value: function calculateFunction(fn, x) {
	            var length = fn.length;
	            var result = 0;

	            for (var i = 0; i < length; i++) {
	                result += Math.pow(x, i) * fn[i];
	            }
	            return result;
	        }
	    }]);

	    return CurveProcessor;
	}();

	function numberSign(value) {
	    return value <= 0 ? -1 : 1;
	}

	exports.default = CurveProcessor;

/***/ }

/******/ });