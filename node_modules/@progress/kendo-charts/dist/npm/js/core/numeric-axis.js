module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(510);


/***/ },

/***/ 60:
/***/ function(module, exports) {

	module.exports = require("../common/constants");

/***/ },

/***/ 111:
/***/ function(module, exports) {

	module.exports = require("../common/set-default-options");

/***/ },

/***/ 112:
/***/ function(module, exports) {

	module.exports = require("../common/deep-extend");

/***/ },

/***/ 113:
/***/ function(module, exports) {

	module.exports = require("../common/defined");

/***/ },

/***/ 459:
/***/ function(module, exports) {

	module.exports = require("./axis-label");

/***/ },

/***/ 461:
/***/ function(module, exports) {

	module.exports = require("./box");

/***/ },

/***/ 473:
/***/ function(module, exports) {

	module.exports = require("./axis");

/***/ },

/***/ 474:
/***/ function(module, exports) {

	module.exports = require("../common/round");

/***/ },

/***/ 475:
/***/ function(module, exports) {

	module.exports = require("../common/limit-value");

/***/ },

/***/ 493:
/***/ function(module, exports) {

	module.exports = require("./utils/auto-major-unit");

/***/ },

/***/ 494:
/***/ function(module, exports) {

	module.exports = require("./utils/ceil");

/***/ },

/***/ 510:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _axis = __webpack_require__(473);

	var _axis2 = _interopRequireDefault(_axis);

	var _axisLabel = __webpack_require__(459);

	var _axisLabel2 = _interopRequireDefault(_axisLabel);

	var _box = __webpack_require__(461);

	var _box2 = _interopRequireDefault(_box);

	var _constants = __webpack_require__(60);

	var _setDefaultOptions = __webpack_require__(111);

	var _setDefaultOptions2 = _interopRequireDefault(_setDefaultOptions);

	var _deepExtend = __webpack_require__(112);

	var _deepExtend2 = _interopRequireDefault(_deepExtend);

	var _defined = __webpack_require__(113);

	var _defined2 = _interopRequireDefault(_defined);

	var _limitValue = __webpack_require__(475);

	var _limitValue2 = _interopRequireDefault(_limitValue);

	var _round = __webpack_require__(474);

	var _round2 = _interopRequireDefault(_round);

	var _autoMajorUnit = __webpack_require__(493);

	var _autoMajorUnit2 = _interopRequireDefault(_autoMajorUnit);

	var _autoAxisMin = __webpack_require__(511);

	var _autoAxisMin2 = _interopRequireDefault(_autoAxisMin);

	var _autoAxisMax = __webpack_require__(512);

	var _autoAxisMax2 = _interopRequireDefault(_autoAxisMax);

	var _floor = __webpack_require__(513);

	var _floor2 = _interopRequireDefault(_floor);

	var _ceil = __webpack_require__(494);

	var _ceil2 = _interopRequireDefault(_ceil);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var NumericAxis = function (_Axis) {
	    _inherits(NumericAxis, _Axis);

	    function NumericAxis(seriesMin, seriesMax, options) {
	        _classCallCheck(this, NumericAxis);

	        var autoOptions = autoAxisOptions(seriesMin, seriesMax, options);
	        var totalOptions = totalAxisOptions(autoOptions, options);

	        var _this = _possibleConstructorReturn(this, (NumericAxis.__proto__ || Object.getPrototypeOf(NumericAxis)).call(this, axisOptions(autoOptions, options)));

	        _this.totalMin = totalOptions.min;
	        _this.totalMax = totalOptions.max;
	        _this.totalMajorUnit = totalOptions.majorUnit;
	        _this.seriesMin = seriesMin;
	        _this.seriesMax = seriesMax;
	        return _this;
	    }

	    _createClass(NumericAxis, [{
	        key: 'startValue',
	        value: function startValue() {
	            return 0;
	        }
	    }, {
	        key: 'range',
	        value: function range() {
	            var options = this.options;
	            return { min: options.min, max: options.max };
	        }
	    }, {
	        key: 'getDivisions',
	        value: function getDivisions(stepValue) {
	            if (stepValue === 0) {
	                return 1;
	            }

	            var options = this.options;
	            var range = options.max - options.min;

	            return Math.floor((0, _round2.default)(range / stepValue, _constants.COORD_PRECISION)) + 1;
	        }
	    }, {
	        key: 'getTickPositions',
	        value: function getTickPositions(unit, skipUnit) {
	            var options = this.options;
	            var vertical = options.vertical;
	            var reverse = options.reverse;

	            var lineBox = this.lineBox();
	            var lineSize = vertical ? lineBox.height() : lineBox.width();
	            var range = options.max - options.min;
	            var scale = lineSize / range;
	            var step = unit * scale;
	            var divisions = this.getDivisions(unit);
	            var dir = (vertical ? -1 : 1) * (reverse ? -1 : 1);
	            var startEdge = dir === 1 ? 1 : 2;
	            var positions = [];
	            var pos = lineBox[(vertical ? _constants.Y : _constants.X) + startEdge];
	            var skipStep = 0;

	            if (skipUnit) {
	                skipStep = skipUnit / unit;
	            }

	            for (var idx = 0; idx < divisions; idx++) {
	                if (idx % skipStep !== 0) {
	                    positions.push((0, _round2.default)(pos, _constants.COORD_PRECISION));
	                }

	                pos = pos + step * dir;
	            }

	            return positions;
	        }
	    }, {
	        key: 'getMajorTickPositions',
	        value: function getMajorTickPositions() {
	            return this.getTickPositions(this.options.majorUnit);
	        }
	    }, {
	        key: 'getMinorTickPositions',
	        value: function getMinorTickPositions() {
	            return this.getTickPositions(this.options.minorUnit);
	        }
	    }, {
	        key: 'getSlot',
	        value: function getSlot(a, b) {
	            var limit = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

	            var options = this.options;
	            var vertical = options.vertical;
	            var reverse = options.reverse;

	            var valueAxis = vertical ? _constants.Y : _constants.X;
	            var lineBox = this.lineBox();
	            var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];
	            var lineSize = vertical ? lineBox.height() : lineBox.width();
	            var dir = reverse ? -1 : 1;
	            var step = dir * (lineSize / (options.max - options.min));
	            var slotBox = new _box2.default(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);

	            var start = a;
	            var end = b;

	            if (!(0, _defined2.default)(start)) {
	                start = end || 0;
	            }

	            if (!(0, _defined2.default)(end)) {
	                end = start || 0;
	            }

	            if (limit) {
	                start = Math.max(Math.min(start, options.max), options.min);
	                end = Math.max(Math.min(end, options.max), options.min);
	            }

	            var p1 = void 0,
	                p2 = void 0;

	            if (vertical) {
	                p1 = options.max - Math.max(start, end);
	                p2 = options.max - Math.min(start, end);
	            } else {
	                p1 = Math.min(start, end) - options.min;
	                p2 = Math.max(start, end) - options.min;
	            }

	            slotBox[valueAxis + 1] = lineStart + step * (reverse ? p2 : p1);
	            slotBox[valueAxis + 2] = lineStart + step * (reverse ? p1 : p2);

	            return slotBox;
	        }
	    }, {
	        key: 'getValue',
	        value: function getValue(point) {
	            var options = this.options;
	            var vertical = options.vertical;
	            var reverse = options.reverse;

	            var max = Number(options.max);
	            var min = Number(options.min);
	            var valueAxis = vertical ? _constants.Y : _constants.X;
	            var lineBox = this.lineBox();
	            var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];
	            var lineSize = vertical ? lineBox.height() : lineBox.width();
	            var dir = reverse ? -1 : 1;
	            var offset = dir * (point[valueAxis] - lineStart);
	            var step = (max - min) / lineSize;
	            var valueOffset = offset * step;

	            if (offset < 0 || offset > lineSize) {
	                return null;
	            }

	            var value = vertical ? max - valueOffset : min + valueOffset;

	            return (0, _round2.default)(value, _constants.DEFAULT_PRECISION);
	        }
	    }, {
	        key: 'translateRange',
	        value: function translateRange(delta) {
	            var options = this.options;
	            var vertical = options.vertical;
	            var reverse = options.reverse;
	            var max = options.max;
	            var min = options.min;

	            var lineBox = this.lineBox();
	            var size = vertical ? lineBox.height() : lineBox.width();
	            var range = max - min;
	            var scale = size / range;
	            var offset = (0, _round2.default)(delta / scale, _constants.DEFAULT_PRECISION);

	            if ((vertical || reverse) && !(vertical && reverse)) {
	                offset = -offset;
	            }

	            return {
	                min: min + offset,
	                max: max + offset
	            };
	        }
	    }, {
	        key: 'scaleRange',
	        value: function scaleRange(delta) {
	            var options = this.options;
	            var offset = -delta * options.majorUnit;

	            return {
	                min: options.min - offset,
	                max: options.max + offset
	            };
	        }
	    }, {
	        key: 'labelsCount',
	        value: function labelsCount() {
	            return this.getDivisions(this.options.majorUnit);
	        }
	    }, {
	        key: 'createAxisLabel',
	        value: function createAxisLabel(index, labelOptions) {
	            var options = this.options;
	            var value = (0, _round2.default)(options.min + index * options.majorUnit, _constants.DEFAULT_PRECISION);
	            var text = this.axisLabelText(value, null, labelOptions);

	            return new _axisLabel2.default(value, text, index, null, labelOptions);
	        }
	    }, {
	        key: 'shouldRenderNote',
	        value: function shouldRenderNote(value) {
	            var range = this.range();
	            return range.min <= value && value <= range.max;
	        }
	    }, {
	        key: 'pan',
	        value: function pan(delta) {
	            var range = this.translateRange(delta);
	            return this.limitRange(range.min, range.max, this.totalMin, this.totalMax);
	        }
	    }, {
	        key: 'pointsRange',
	        value: function pointsRange(start, end) {
	            var startValue = this.getValue(start);
	            var endValue = this.getValue(end);
	            var min = Math.min(startValue, endValue);
	            var max = Math.max(startValue, endValue);

	            return {
	                min: min,
	                max: max
	            };
	        }
	    }, {
	        key: 'zoomRange',
	        value: function zoomRange(delta) {
	            var totalMin = this.totalMin;
	            var totalMax = this.totalMax;

	            var newRange = this.scaleRange(delta);
	            var min = (0, _limitValue2.default)(newRange.min, totalMin, totalMax);
	            var max = (0, _limitValue2.default)(newRange.max, totalMin, totalMax);
	            var optionsRange = this.options.max - this.options.min;

	            if (optionsRange < this.totalMajorUnit || max - min >= this.totalMajorUnit) {
	                return {
	                    min: min,
	                    max: max
	                };
	            }
	        }
	    }]);

	    return NumericAxis;
	}(_axis2.default);

	function autoAxisOptions(seriesMin, seriesMax, options) {
	    var narrowRange = options.narrowRange;

	    var autoMin = (0, _autoAxisMin2.default)(seriesMin, seriesMax, narrowRange);
	    var autoMax = (0, _autoAxisMax2.default)(seriesMin, seriesMax, narrowRange);

	    var majorUnit = (0, _autoMajorUnit2.default)(autoMin, autoMax);
	    var autoOptions = {
	        majorUnit: majorUnit
	    };

	    if (options.roundToMajorUnit !== false) {
	        if (autoMin < 0 && remainderClose(autoMin, majorUnit, 1 / 3)) {
	            autoMin -= majorUnit;
	        }

	        if (autoMax > 0 && remainderClose(autoMax, majorUnit, 1 / 3)) {
	            autoMax += majorUnit;
	        }
	    }

	    autoOptions.min = (0, _floor2.default)(autoMin, majorUnit);
	    autoOptions.max = (0, _ceil2.default)(autoMax, majorUnit);

	    return autoOptions;
	}

	function totalAxisOptions(autoOptions, options) {
	    return {
	        min: (0, _defined2.default)(options.min) ? Math.min(autoOptions.min, options.min) : autoOptions.min,
	        max: (0, _defined2.default)(options.max) ? Math.max(autoOptions.max, options.max) : autoOptions.max,
	        majorUnit: autoOptions.majorUnit
	    };
	}

	function axisOptions(autoOptions, options) {
	    var axisOptions = options;
	    if (options) {
	        var userSetLimits = (0, _defined2.default)(options.min) || (0, _defined2.default)(options.max);
	        if (userSetLimits) {
	            if (options.min === options.max) {
	                if (options.min > 0) {
	                    options.min = 0;
	                } else {
	                    options.max = 1;
	                }
	            }
	        }

	        if (options.majorUnit) {
	            autoOptions.min = (0, _floor2.default)(autoOptions.min, options.majorUnit);
	            autoOptions.max = (0, _ceil2.default)(autoOptions.max, options.majorUnit);
	        } else if (userSetLimits) {
	            axisOptions = (0, _deepExtend2.default)(autoOptions, options);

	            // Determine an auto major unit after min/max have been set
	            autoOptions.majorUnit = (0, _autoMajorUnit2.default)(axisOptions.min, axisOptions.max);
	        }
	    }

	    autoOptions.minorUnit = (axisOptions.majorUnit || autoOptions.majorUnit) / 5;

	    return (0, _deepExtend2.default)(autoOptions, axisOptions);
	}

	function remainderClose(value, divisor, ratio) {
	    var remainder = (0, _round2.default)(Math.abs(value % divisor), _constants.DEFAULT_PRECISION);
	    var threshold = divisor * (1 - ratio);

	    return remainder === 0 || remainder > threshold;
	}

	(0, _setDefaultOptions2.default)(NumericAxis.prototype, {
	    type: "numeric",
	    min: 0,
	    max: 1,
	    vertical: true,
	    majorGridLines: {
	        visible: true,
	        width: 1,
	        color: _constants.BLACK
	    },
	    labels: {
	        format: "#.####################"
	    },
	    zIndex: 1
	});

	exports.default = NumericAxis;

/***/ },

/***/ 511:
/***/ function(module, exports) {

	module.exports = require("./utils/auto-axis-min");

/***/ },

/***/ 512:
/***/ function(module, exports) {

	module.exports = require("./utils/auto-axis-max");

/***/ },

/***/ 513:
/***/ function(module, exports) {

	module.exports = require("./utils/floor");

/***/ }

/******/ });