module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(497);


/***/ },

/***/ 60:
/***/ function(module, exports) {

	module.exports = require("../common/constants");

/***/ },

/***/ 111:
/***/ function(module, exports) {

	module.exports = require("../common/set-default-options");

/***/ },

/***/ 112:
/***/ function(module, exports) {

	module.exports = require("../common/deep-extend");

/***/ },

/***/ 113:
/***/ function(module, exports) {

	module.exports = require("../common/defined");

/***/ },

/***/ 459:
/***/ function(module, exports) {

	module.exports = require("./axis-label");

/***/ },

/***/ 461:
/***/ function(module, exports) {

	module.exports = require("./box");

/***/ },

/***/ 462:
/***/ function(module, exports) {

	module.exports = require("./utils/create-axis-tick");

/***/ },

/***/ 463:
/***/ function(module, exports) {

	module.exports = require("./utils/create-axis-grid-line");

/***/ },

/***/ 468:
/***/ function(module, exports) {

	module.exports = require("../common/in-array");

/***/ },

/***/ 473:
/***/ function(module, exports) {

	module.exports = require("./axis");

/***/ },

/***/ 474:
/***/ function(module, exports) {

	module.exports = require("../common/round");

/***/ },

/***/ 475:
/***/ function(module, exports) {

	module.exports = require("../common/limit-value");

/***/ },

/***/ 497:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _axis = __webpack_require__(473);

	var _axis2 = _interopRequireDefault(_axis);

	var _axisLabel = __webpack_require__(459);

	var _axisLabel2 = _interopRequireDefault(_axisLabel);

	var _box = __webpack_require__(461);

	var _box2 = _interopRequireDefault(_box);

	var _createAxisTick = __webpack_require__(462);

	var _createAxisTick2 = _interopRequireDefault(_createAxisTick);

	var _createAxisGridLine = __webpack_require__(463);

	var _createAxisGridLine2 = _interopRequireDefault(_createAxisGridLine);

	var _constants = __webpack_require__(60);

	var _setDefaultOptions = __webpack_require__(111);

	var _setDefaultOptions2 = _interopRequireDefault(_setDefaultOptions);

	var _defined = __webpack_require__(113);

	var _defined2 = _interopRequireDefault(_defined);

	var _round = __webpack_require__(474);

	var _round2 = _interopRequireDefault(_round);

	var _inArray = __webpack_require__(468);

	var _inArray2 = _interopRequireDefault(_inArray);

	var _deepExtend = __webpack_require__(112);

	var _deepExtend2 = _interopRequireDefault(_deepExtend);

	var _limitValue = __webpack_require__(475);

	var _limitValue2 = _interopRequireDefault(_limitValue);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var DEFAULT_MAJOR_UNIT = 10;

	var LogarithmicAxis = function (_Axis) {
	    _inherits(LogarithmicAxis, _Axis);

	    function LogarithmicAxis(seriesMin, seriesMax, options) {
	        _classCallCheck(this, LogarithmicAxis);

	        var axisOptions = (0, _deepExtend2.default)({ majorUnit: DEFAULT_MAJOR_UNIT, min: seriesMin, max: seriesMax }, options);
	        var base = axisOptions.majorUnit;
	        var autoMax = autoAxisMax(seriesMax, base);
	        var autoMin = autoAxisMin(seriesMin, seriesMax, axisOptions);
	        var range = initRange(autoMin, autoMax, axisOptions, options);

	        axisOptions.max = range.max;
	        axisOptions.min = range.min;
	        axisOptions.minorUnit = options.minorUnit || (0, _round2.default)(base - 1, _constants.DEFAULT_PRECISION);

	        var _this = _possibleConstructorReturn(this, (LogarithmicAxis.__proto__ || Object.getPrototypeOf(LogarithmicAxis)).call(this, axisOptions));

	        _this.totalMin = (0, _defined2.default)(options.min) ? Math.min(autoMin, options.min) : autoMin;
	        _this.totalMax = (0, _defined2.default)(options.max) ? Math.max(autoMax, options.max) : autoMax;
	        _this.logMin = (0, _round2.default)(log(range.min, base), _constants.DEFAULT_PRECISION);
	        _this.logMax = (0, _round2.default)(log(range.max, base), _constants.DEFAULT_PRECISION);
	        _this.seriesMin = seriesMin;
	        _this.seriesMax = seriesMax;

	        _this.createLabels();
	        return _this;
	    }

	    _createClass(LogarithmicAxis, [{
	        key: 'startValue',
	        value: function startValue() {
	            return this.options.min;
	        }
	    }, {
	        key: 'getSlot',
	        value: function getSlot(a, b, limit) {
	            var options = this.options;
	            var logMin = this.logMin;
	            var logMax = this.logMax;
	            var reverse = options.reverse;
	            var vertical = options.vertical;
	            var base = options.majorUnit;

	            var valueAxis = vertical ? _constants.Y : _constants.X;
	            var lineBox = this.lineBox();
	            var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];
	            var lineSize = vertical ? lineBox.height() : lineBox.width();
	            var dir = reverse ? -1 : 1;
	            var step = dir * (lineSize / (logMax - logMin));
	            var slotBox = new _box2.default(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);
	            var start = a;
	            var end = b;

	            if (!(0, _defined2.default)(start)) {
	                start = end || 1;
	            }

	            if (!(0, _defined2.default)(end)) {
	                end = start || 1;
	            }

	            if (start <= 0 || end <= 0) {
	                return null;
	            }

	            if (limit) {
	                start = Math.max(Math.min(start, options.max), options.min);
	                end = Math.max(Math.min(end, options.max), options.min);
	            }

	            start = log(start, base);
	            end = log(end, base);

	            var p1 = void 0,
	                p2 = void 0;

	            if (vertical) {
	                p1 = logMax - Math.max(start, end);
	                p2 = logMax - Math.min(start, end);
	            } else {
	                p1 = Math.min(start, end) - logMin;
	                p2 = Math.max(start, end) - logMin;
	            }

	            slotBox[valueAxis + 1] = lineStart + step * (reverse ? p2 : p1);
	            slotBox[valueAxis + 2] = lineStart + step * (reverse ? p1 : p2);

	            return slotBox;
	        }
	    }, {
	        key: 'getValue',
	        value: function getValue(point) {
	            var options = this.options;
	            var logMin = this.logMin;
	            var logMax = this.logMax;
	            var reverse = options.reverse;
	            var vertical = options.vertical;
	            var base = options.majorUnit;

	            var lineBox = this.lineBox();
	            var dir = vertical === reverse ? 1 : -1;
	            var startEdge = dir === 1 ? 1 : 2;
	            var lineSize = vertical ? lineBox.height() : lineBox.width();
	            var step = (logMax - logMin) / lineSize;
	            var valueAxis = vertical ? _constants.Y : _constants.X;
	            var lineStart = lineBox[valueAxis + startEdge];
	            var offset = dir * (point[valueAxis] - lineStart);
	            var valueOffset = offset * step;

	            if (offset < 0 || offset > lineSize) {
	                return null;
	            }

	            var value = logMin + valueOffset;

	            return (0, _round2.default)(Math.pow(base, value), _constants.DEFAULT_PRECISION);
	        }
	    }, {
	        key: 'range',
	        value: function range() {
	            var options = this.options;
	            return { min: options.min, max: options.max };
	        }
	    }, {
	        key: 'scaleRange',
	        value: function scaleRange(delta) {
	            var base = this.options.majorUnit;
	            var offset = -delta;

	            return {
	                min: Math.pow(base, this.logMin - offset),
	                max: Math.pow(base, this.logMax + offset)
	            };
	        }
	    }, {
	        key: 'translateRange',
	        value: function translateRange(delta) {
	            var options = this.options;
	            var logMin = this.logMin;
	            var logMax = this.logMax;
	            var reverse = options.reverse;
	            var vertical = options.vertical;
	            var base = options.majorUnit;

	            var lineBox = this.lineBox();
	            var size = vertical ? lineBox.height() : lineBox.width();
	            var scale = size / (logMax - logMin);
	            var offset = (0, _round2.default)(delta / scale, _constants.DEFAULT_PRECISION);

	            if ((vertical || reverse) && !(vertical && reverse)) {
	                offset = -offset;
	            }

	            return {
	                min: Math.pow(base, logMin + offset),
	                max: Math.pow(base, logMax + offset)
	            };
	        }
	    }, {
	        key: 'labelsCount',
	        value: function labelsCount() {
	            var floorMax = Math.floor(this.logMax);
	            var count = Math.floor(floorMax - this.logMin) + 1;

	            return count;
	        }
	    }, {
	        key: 'getMajorTickPositions',
	        value: function getMajorTickPositions() {
	            var ticks = [];

	            this.traverseMajorTicksPositions(function (position) {
	                ticks.push(position);
	            }, { step: 1, skip: 0 });

	            return ticks;
	        }
	    }, {
	        key: 'createTicks',
	        value: function createTicks(lineGroup) {
	            var options = this.options;
	            var majorTicks = options.majorTicks;
	            var minorTicks = options.minorTicks;
	            var vertical = options.vertical;

	            var mirror = options.labels.mirror;
	            var lineBox = this.lineBox();
	            var ticks = [];
	            var tickLineOptions = {
	                // TODO
	                // _alignLines: options._alignLines,
	                vertical: vertical
	            };

	            function render(tickPosition, tickOptions) {
	                tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
	                tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
	                tickLineOptions.position = tickPosition;

	                lineGroup.append((0, _createAxisTick2.default)(tickLineOptions, tickOptions));
	            }

	            if (majorTicks.visible) {
	                this.traverseMajorTicksPositions(render, majorTicks);
	            }

	            if (minorTicks.visible) {
	                this.traverseMinorTicksPositions(render, minorTicks);
	            }

	            return ticks;
	        }
	    }, {
	        key: 'createGridLines',
	        value: function createGridLines(altAxis) {
	            var options = this.options;
	            var minorGridLines = options.minorGridLines;
	            var majorGridLines = options.majorGridLines;
	            var vertical = options.vertical;

	            var lineBox = altAxis.lineBox();
	            var lineOptions = {
	                lineStart: lineBox[vertical ? "x1" : "y1"],
	                lineEnd: lineBox[vertical ? "x2" : "y2"],
	                vertical: vertical
	            };
	            var majorTicks = [];

	            var container = this.gridLinesVisual();
	            function render(tickPosition, gridLine) {
	                if (!(0, _inArray2.default)(tickPosition, majorTicks)) {
	                    lineOptions.position = tickPosition;
	                    container.append((0, _createAxisGridLine2.default)(lineOptions, gridLine));

	                    majorTicks.push(tickPosition);
	                }
	            }

	            if (majorGridLines.visible) {
	                this.traverseMajorTicksPositions(render, majorGridLines);
	            }

	            if (minorGridLines.visible) {
	                this.traverseMinorTicksPositions(render, minorGridLines);
	            }

	            return container.children;
	        }
	    }, {
	        key: 'traverseMajorTicksPositions',
	        value: function traverseMajorTicksPositions(callback, tickOptions) {
	            var _lineOptions2 = this._lineOptions();

	            var lineStart = _lineOptions2.lineStart;
	            var step = _lineOptions2.step;
	            var logMin = this.logMin;
	            var logMax = this.logMax;


	            for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {
	                var position = (0, _round2.default)(lineStart + step * (power - logMin), _constants.DEFAULT_PRECISION);
	                callback(position, tickOptions);
	            }
	        }
	    }, {
	        key: 'traverseMinorTicksPositions',
	        value: function traverseMinorTicksPositions(callback, tickOptions) {
	            var _options = this.options;
	            var min = _options.min;
	            var max = _options.max;
	            var minorUnit = _options.minorUnit;
	            var base = _options.majorUnit;

	            var _lineOptions3 = this._lineOptions();

	            var lineStart = _lineOptions3.lineStart;
	            var lineStep = _lineOptions3.lineStep;
	            var logMin = this.logMin;
	            var logMax = this.logMax;

	            var start = Math.floor(logMin);

	            for (var power = start; power < logMax; power++) {
	                var minorOptions = this._minorIntervalOptions(power);
	                for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {
	                    var value = minorOptions.value + idx * minorOptions.minorStep;
	                    if (value > max) {
	                        break;
	                    }
	                    if (value >= min) {
	                        var position = (0, _round2.default)(lineStart + lineStep * (log(value, base) - logMin), _constants.DEFAULT_PRECISION);
	                        callback(position, tickOptions);
	                    }
	                }
	            }
	        }
	    }, {
	        key: 'createAxisLabel',
	        value: function createAxisLabel(index, labelOptions) {
	            var power = Math.ceil(this.logMin + index);
	            var value = Math.pow(this.options.majorUnit, power);
	            var text = this.axisLabelText(value, null, labelOptions);

	            return new _axisLabel2.default(value, text, index, null, labelOptions);
	        }
	    }, {
	        key: 'shouldRenderNote',
	        value: function shouldRenderNote(value) {
	            var range = this.range();
	            return range.min <= value && value <= range.max;
	        }
	    }, {
	        key: 'pan',
	        value: function pan(delta) {
	            var range = this.translateRange(delta);
	            return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, -delta);
	        }
	    }, {
	        key: 'pointsRange',
	        value: function pointsRange(start, end) {
	            var startValue = this.getValue(start);
	            var endValue = this.getValue(end);
	            var min = Math.min(startValue, endValue);
	            var max = Math.max(startValue, endValue);

	            return {
	                min: min,
	                max: max
	            };
	        }
	    }, {
	        key: 'zoomRange',
	        value: function zoomRange(delta) {
	            var options = this.options;
	            var totalMin = this.totalMin;
	            var totalMax = this.totalMax;

	            var newRange = this.scaleRange(delta);
	            var min = (0, _limitValue2.default)(newRange.min, totalMin, totalMax);
	            var max = (0, _limitValue2.default)(newRange.max, totalMin, totalMax);
	            var base = options.majorUnit;
	            var acceptOptionsRange = max > min && options.min && options.max && (0, _round2.default)(log(options.max, base) - log(options.min, base), _constants.DEFAULT_PRECISION) < 1;
	            var acceptNewRange = !(options.min === totalMin && options.max === totalMax) && (0, _round2.default)(log(max, base) - log(min, base), _constants.DEFAULT_PRECISION) >= 1;

	            if (acceptOptionsRange || acceptNewRange) {
	                return {
	                    min: min,
	                    max: max
	                };
	            }
	        }
	    }, {
	        key: '_minorIntervalOptions',
	        value: function _minorIntervalOptions(power) {
	            var _options2 = this.options;
	            var minorUnit = _options2.minorUnit;
	            var base = _options2.majorUnit;

	            var value = Math.pow(base, power);
	            var nextValue = Math.pow(base, power + 1);
	            var difference = nextValue - value;
	            var minorStep = difference / minorUnit;

	            return {
	                value: value,
	                minorStep: minorStep
	            };
	        }
	    }, {
	        key: '_lineOptions',
	        value: function _lineOptions() {
	            var _options3 = this.options;
	            var reverse = _options3.reverse;
	            var vertical = _options3.vertical;

	            var valueAxis = vertical ? _constants.Y : _constants.X;
	            var lineBox = this.lineBox();
	            var dir = vertical === reverse ? 1 : -1;
	            var startEdge = dir === 1 ? 1 : 2;
	            var lineSize = vertical ? lineBox.height() : lineBox.width();
	            var step = dir * (lineSize / (this.logMax - this.logMin));
	            var lineStart = lineBox[valueAxis + startEdge];

	            return {
	                step: step,
	                lineStart: lineStart,
	                lineBox: lineBox
	            };
	        }
	    }]);

	    return LogarithmicAxis;
	}(_axis2.default);

	function initRange(autoMin, autoMax, axisOptions, options) {
	    var min = axisOptions.min;
	    var max = axisOptions.max;


	    if ((0, _defined2.default)(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {
	        throwNegativeValuesError();
	    }

	    if (!(0, _defined2.default)(options.max)) {
	        max = autoMax;
	    } else if (options.max <= 0) {
	        throwNegativeValuesError();
	    }

	    if (!(0, _defined2.default)(options.min)) {
	        min = autoMin;
	    } else if (options.min <= 0) {
	        throwNegativeValuesError();
	    }

	    return {
	        min: min,
	        max: max
	    };
	}

	function autoAxisMin(min, max, options) {
	    var base = options.majorUnit;
	    var autoMin = min;
	    if (min <= 0) {
	        autoMin = max <= 1 ? Math.pow(base, -2) : 1;
	    } else if (!options.narrowRange) {
	        autoMin = Math.pow(base, Math.floor(log(min, base)));
	    }
	    return autoMin;
	}

	function autoAxisMax(max, base) {
	    var logMaxRemainder = (0, _round2.default)(log(max, base), _constants.DEFAULT_PRECISION) % 1;
	    var autoMax = void 0;
	    if (max <= 0) {
	        autoMax = base;
	    } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {
	        autoMax = Math.pow(base, log(max, base) + 0.2);
	    } else {
	        autoMax = Math.pow(base, Math.ceil(log(max, base)));
	    }

	    return autoMax;
	}

	function throwNegativeValuesError() {
	    throw new Error("Non positive values cannot be used for a logarithmic axis");
	}

	function log(y, x) {
	    return Math.log(y) / Math.log(x);
	}

	(0, _setDefaultOptions2.default)(LogarithmicAxis.prototype, {
	    type: "log",
	    majorUnit: DEFAULT_MAJOR_UNIT,
	    minorUnit: 1,
	    axisCrossingValue: 1,
	    vertical: true,
	    majorGridLines: {
	        visible: true,
	        width: 1,
	        color: _constants.BLACK
	    },
	    zIndex: 1,
	    _deferLabels: true
	});

	exports.default = LogarithmicAxis;

/***/ }

/******/ });