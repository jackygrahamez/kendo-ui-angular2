import 'core-js/es6';

import { Ring, Box, Point } from '../../src/core';
import RadarBarChart from '../../src/chart/radar-bar-chart/radar-bar-chart';
import categoriesCount from '../../src/chart/utils/categories-count';
import RadarClusterLayout from '../../src/chart/radar-cluster-layout';
import RadarStackLayout from '../../src/chart/radar-stack-layout';
import { deepExtend, map } from '../../src/common';

import { ok, equal } from '../../test/test-helpers';
import { createChart, destroyChart }  from '../test-helpers';
import '../../test/text-measure';
import '../../test/intl';

const chartBox = new Box(0, 0, 800, 600);
let series;

function SegmentStub(sector) {
    this.sector = sector.clone();
}

SegmentStub.prototype = {
    reflow: function(sector) {
        this.sector = sector.clone();
    }
};


(function() {
    let cluster, s1, s2;

    function createCluster(options) {
        const segmentSector = new Ring(new Point(0, 0), 0, 10, 90, 90),
        segments = [ new SegmentStub(segmentSector), new SegmentStub(segmentSector) ];

        cluster = new RadarClusterLayout(options);
        [].push.apply(cluster.children, segments);
        cluster.reflow(new Ring(new Point(0, 0), 0, 100, 90, 90));

        s1 = segments[0].sector;
        s2 = segments[1].sector;
    }

    // ------------------------------------------------------------
    describe('Cluster Layout', () => {
        beforeEach(() => {
            createCluster({ gap: 0 });
        });

        it("retains children radius", () => {
            equal(s1.radius, 10);
            equal(s2.radius, 10);
        });

        it("distributes width evenly", () => {
            equal(s1.angle, 45);
            equal(s2.angle, 45);
        });

        it("positions children next to each other", () => {
            equal(s1.startAngle, 90);
            equal(s2.startAngle, 135);
        });

        it("leaves 50% gap on both sides", () => {
            createCluster({ gap: 1 });

            equal(s1.startAngle, 105);
            equal(s2.startAngle + s2.angle, 165);
        });

        it("positions children next to each other with spacing", () => {
            createCluster({ gap: 0, spacing: 1 });

            equal(s1.startAngle + s1.angle, 120);
            equal(s2.startAngle, 150);
        });
    });

})();

(function() {
    let stack, segments, s1, s2;

    function createStack(options) {
        segments = [ new SegmentStub(new Ring(new Point(0, 0), 0, 10, 90, 90)),
                     new SegmentStub(new Ring(new Point(0, 0), 10, 20, 90, 90)) ];

        stack = new RadarStackLayout(options);
        [].push.apply(stack.children, segments);

        stack.reflow(new Ring(new Point(0, 0), 10, 100, 110, 70));

        s1 = segments[0].sector;
        s2 = segments[1].sector;
    }

    // ------------------------------------------------------------
    describe('Stack Layout', () => {
        beforeEach(() => {
            createStack();
        });

        it("first sector radius is not changed", () => {
            equal(s1.radius, 10);
        });

        it("first sector inner radius is not changed", () => {
            equal(s1.innerRadius, 0);
        });

        it("first sector is fitted in sector segment", () => {
            equal(s1.startAngle, 110);
            equal(s1.angle, 70);
        });

        it("second sector is fitted in sector segment", () => {
            equal(s1.startAngle, 110);
            equal(s1.angle, 70);
        });

        it("second sector radius is not changed", () => {
            equal(s2.radius, 20);
        });

        it("second sector inner radius not changed", () => {
            equal(s2.innerRadius, 10);
        });
    });

    // ------------------------------------------------------------
    describe('Stack Layout / Inverted', () => {
        beforeEach(() => {
            createStack({ isReversed: true });
        });

        it("first sector radius is not changed", () => {
            equal(s1.radius, 10);
        });

        it("first sector inner radius is not changed", () => {
            equal(s1.innerRadius, 0);
        });

        it("first sector is fitted in sector segment", () => {
            equal(s1.startAngle, 110);
            equal(s1.angle, 70);
        });

        it("second sector radius is not changed", () => {
            equal(s2.radius, 20);
        });

        it("second sector inner radius is not changed", () => {
            equal(s2.innerRadius, 10);
        });

        it("second sector is fitted in sector segment", () => {
            equal(s1.startAngle, 110);
            equal(s1.angle, 70);
        });
    });
})();

(function() {
    let chart, barChart;

    function createRadarBarChart(series, options) {
        chart = createChart(deepExtend({
            series: series,
            transitions: false,
            chartArea: {
                height: 400
            }
        }, options));

        barChart = chart._plotArea.charts[0];
    }

    const positiveSeries = {
        type: "radarColumn",
        data: [1, 2]
    };

    // ------------------------------------------------------------
    describe('Radar Bar Chart / Rendering', () => {
        beforeEach(() => {
            createRadarBarChart([positiveSeries]);
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("radius is set according to value", () => {
            equal(map(barChart.points, function(point) { return point.sector.radius; }), [68.25, 136.5]);
        });

        it("inner radius is set 0", () => {
            equal(map(barChart.points, function(point) { return point.sector.innerRadius; }), [0, 0]);
        });
    });

    // ------------------------------------------------------------
    describe('Radar Bar Chart / Stacked / Rendering', () => {
        beforeEach(() => {
            const stackedSeries = {
                type: "radarColumn",
                data: [1, 2],
                stack: true
            };

            createRadarBarChart([stackedSeries, stackedSeries]);
        });

        afterEach(() => {
            destroyChart(chart);
        });


        it("radius is set according to stacked value", () => {
            equal(map(barChart.points, function(point) { return point.sector.radius; }),
                      [34.125,68.25,68.25,136.5]);
        });

        it("inner radius is set according to prev value", () => {
            equal(map(barChart.points, function(point) { return point.sector.innerRadius; }), [0, 34.125, 0, 68.25]);
        });
    });
})();

// ------------------------------------------------------------
describe('RadarBar Chart / Values exceeding axis min or max options ', () => {

    it("values are limited", 2, () => {
        const plotArea = {
            categoryAxis:  {
                getSlot: function() {
                     return new Ring(new Point());
                },
                lineBox: function() {
                    return new Box(0,2,2,2);
                },
                options: {
                    categories: ["A", "B"]
                }
            },
            valueAxis: {
                getSlot: function(a,b, limit) {
                    ok(limit);
                    return new Box();
                },
                options: {
                    axisCrossingValue: 0
                },
                startValue: function() {
                    return 0;
                }
            },
            seriesCategoryAxis: function() {
                return plotArea.categoryAxis;
            }
        };

        const chart = new RadarBarChart(plotArea, {series: [{
            type: "radarColumn",
            data: [1,2]
        }]});

        chart.reflow();
    });
});
