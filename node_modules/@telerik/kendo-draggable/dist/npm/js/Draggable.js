module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var proxy = function proxy(a, b) {
	    return function (e) {
	        return b(a(e));
	    };
	};

	var bind = function bind(el, event, callback) {
	    return el.addEventListener(event, callback);
	};

	var unbind = function unbind(el, event, callback) {
	    return el.removeEventListener(event, callback);
	};

	var touchRegExp = /touch/;

	function normalizeEvent(e) {
	    if (e.type.match(touchRegExp)) {
	        return {
	            pageX: e.changedTouches[0].pageX,
	            pageY: e.changedTouches[0].pageY,
	            type: e.type,
	            originalEvent: e
	        };
	    }

	    return {
	        pageX: e.pageX,
	        pageY: e.pageY,
	        type: e.type,
	        ctrlKey: e.ctrlKey,
	        shiftKey: e.shiftKey,
	        altKey: e.altKey,
	        originalEvent: e
	    };
	}

	var noop = function noop() {};

	// 300ms is the usual mouse interval;
	// However, an underpowered mobile device under a heavy load may queue mouse events for a longer period.
	var IGNORE_MOUSE_TIMEOUT = 2000;

	var Draggable = function () {
	    function Draggable(_ref) {
	        var _this = this;

	        var _ref$press = _ref.press;
	        var press = _ref$press === undefined ? noop : _ref$press;
	        var _ref$drag = _ref.drag;
	        var drag = _ref$drag === undefined ? noop : _ref$drag;
	        var _ref$release = _ref.release;
	        var release = _ref$release === undefined ? noop : _ref$release;

	        _classCallCheck(this, Draggable);

	        this._touchstart = function (e) {
	            if (e.touches.length === 1) {
	                _this._pressHandler(e);
	            }
	        };

	        this._touchmove = function (e) {
	            if (e.touches.length === 1) {
	                _this._dragHandler(e);
	            }
	        };

	        this._touchend = function (e) {
	            // the last finger has been lifted, and the user is not doing gesture.
	            // there might be a better way to handle this.
	            if (e.touches.length === 0 && e.changedTouches.length === 1) {
	                _this._releaseHandler(e);
	                _this._ignoreMouse = true;
	                setTimeout(_this._restoreMouse, IGNORE_MOUSE_TIMEOUT);
	            }
	        };

	        this._restoreMouse = function () {
	            _this._ignoreMouse = false;
	        };

	        this._mousedown = function (e) {
	            var which = e.which;


	            if (which && which > 1 || _this._ignoreMouse) {
	                return;
	            }

	            bind(document, "mousemove", _this._mousemove);
	            bind(document, "mouseup", _this._mouseup);
	            _this._pressHandler(e);
	        };

	        this._mousemove = function (e) {
	            _this._dragHandler(e);
	        };

	        this._mouseup = function (e) {
	            unbind(document, "mousemove", _this._mousemove);
	            unbind(document, "mouseup", _this._mouseup);
	            _this._releaseHandler(e);
	        };

	        this._pressHandler = proxy(normalizeEvent, press);
	        this._dragHandler = proxy(normalizeEvent, drag);
	        this._releaseHandler = proxy(normalizeEvent, release);

	        this._ignoreMouse = false;
	    }

	    _createClass(Draggable, [{
	        key: "bindTo",
	        value: function bindTo(element) {
	            if (element === this._element) {
	                return;
	            }

	            if (this._element) {
	                this._unbindFromCurrent();
	            }

	            this._element = element;

	            bind(element, "mousedown", this._mousedown);
	            bind(element, "touchstart", this._touchstart);
	            bind(element, "touchmove", this._touchmove);
	            bind(element, "touchend", this._touchend);
	        }
	    }, {
	        key: "_unbindFromCurrent",
	        value: function _unbindFromCurrent() {
	            unbind(this._element, "mousedown", this._mousedown);
	            unbind(this._element, "touchstart", this._touchstart);
	            unbind(this._element, "touchmove", this._touchmove);
	            unbind(this._element, "touchend", this._touchend);
	        }
	    }, {
	        key: "destroy",
	        value: function destroy() {
	            this._unbindFromCurrent();
	            this._element = null;
	        }
	    }]);

	    return Draggable;
	}();

	exports.default = Draggable;

/***/ }
/******/ ]);