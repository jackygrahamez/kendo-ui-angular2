module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(117);


/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */
/***/ function(module, exports) {

	module.exports = require("@progress/kendo-drawing");

/***/ },
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */
/***/ function(module, exports) {

	module.exports = require("./api-elements/chart-axis");

/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = require("./api-elements/chart-pane");

/***/ },
/* 34 */
/***/ function(module, exports) {

	module.exports = require("./api-elements/chart-series");

/***/ },
/* 35 */
/***/ function(module, exports) {

	module.exports = require("./api-elements/chart-plotarea");

/***/ },
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */
/***/ function(module, exports) {

	module.exports = require("../common/constants");

/***/ },
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */
/***/ function(module, exports) {

	module.exports = require("./series-binder");

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = require("./constants");

/***/ },
/* 108 */,
/* 109 */,
/* 110 */
/***/ function(module, exports) {

	module.exports = require("../core");

/***/ },
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _kendoDrawing = __webpack_require__(23);

	var _core = __webpack_require__(110);

	var _exportMixin = __webpack_require__(118);

	var _exportMixin2 = _interopRequireDefault(_exportMixin);

	var _highlight = __webpack_require__(119);

	var _highlight2 = _interopRequireDefault(_highlight);

	var _chartPlotarea = __webpack_require__(35);

	var _chartPlotarea2 = _interopRequireDefault(_chartPlotarea);

	var _chartPane = __webpack_require__(33);

	var _chartPane2 = _interopRequireDefault(_chartPane);

	var _chartAxis = __webpack_require__(32);

	var _chartAxis2 = _interopRequireDefault(_chartAxis);

	var _chartSeries = __webpack_require__(34);

	var _chartSeries2 = _interopRequireDefault(_chartSeries);

	var _pannable = __webpack_require__(120);

	var _pannable2 = _interopRequireDefault(_pannable);

	var _zoomSelection = __webpack_require__(121);

	var _zoomSelection2 = _interopRequireDefault(_zoomSelection);

	var _mousewheelZoom = __webpack_require__(122);

	var _mousewheelZoom2 = _interopRequireDefault(_mousewheelZoom);

	var _legend = __webpack_require__(123);

	var _legend2 = _interopRequireDefault(_legend);

	var _plotareaFactory = __webpack_require__(124);

	var _plotareaFactory2 = _interopRequireDefault(_plotareaFactory);

	var _selection = __webpack_require__(125);

	var _selection2 = _interopRequireDefault(_selection);

	var _chartEvents = __webpack_require__(126);

	var _chartEvents2 = _interopRequireDefault(_chartEvents);

	var _seriesBinder = __webpack_require__(106);

	var _seriesBinder2 = _interopRequireDefault(_seriesBinder);

	var _tooltip = __webpack_require__(127);

	var _tooltip2 = _interopRequireDefault(_tooltip);

	var _sharedTooltip2 = __webpack_require__(128);

	var _sharedTooltip3 = _interopRequireDefault(_sharedTooltip2);

	var _categoricalPlotarea = __webpack_require__(129);

	var _categoricalPlotarea2 = _interopRequireDefault(_categoricalPlotarea);

	var _plotareaBase = __webpack_require__(130);

	var _plotareaBase2 = _interopRequireDefault(_plotareaBase);

	var _getField = __webpack_require__(131);

	var _getField2 = _interopRequireDefault(_getField);

	var _getDateField = __webpack_require__(132);

	var _getDateField2 = _interopRequireDefault(_getDateField);

	var _isDateAxis = __webpack_require__(133);

	var _isDateAxis2 = _interopRequireDefault(_isDateAxis);

	var _constants = __webpack_require__(60);

	var _common = __webpack_require__(134);

	var _dateUtils = __webpack_require__(135);

	var _constants2 = __webpack_require__(107);

	__webpack_require__(136);

	__webpack_require__(137);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var AXIS_NAMES = [_constants2.CATEGORY, _constants.VALUE, _constants.X, _constants.Y];

	var MOUSEMOVE = "mousemove";
	var CONTEXTMENU = "contextmenu";
	var SHOW_TOOLTIP = "showTooltip";
	var HIDE_TOOLTIP = "hideTooltip";

	var MOUSEMOVE_DELAY = 20;

	var Chart = function (_Observable) {
	    _inherits(Chart, _Observable);

	    function Chart(element, userOptions, themeOptions) {
	        _classCallCheck(this, Chart);

	        // kendo.destroy(element);

	        // Widget.fn.init.call(chart, element);

	        var _this = _possibleConstructorReturn(this, (Chart.__proto__ || Object.getPrototypeOf(Chart)).call(this));

	        _this.element = element;
	        (0, _common.addClass)(element, "k-chart");
	        element.style.position = "relative";

	        // if (userOptions) {
	        // dataSource = userOptions.dataSource;
	        // userOptions.dataSource = undefined;
	        // }

	        var options = (0, _common.deepExtend)({}, _this.options, userOptions);
	        _this._originalOptions = (0, _common.deepExtend)({}, options);
	        _this._theme = themeOptions;
	        _this._initTheme(options, themeOptions);

	        _this._initSurface();

	        _this.bind(_this.events, _this.options);

	        _this.wrapper = _this.element;

	        _this._initHandlers();

	        // if (userOptions) {
	        // userOptions.dataSource = dataSource;
	        // }

	        // chart._initDataSource(userOptions);
	        _this._bindCategories();
	        _common.FontLoader.preloadFonts(userOptions, function () {
	            _this._redraw();
	            _this._attachEvents();
	        });

	        // kendo.notify(chart, dataviz.ui);
	        return _this;
	    }

	    _createClass(Chart, [{
	        key: '_initTheme',
	        value: function _initTheme(options, themeOptions) {
	            var seriesCopies = [];
	            var series = options.series || [];

	            for (var i = 0; i < series.length; i++) {
	                seriesCopies.push(Object.assign({}, series[i]));
	            }
	            options.series = seriesCopies;

	            resolveAxisAliases(options);
	            this._applyDefaults(options, themeOptions);

	            // Clean up default if not overriden by data attributes
	            if (options.seriesColors === null) {
	                delete options.seriesColors;
	            }

	            this.options = (0, _common.deepExtend)({}, themeOptions, options);
	            applySeriesColors(this.options);
	        }

	        // _initDataSource(userOptions) {
	        // const dataSource = (userOptions || {}).dataSource;

	        // this._dataChangeHandler = this._onDataChanged.bind(this);

	        // this.dataSource = DataSource
	        // .create(dataSource)
	        // .bind(CHANGE, this._dataChangeHandler);

	        // this._bindCategories();

	        // if (dataSource) {
	        // this._hasDataSource = true;
	        // }

	        // preloadFonts(userOptions, function() {
	        // this._redraw();
	        // this._attachEvents();
	        // });

	        // if (dataSource) {
	        // if (this.options.autoBind) {
	        // this.dataSource.fetch();
	        // }
	        // }
	        // }

	        // setDataSource(dataSource) {
	        // this.dataSource.unbind(CHANGE, this._dataChangeHandler);
	        // this.dataSource = dataSource = DataSource.create(dataSource);
	        // this._hasDataSource = true;
	        // this._hasData = false;

	        // dataSource.bind(CHANGE, this._dataChangeHandler);

	        // if (this.options.autoBind) {
	        // dataSource.fetch();
	        // }
	        // }

	        // items() {
	        // return $();
	        // },

	    }, {
	        key: 'refresh',
	        value: function refresh() {
	            this._applyDefaults(this.options);

	            applySeriesColors(this.options);

	            this._bindSeries();
	            this._bindCategories();

	            // this.trigger(DATABOUND);
	            this._redraw();
	        }
	    }, {
	        key: 'getSize',
	        value: function getSize() {
	            return { width: this.element.offsetWidth, height: this.element.offsetHeight };
	            // return kendo.dimensions(this.element);
	        }
	    }, {
	        key: 'resize',
	        value: function resize(force) {
	            var size = this.getSize();
	            var currentSize = this._size;

	            if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {
	                this._size = size;
	                this._resize(size, force);
	                this.trigger("resize", size);
	            }
	        }
	    }, {
	        key: '_resize',
	        value: function _resize() {
	            this._noTransitionsRedraw();
	        }
	    }, {
	        key: 'redraw',
	        value: function redraw(paneName) {
	            this._applyDefaults(this.options);
	            applySeriesColors(this.options);

	            if (paneName) {
	                var plotArea = this._model._plotArea;
	                var pane = plotArea.findPane(paneName);
	                plotArea.redraw(pane);
	            } else {
	                this._redraw();
	            }
	        }
	    }, {
	        key: 'getAxis',
	        value: function getAxis(name) {
	            var axes = this._plotArea.axes;

	            for (var idx = 0; idx < axes.length; idx++) {
	                if (axes[idx].options.name === name) {
	                    return new _chartAxis2.default(axes[idx]);
	                }
	            }
	        }
	    }, {
	        key: 'findAxisByName',
	        value: function findAxisByName(name) {
	            return this.getAxis(name);
	        }
	    }, {
	        key: 'plotArea',
	        value: function plotArea() {
	            return new _chartPlotarea2.default(this._plotArea);
	        }
	    }, {
	        key: 'findPaneByName',
	        value: function findPaneByName(name) {
	            var panes = this._plotArea.panes;

	            for (var idx = 0; idx < panes.length; idx++) {
	                if (panes[idx].options.name === name) {
	                    return new _chartPane2.default(this, panes[idx]);
	                }
	            }
	        }
	    }, {
	        key: 'findPaneByIndex',
	        value: function findPaneByIndex(idx) {
	            var panes = this._plotArea.panes;
	            if (panes[idx]) {
	                return new _chartPane2.default(this, panes[idx]);
	            }
	        }
	    }, {
	        key: 'findSeries',
	        value: function findSeries(callback) {
	            var plotArea = this._plotArea;
	            var series = plotArea.srcSeries || plotArea.series;
	            for (var idx = 0; idx < series.length; idx++) {
	                if (callback(series[idx])) {
	                    return new _chartSeries2.default(this, series[idx]);
	                }
	            }
	        }
	    }, {
	        key: 'findSeriesByName',
	        value: function findSeriesByName(name) {
	            return this._createSeries({ name: name });
	        }
	    }, {
	        key: 'findSeriesByIndex',
	        value: function findSeriesByIndex(index) {
	            return this._createSeries({ index: index });
	        }
	    }, {
	        key: '_createSeries',
	        value: function _createSeries(options) {
	            var seriesOptions = this._seriesOptions(options);
	            if (seriesOptions) {
	                return new _chartSeries2.default(this, seriesOptions);
	            }
	        }
	    }, {
	        key: '_seriesOptions',
	        value: function _seriesOptions(options) {
	            var plotArea = this._plotArea;
	            var series = plotArea.srcSeries || plotArea.series;
	            var seriesOptions = void 0;

	            if ((0, _common.defined)(options.index)) {
	                seriesOptions = series[options.index];
	            } else if ((0, _common.defined)(options.name)) {
	                for (var idx = 0; idx < series.length; idx++) {
	                    if (series[idx].name === options.name) {
	                        seriesOptions = series[idx];
	                        break;
	                    }
	                }
	            }

	            return seriesOptions;
	        }
	    }, {
	        key: 'toggleHighlight',
	        value: function toggleHighlight(show, filter) {
	            var plotArea = this._plotArea;
	            var firstSeries = (plotArea.srcSeries || plotArea.series || [])[0];
	            var points = void 0;

	            if ((0, _common.isFunction)(filter)) {
	                points = plotArea.filterPoints(filter);
	            } else {
	                var seriesName = void 0,
	                    categoryName = void 0;
	                if ((0, _common.isObject)(filter)) {
	                    seriesName = filter.series;
	                    categoryName = filter.category;
	                } else {
	                    seriesName = categoryName = filter;
	                }

	                if (firstSeries.type === _constants2.DONUT) {
	                    points = pointByCategoryName(plotArea.pointsBySeriesName(seriesName), categoryName);
	                } else if (firstSeries.type === _constants2.PIE || firstSeries.type === _constants2.FUNNEL) {
	                    points = pointByCategoryName((plotArea.charts[0] || {}).points, categoryName);
	                } else {
	                    points = plotArea.pointsBySeriesName(seriesName);
	                }
	            }

	            if (points) {
	                this._togglePointsHighlight(show, points);
	            }
	        }
	    }, {
	        key: '_togglePointsHighlight',
	        value: function _togglePointsHighlight(show, points) {
	            var highlight = this._highlight;
	            for (var idx = 0; idx < points.length; idx++) {
	                highlight.togglePointHighlight(points[idx], show);
	            }
	        }
	    }, {
	        key: 'showTooltip',
	        value: function showTooltip(filter) {
	            var shared = this._sharedTooltip();
	            var tooltip = this._tooltip;
	            var plotArea = this._plotArea;

	            var point = void 0,
	                categoryIndex = void 0;

	            if ((0, _common.isFunction)(filter)) {
	                point = plotArea.findPoint(filter);
	                if (point && shared) {
	                    categoryIndex = point.categoryIx;
	                }
	            } else if (shared && (0, _common.defined)(filter)) {
	                categoryIndex = plotArea.categoryAxis.categoryIndex(filter);
	            }

	            if (shared) {
	                if (categoryIndex >= 0) {
	                    var points = this._plotArea.pointsByCategoryIndex(categoryIndex);
	                    tooltip.showAt(points);
	                }
	            } else if (point) {
	                tooltip.show(point);
	            }
	        }
	    }, {
	        key: 'hideTooltip',
	        value: function hideTooltip() {
	            this._tooltip.hide();
	        }
	    }, {
	        key: '_initSurface',
	        value: function _initSurface() {
	            var surface = this.surface;
	            var wrap = this._surfaceWrap();

	            var chartArea = this.options.chartArea;
	            if (chartArea.width) {
	                (0, _common.elementSize)(wrap, { width: chartArea.width });
	            }
	            if (chartArea.height) {
	                (0, _common.elementSize)(wrap, { height: chartArea.height });
	            }

	            if (!surface || surface.options.type !== this.options.renderAs) {
	                if (surface) {
	                    surface.destroy();
	                }

	                this.surface = _kendoDrawing.drawing.Surface.create(wrap, {
	                    type: this.options.renderAs
	                });
	            } else {
	                this.surface.clear();
	                this.surface.resize();
	            }
	        }
	    }, {
	        key: '_surfaceWrap',
	        value: function _surfaceWrap() {
	            return this.element;
	        }
	    }, {
	        key: '_redraw',
	        value: function _redraw() {
	            var model = this._getModel();

	            this._destroyView();

	            this._model = model;
	            this._plotArea = model._plotArea;

	            model.renderVisual();

	            if (this.options.transitions !== false) {
	                model.traverse(function (element) {
	                    if (element.animation) {
	                        element.animation.setup();
	                    }
	                });
	            }

	            this._initSurface();
	            this.surface.draw(model.visual);

	            if (this.options.transitions !== false) {
	                model.traverse(function (element) {
	                    if (element.animation) {
	                        element.animation.play();
	                    }
	                });
	            }

	            this._tooltip = this._createTooltip();
	            this._highlight = new _highlight2.default();
	            this._setupSelection();
	            this._createPannable();
	            this._createZoomSelection();
	            this._createMousewheelZoom();

	            //if (!this._hasDataSource || this._hasData || !this.options.autoBind) {
	            this.trigger(_constants2.RENDER);
	            //}
	        }
	    }, {
	        key: 'exportVisual',
	        value: function exportVisual(options) {
	            var visual = void 0;
	            if (options && (options.width || options.height)) {
	                var chartArea = this.options.chartArea;
	                var originalChartArea = this._originalOptions.chartArea;

	                (0, _common.deepExtend)(chartArea, options);

	                var model = this._getModel();

	                chartArea.width = originalChartArea.width;
	                chartArea.height = originalChartArea.height;

	                model.renderVisual();

	                visual = model.visual;
	            } else {
	                visual = this.surface.exportVisual();
	            }

	            return visual;
	        }
	    }, {
	        key: '_sharedTooltip',
	        value: function _sharedTooltip() {
	            return this._plotArea instanceof _categoricalPlotarea2.default && this.options.tooltip.shared;
	        }
	    }, {
	        key: '_createPannable',
	        value: function _createPannable() {
	            var options = this.options;
	            if (options.pannable !== false) {
	                this._pannable = new _pannable2.default(this._plotArea, options.pannable);
	            }
	        }
	    }, {
	        key: '_createZoomSelection',
	        value: function _createZoomSelection() {
	            var zoomable = this.options.zoomable;
	            var selection = (zoomable || {}).selection;
	            if (zoomable !== false && selection !== false) {
	                this._zoomSelection = new _zoomSelection2.default(this, selection);
	            }
	        }
	    }, {
	        key: '_createMousewheelZoom',
	        value: function _createMousewheelZoom() {
	            var zoomable = this.options.zoomable;
	            var mousewheel = (zoomable || {}).mousewheel;
	            if (zoomable !== false && mousewheel !== false) {
	                this._mousewheelZoom = new _mousewheelZoom2.default(this, mousewheel);
	            }
	        }
	    }, {
	        key: '_createTooltip',
	        value: function _createTooltip() {
	            var element = this.element;
	            var tooltipOptions = this.options.tooltip;

	            var tooltip = void 0;

	            if (this._sharedTooltip()) {
	                tooltip = new _sharedTooltip3.default(element, this._plotArea, tooltipOptions);
	            } else {
	                tooltip = new _tooltip2.default(element, tooltipOptions);
	            }

	            this._bindTooltip(tooltip);

	            return tooltip;
	        }
	    }, {
	        key: '_bindTooltip',
	        value: function _bindTooltip(tooltip) {
	            tooltip.bind("show", this._tooltipShowHandler);
	            tooltip.bind("hide", this._tooltipHideHandler);
	        }
	    }, {
	        key: '_tooltipleave',
	        value: function _tooltipleave() {
	            // var this = this,
	            // plotArea = this._plotArea,
	            // highlight = this._highlight;

	            // plotArea.hideCrosshairs();

	            // highlight.hide();
	        }
	    }, {
	        key: '_applyDefaults',
	        value: function _applyDefaults(options, themeOptions) {
	            applyAxisDefaults(options, themeOptions);
	            applySeriesDefaults(options, themeOptions);
	        }
	    }, {
	        key: '_getModel',
	        value: function _getModel() {
	            var options = this.options;
	            var model = new _core.RootElement(this._modelOptions());
	            model.chart = this;

	            _core.Title.buildTitle(options.title, model);

	            var plotArea = model._plotArea = this._createPlotArea();
	            if (options.legend.visible) {
	                model.append(new _legend2.default(plotArea.options.legend));
	            }
	            model.append(plotArea);
	            model.reflow();

	            return model;
	        }
	    }, {
	        key: '_modelOptions',
	        value: function _modelOptions() {
	            var options = this.options;
	            var element = this.element;

	            var size = (0, _common.elementSize)(element);

	            this._size = null;

	            return (0, _common.deepExtend)({
	                width: Math.floor(size.width) || _constants.DEFAULT_WIDTH,
	                height: Math.floor(size.height) || _constants.DEFAULT_HEIGHT,
	                transitions: options.transitions
	            }, options.chartArea);
	        }
	    }, {
	        key: '_createPlotArea',
	        value: function _createPlotArea(skipSeries) {
	            var options = this.options;

	            var plotArea = this._plotArea = _plotareaFactory2.default.current.create(skipSeries ? [] : options.series, options);

	            plotArea.chart = this;
	            plotArea.createCrosshairs();

	            return plotArea;
	        }
	    }, {
	        key: '_hasSelection',
	        value: function _hasSelection() {
	            return this._selections && this._selections.length;
	        }
	    }, {
	        key: '_setupSelection',
	        value: function _setupSelection() {
	            var axes = this._plotArea.axes;

	            var selections = this._selections = [];

	            if (!this._selectStartHandler) {
	                this._selectStartHandler = this._selectStart.bind(this);
	                this._selectHandler = this._select.bind(this);
	                this._selectEndHandler = this._selectEnd.bind(this);
	            }

	            for (var i = 0; i < axes.length; i++) {
	                var axis = axes[i];
	                var options = axis.options;
	                if (axis instanceof _core.CategoryAxis && options.select && !options.vertical) {
	                    var min = 0;
	                    var max = options.categories.length - 1;

	                    if (axis instanceof _core.DateCategoryAxis) {
	                        min = options.categories[min];
	                        max = options.categories[max];
	                    }

	                    if (!options.justified) {
	                        if (axis instanceof _core.DateCategoryAxis) {
	                            max = (0, _dateUtils.addDuration)(max, 1, options.baseUnit, options.weekStartDay);
	                        } else {
	                            max++;
	                        }
	                    }

	                    var selection = new _selection2.default(this, axis, (0, _common.deepExtend)({ min: min, max: max }, options.select));

	                    selection.bind(_constants2.SELECT_START, this._selectStartHandler);
	                    selection.bind(_constants2.SELECT, this._selectHandler);
	                    selection.bind(_constants2.SELECT_END, this._selectEndHandler);

	                    selections.push(selection);
	                }
	            }
	        }
	    }, {
	        key: '_selectStart',
	        value: function _selectStart(e) {
	            return this.trigger(_constants2.SELECT_START, e);
	        }
	    }, {
	        key: '_select',
	        value: function _select(e) {
	            return this.trigger(_constants2.SELECT, e);
	        }
	    }, {
	        key: '_selectEnd',
	        value: function _selectEnd(e) {
	            return this.trigger(_constants2.SELECT_END, e);
	        }
	    }, {
	        key: '_initHandlers',
	        value: function _initHandlers() {
	            this._clickHandler = this._click.bind(this);
	            this._mousewheelHandler = this._mousewheel.bind(this);
	            this._surfaceMouseenterHandler = this._mouseover.bind(this);
	            this._surfaceMouseleaveHandler = this._mouseout.bind(this);

	            this._mousemove = (0, _kendoDrawing.throttle)(this._mousemove.bind(this), MOUSEMOVE_DELAY);

	            this._tooltipShowHandler = this._tooltipShow.bind(this);
	            this._tooltipHideHandler = this._tooltipHide.bind(this);
	        }
	    }, {
	        key: '_tooltipShow',
	        value: function _tooltipShow(e) {
	            this.trigger(SHOW_TOOLTIP, e);
	        }
	    }, {
	        key: '_tooltipHide',
	        value: function _tooltipHide(e) {
	            this.trigger(HIDE_TOOLTIP, e);
	        }
	    }, {
	        key: '_attachEvents',
	        value: function _attachEvents() {
	            var _bindEvents;

	            var element = this.element;
	            var surface = this.surface;


	            surface.bind("mouseenter", this._surfaceMouseenterHandler);
	            surface.bind("mouseleave", this._surfaceMouseleaveHandler);
	            (0, _common.bindEvents)(element, (_bindEvents = {}, _defineProperty(_bindEvents, CONTEXTMENU, this._clickHandler), _defineProperty(_bindEvents, _constants2.MOUSEWHEEL, this._mousewheelHandler), _bindEvents));

	            if (this._shouldAttachMouseMove()) {
	                (0, _common.bindEvents)(element, _defineProperty({}, MOUSEMOVE, this._mousemove));
	            }

	            this._chartEvents = new _chartEvents2.default(this.element, {
	                start: this._start.bind(this),
	                move: this._move.bind(this),
	                end: this._end.bind(this),
	                tap: this._tap.bind(this)
	            });
	        }
	    }, {
	        key: '_gesturestart',
	        value: function _gesturestart(e) {
	            if (this._mousewheelZoom) {
	                this._gestureDistance = e.distance;
	                this._unsetActivePoint();
	                this.surface.suspendTracking();
	            }
	        }
	    }, {
	        key: '_gestureend',
	        value: function _gestureend() {
	            if (this._zooming) {
	                if (this.surface) {
	                    this.surface.resumeTracking();
	                }
	                this._zooming = false;
	                this.trigger(_constants2.ZOOM_END, {});
	            }
	        }
	    }, {
	        key: '_gesturechange',
	        value: function _gesturechange(e) {
	            var mousewheelZoom = this._mousewheelZoom;

	            if (mousewheelZoom) {
	                e.preventDefault();
	                var previousGestureDistance = this._gestureDistance;
	                var scaleDelta = -e.distance / previousGestureDistance + 1;

	                if (Math.abs(scaleDelta) >= 0.1) {
	                    scaleDelta = Math.round(scaleDelta * 10);

	                    this._gestureDistance = e.distance;
	                    var args = { delta: scaleDelta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e };
	                    if (this._zooming || !this.trigger(_constants2.ZOOM_START, args)) {

	                        if (!this._zooming) {
	                            this._zooming = true;
	                        }

	                        var ranges = args.axisRanges = mousewheelZoom.updateRanges(scaleDelta);
	                        if (ranges && !this.trigger(_constants2.ZOOM, args)) {
	                            mousewheelZoom.zoom();
	                        }
	                    }
	                }
	            }
	        }
	    }, {
	        key: '_mouseout',
	        value: function _mouseout(e) {
	            if (e.element) {
	                var element = this._drawingChartElement(e.element, e);

	                if (element && element.leave) {
	                    element.leave(this, e.originalEvent);
	                }
	            }
	        }
	    }, {
	        key: '_start',
	        value: function _start(e) {
	            var events = this._events;
	            var coords = this._eventCoordinates(e);

	            if (this._hasSelection() || !this._plotArea.backgroundContainsPoint(coords)) {
	                return;
	            }

	            if ((0, _common.defined)(events[_constants2.DRAG_START] || events[_constants2.DRAG] || events[_constants2.DRAG_END])) {
	                this._startNavigation(e, coords, _constants2.DRAG_START);
	            }

	            if (this._pannable && this._pannable.start(e)) {
	                this.surface.suspendTracking();
	                this._unsetActivePoint();
	                this._suppressHover = true;
	            }

	            if (this._zoomSelection) {
	                if (this._zoomSelection.start(e)) {
	                    this.trigger(_constants2.ZOOM_START, { axisRanges: axisRanges(this._plotArea.axes), originalEvent: e });
	                }
	            }
	        }
	    }, {
	        key: '_move',
	        value: function _move(e) {
	            var state = this._navState;
	            var pannable = this._pannable;


	            if (this._hasSelection()) {
	                return;
	            }

	            if (pannable) {
	                var ranges = pannable.move(e);

	                if (ranges && !this.trigger(_constants2.DRAG, { axisRanges: ranges, originalEvent: e })) {
	                    pannable.pan();
	                }
	            } else if (state) {
	                var _ranges = {};
	                var axes = state.axes;

	                for (var i = 0; i < axes.length; i++) {
	                    var currentAxis = axes[i];
	                    var axisName = currentAxis.options.name;
	                    if (axisName) {
	                        var delta = currentAxis.options.vertical ? e.y.delta : e.x.delta;

	                        if (delta !== 0) {
	                            _ranges[currentAxis.options.name] = currentAxis.translateRange(delta);
	                        }
	                    }
	                }

	                state.axisRanges = _ranges;
	                this.trigger(_constants2.DRAG, {
	                    axisRanges: _ranges,
	                    originalEvent: e
	                });
	            }

	            if (this._zoomSelection) {
	                this._zoomSelection.move(e);
	            }
	        }
	    }, {
	        key: '_end',
	        value: function _end(e) {
	            if (this._hasSelection()) {
	                return;
	            }

	            var pannable = this._pannable;
	            if (pannable && pannable.end(e)) {
	                this.surface.resumeTracking();
	                this.trigger(_constants2.DRAG_END, {
	                    axisRanges: axisRanges(this._plotArea.axes),
	                    originalEvent: e
	                });
	                this._suppressHover = false;
	            } else {
	                this._endNavigation(e, _constants2.DRAG_END);
	            }

	            if (this._zoomSelection) {
	                var ranges = this._zoomSelection.end(e);
	                if (ranges && !this.trigger(_constants2.ZOOM, { axisRanges: ranges, originalEvent: e })) {
	                    this._zoomSelection.zoom();
	                    this.trigger(_constants2.ZOOM_END, { axisRanges: ranges, originalEvent: e });
	                }
	            }
	        }
	    }, {
	        key: '_mousewheel',
	        value: function _mousewheel(e) {
	            var _this2 = this;

	            var delta = (0, _common.mousewheelDelta)(e);
	            var mousewheelZoom = this._mousewheelZoom;
	            var coords = this._eventCoordinates(e);

	            if (!this._plotArea.backgroundContainsPoint(coords)) {
	                return;
	            }

	            if (mousewheelZoom) {
	                (function () {
	                    var args = { delta: delta, axisRanges: axisRanges(_this2._plotArea.axes), originalEvent: e };
	                    if (_this2._zooming || !_this2.trigger(_constants2.ZOOM_START, args)) {
	                        e.preventDefault();

	                        if (!_this2._zooming) {
	                            _this2._unsetActivePoint();
	                            _this2.surface.suspendTracking();
	                            _this2._zooming = true;
	                        }

	                        if (_this2._mwTimeout) {
	                            clearTimeout(_this2._mwTimeout);
	                        }

	                        args.axisRanges = mousewheelZoom.updateRanges(delta);
	                        if (args.axisRanges && !_this2.trigger(_constants2.ZOOM, args)) {
	                            mousewheelZoom.zoom();
	                        }

	                        _this2._mwTimeout = setTimeout(function () {
	                            _this2.trigger(_constants2.ZOOM_END, args);
	                            _this2._zooming = false;
	                            if (_this2.surface) {
	                                _this2.surface.resumeTracking();
	                            }
	                        }, _constants2.MOUSEWHEEL_DELAY);
	                    }
	                })();
	            } else {
	                var state = this._navState;
	                if (!state) {
	                    var prevented = this._startNavigation(e, coords, _constants2.ZOOM_START);
	                    if (!prevented) {
	                        state = this._navState;
	                    }
	                }

	                if (state) {
	                    var totalDelta = state.totalDelta || delta;
	                    state.totalDelta = totalDelta + delta;

	                    var axes = this._navState.axes;
	                    var ranges = {};

	                    for (var i = 0; i < axes.length; i++) {
	                        var currentAxis = axes[i];
	                        var axisName = currentAxis.options.name;
	                        if (axisName) {
	                            ranges[axisName] = currentAxis.scaleRange(-totalDelta);
	                        }
	                    }

	                    this.trigger(_constants2.ZOOM, {
	                        delta: delta,
	                        axisRanges: ranges,
	                        originalEvent: e
	                    });

	                    if (this._mwTimeout) {
	                        clearTimeout(this._mwTimeout);
	                    }

	                    this._mwTimeout = setTimeout(function () {
	                        _this2._endNavigation(e, _constants2.ZOOM_END);
	                    }, _constants2.MOUSEWHEEL_DELAY);
	                }
	            }
	        }
	    }, {
	        key: '_startNavigation',
	        value: function _startNavigation(e, coords, chartEvent) {
	            var plotArea = this._model._plotArea;
	            var pane = plotArea.findPointPane(coords);
	            var axes = plotArea.axes.slice(0);

	            if (!pane) {
	                return;
	            }

	            var ranges = axisRanges(axes);

	            var prevented = this.trigger(chartEvent, {
	                axisRanges: ranges,
	                originalEvent: e
	            });

	            if (prevented) {
	                this._userEvents.cancel();
	            } else {
	                this._suppressHover = true;
	                this._unsetActivePoint();
	                this._navState = {
	                    axisRanges: ranges,
	                    pane: pane,
	                    axes: axes
	                };
	            }
	        }
	    }, {
	        key: '_endNavigation',
	        value: function _endNavigation(e, chartEvent) {
	            if (this._navState) {
	                this.trigger(chartEvent, {
	                    axisRanges: this._navState.axisRanges,
	                    originalEvent: e
	                });
	                this._suppressHover = false;
	                this._navState = null;
	            }
	        }
	    }, {
	        key: '_getChartElement',
	        value: function _getChartElement(e, match) {
	            var element = this.surface.eventTarget(e);
	            if (element) {
	                return this._drawingChartElement(element, e, match);
	            }
	        }
	    }, {
	        key: '_drawingChartElement',
	        value: function _drawingChartElement(element, e, match) {
	            var current = element;
	            var chartElement = void 0;
	            while (current && !chartElement) {
	                chartElement = current.chartElement;
	                current = current.parent;
	            }

	            if (chartElement) {
	                if (chartElement.aliasFor) {
	                    chartElement = chartElement.aliasFor(e, this._eventCoordinates(e));
	                }

	                if (match) {
	                    chartElement = chartElement.closest(match);
	                }

	                return chartElement;
	            }
	        }
	    }, {
	        key: '_eventCoordinates',
	        value: function _eventCoordinates(e) {
	            return this._toModelCoordinates(e.pageX, e.pageY);
	        }
	    }, {
	        key: '_toModelCoordinates',
	        value: function _toModelCoordinates(clientX, clientY) {
	            var element = this.element;
	            var offset = (0, _common.elementOffset)(element);
	            var padding = (0, _common.elementStyles)(element, ["paddingLeft", "paddingTop"]);
	            var paddingLeft = padding.paddingLeft;
	            var paddingTop = padding.paddingTop;

	            return new _core.Point(clientX - offset.left - paddingLeft, clientY - offset.top - paddingTop);
	        }
	    }, {
	        key: '_tap',
	        value: function _tap(e) {
	            var drawingElement = this.surface.eventTarget(e);
	            var element = this._drawingChartElement(drawingElement, e);

	            if (this._activePoint === element) {
	                this._propagateClick(element, e);
	            } else {
	                if (!this._startHover(drawingElement, e)) {
	                    this._unsetActivePoint();
	                }

	                this._propagateClick(element, e);
	            }
	        }
	    }, {
	        key: '_click',
	        value: function _click(e) {
	            var element = this._getChartElement(e);
	            this._propagateClick(element, e);
	        }
	    }, {
	        key: '_propagateClick',
	        value: function _propagateClick(element, e) {
	            var current = element;
	            while (current) {
	                if (current.click) {
	                    current.click(this, e);
	                }

	                current = current.parent;
	            }
	        }
	    }, {
	        key: '_startHover',
	        value: function _startHover(element, e) {
	            var chartElement = this._drawingChartElement(element, e);
	            var tooltip = this._tooltip;
	            var highlight = this._highlight;


	            if (this._suppressHover || !highlight || highlight.isHighlighted(chartElement) || this._sharedTooltip()) {
	                return false;
	            }

	            var point = this._drawingChartElement(element, e, function (element) {
	                return element.hover && !(element instanceof _plotareaBase2.default);
	            });

	            if (point && !point.hover(this, e)) {
	                this._activePoint = point;

	                var tooltipOptions = (0, _common.deepExtend)({}, tooltipOptions, point.options.tooltip);
	                if (tooltipOptions.visible) {
	                    tooltip.show(point);
	                }

	                highlight.show(point);

	                return point.tooltipTracking;
	            }
	        }
	    }, {
	        key: '_mouseover',
	        value: function _mouseover(e) {
	            if (this._startHover(e.element, e.originalEvent)) {
	                this._mouseMoveTrackHandler = this._mouseMoveTrackHandler || this._mouseMoveTracking.bind(this);
	                (0, _common.bindEvents)(document, _defineProperty({}, MOUSEMOVE, this._mouseMoveTrackHandler));
	            }
	        }
	    }, {
	        key: '_mouseMoveTracking',
	        value: function _mouseMoveTracking(e) {
	            var options = this.options;
	            var tooltip = this._tooltip;
	            var highlight = this._highlight;
	            var point = this._activePoint;

	            var coords = this._eventCoordinates(e);

	            if (this._plotArea.box.containsPoint(coords)) {
	                if (point && point.tooltipTracking && point.series && point.parent.getNearestPoint) {
	                    var seriesPoint = point.parent.getNearestPoint(coords.x, coords.y, point.seriesIx);
	                    if (seriesPoint && seriesPoint !== point) {
	                        seriesPoint.hover(this, e);
	                        this._activePoint = seriesPoint;

	                        var tooltipOptions = (0, _common.deepExtend)({}, options.tooltip, point.options.tooltip);
	                        if (tooltipOptions.visible) {
	                            tooltip.show(seriesPoint);
	                        }

	                        highlight.show(seriesPoint);
	                    }
	                }
	            } else {
	                (0, _common.unbindEvents)(document, MOUSEMOVE, this._mouseMoveTrackHandler);
	                this._unsetActivePoint();
	            }
	        }
	    }, {
	        key: '_mousemove',
	        value: function _mousemove(e) {
	            var coords = this._eventCoordinates(e);

	            this._trackCrosshairs(coords);

	            if (this._plotArea.hover) {
	                this._plotArea.hover(this, e);
	            }

	            if (this._sharedTooltip()) {
	                this._trackSharedTooltip(coords, e);
	            }
	        }
	    }, {
	        key: '_trackCrosshairs',
	        value: function _trackCrosshairs(coords) {
	            var crosshairs = this._plotArea.crosshairs;

	            for (var i = 0; i < crosshairs.length; i++) {
	                var current = crosshairs[i];

	                if (current.box.containsPoint(coords)) {
	                    current.showAt(coords);
	                } else {
	                    current.hide();
	                }
	            }
	        }
	    }, {
	        key: '_trackSharedTooltip',
	        value: function _trackSharedTooltip(coords, e) {
	            var tooltipOptions = this.options.tooltip;
	            var plotArea = this._plotArea;
	            var categoryAxis = this._plotArea.categoryAxis;
	            var tooltip = this._tooltip;
	            var highlight = this._highlight;


	            if (plotArea.box.containsPoint(coords)) {
	                var index = categoryAxis.pointCategoryIndex(coords);
	                if (index !== this._tooltipCategoryIx) {
	                    var points = plotArea.pointsByCategoryIndex(index);

	                    var pointArgs = points.map(function (point) {
	                        return point.eventArgs(e);
	                    });

	                    var hoverArgs = pointArgs[0] || {};
	                    hoverArgs.categoryPoints = pointArgs;

	                    if (points.length > 0 && !this.trigger(_constants2.SERIES_HOVER, hoverArgs)) {
	                        if (tooltipOptions.visible) {
	                            tooltip.showAt(points, coords);
	                        }

	                        highlight.show(points);
	                    } else {
	                        tooltip.hide();
	                    }

	                    this._tooltipCategoryIx = index;
	                }
	            }
	        }
	    }, {
	        key: 'hideElements',
	        value: function hideElements() {
	            var plotArea = this._plotArea;
	            var tooltip = this._tooltip;
	            var highlight = this._highlight;

	            this._mousemove.cancel();

	            plotArea.hideCrosshairs();

	            highlight.hide();

	            tooltip.hide();

	            delete this._tooltipCategoryIx;
	        }
	    }, {
	        key: '_unsetActivePoint',
	        value: function _unsetActivePoint() {
	            var tooltip = this._tooltip;
	            var highlight = this._highlight;


	            this._activePoint = null;

	            if (tooltip) {
	                tooltip.hide();
	            }

	            if (highlight) {
	                highlight.hide();
	            }
	        }

	        // _onDataChanged(e) {
	        // const options = this.options;
	        // const series = this._sourceSeries || options.series;
	        // const seriesLength = series.length;
	        // const data = this.dataSource.view();
	        // const grouped = (this.dataSource.group() || []).length > 0;
	        // const processedSeries = [];

	        // for (let seriesIx = 0; seriesIx < seriesLength; seriesIx++) {
	        // const currentSeries = series[seriesIx];

	        // if (this._isBindable(currentSeries) && grouped) {
	        // append(processedSeries,
	        // groupSeries(currentSeries, data));
	        // this._applyGroupVisibleState(processedSeries, e);
	        // } else {
	        // processedSeries.push(currentSeries || []);
	        // }
	        // }

	        // this._sourceSeries = series;
	        // options.series = processedSeries;

	        // applySeriesColors(this.options);

	        // this._bindSeries();
	        // this._bindCategories();
	        // this._hasData = true;

	        // this._deferRedraw();
	        // }

	    }, {
	        key: '_applyGroupVisibleState',
	        value: function _applyGroupVisibleState() {//(processedSeries, e) {
	            // if (e && e.action) {
	            // const visibleState = this._groupVisibleState = this._groupVisibleState || {};
	            // for (let idx = 0; idx < processedSeries.length; idx++) {
	            // if (visibleState[processedSeries[idx]._groupValue] === false) {
	            // processedSeries[idx].visible = false;
	            // }
	            // }
	            // } else {
	            // delete this._groupVisibleState;
	            // }
	        }
	    }, {
	        key: '_saveGroupVisibleState',
	        value: function _saveGroupVisibleState() {//(series) {
	            // if (defined(series._groupValue)) {
	            // if (!this._groupVisibleState) {
	            // this._groupVisibleState = {};
	            // }

	            // this._groupVisibleState[series._groupValue] = series.visible;
	            // }
	        }
	    }, {
	        key: '_deferRedraw',
	        value: function _deferRedraw() {
	            this.trigger(_constants2.DATABOUND);
	            this._redraw();
	        }
	    }, {
	        key: '_clearRedrawTimeout',
	        value: function _clearRedrawTimeout() {
	            if (this._redrawTimeout) {
	                clearInterval(this._redrawTimeout);
	                this._redrawTimeout = null;
	            }
	        }
	    }, {
	        key: '_bindSeries',
	        value: function _bindSeries() {
	            // const data = this.dataSource.view();
	            // const series = this.options.series;
	            // const seriesLength = series.length;

	            // for (let seriesIx = 0; seriesIx < seriesLength; seriesIx++) {
	            // cosnt currentSeries = series[seriesIx];

	            // if (this._isBindable(currentSeries)) {
	            // const groupIx = currentSeries._groupIx;
	            // const seriesData = defined(groupIx) ? (data[groupIx] || {}).items : data;

	            // if (currentSeries.autoBind !== false) {
	            // currentSeries.data = seriesData;
	            // }
	            // }
	            // }
	        }
	    }, {
	        key: '_bindCategories',
	        value: function _bindCategories() {
	            // const data = this.dataSource.view() || [];
	            // const grouped = (this.dataSource.group() || []).length > 0;
	            var options = this.options;
	            var definitions = [].concat(options.categoryAxis);
	            // let categoriesData = data;

	            // if (grouped) {
	            // if (data.length) {
	            // categoriesData = data[0].items;
	            // }
	            // }

	            for (var axisIx = 0; axisIx < definitions.length; axisIx++) {
	                var axis = definitions[axisIx];
	                if (axis.autoBind !== false) {
	                    this._bindCategoryAxisFromSeries(axis, axisIx);
	                }
	            }
	        }

	        // _bindCategoryAxis(axis, data, axisIx) {
	        // const count = (data || []).length;

	        // if (axis.field) {
	        // axis.categories = [];
	        // for (let categoryIx = 0; categoryIx < count; categoryIx++) {
	        // const row = data[categoryIx];
	        // const category = getField(axis.field, row);

	        // if (categoryIx === 0) {
	        // axis.categories = [category];
	        // axis.dataItems = [row];
	        // } else {
	        // axis.categories.push(category);
	        // axis.dataItems.push(row);
	        // }
	        // }
	        // } else {
	        // this._bindCategoryAxisFromSeries(axis, axisIx);
	        // }
	        // }

	    }, {
	        key: '_bindCategoryAxisFromSeries',
	        value: function _bindCategoryAxisFromSeries(axis, axisIx) {
	            var series = this.options.series;
	            var seriesLength = series.length;
	            var uniqueCategories = {};
	            var items = [];
	            var dateAxis = void 0;

	            for (var seriesIx = 0; seriesIx < seriesLength; seriesIx++) {
	                var s = series[seriesIx];
	                var onAxis = s.categoryAxis === axis.name || !s.categoryAxis && axisIx === 0;
	                var data = s.data;
	                var dataLength = data.length;

	                if (s.categoryField && onAxis && dataLength > 0) {
	                    dateAxis = (0, _isDateAxis2.default)(axis, (0, _getField2.default)(s.categoryField, data[0]));

	                    var getFn = dateAxis ? _getDateField2.default : _getField2.default;

	                    for (var dataIx = 0; dataIx < dataLength; dataIx++) {
	                        var dataRow = data[dataIx];
	                        var category = getFn(s.categoryField, dataRow);

	                        if (dateAxis || !uniqueCategories[category]) {
	                            items.push([category, dataRow]);

	                            if (!dateAxis) {
	                                uniqueCategories[category] = true;
	                            }
	                        }
	                    }
	                }
	            }

	            if (items.length > 0) {
	                if (dateAxis) {
	                    items = uniqueDates(items, function (a, b) {
	                        return (0, _dateUtils.dateComparer)(a[0], b[0]);
	                    });
	                }

	                var result = transpose(items);
	                axis.categories = result[0];
	                axis.dataItems = result[1];
	            }
	        }
	    }, {
	        key: '_isBindable',
	        value: function _isBindable(series) {
	            var valueFields = _seriesBinder2.default.current.valueFields(series);
	            var result = true;

	            for (var i = 0; i < valueFields.length; i++) {
	                var field = valueFields[i];
	                if (field === _constants.VALUE) {
	                    field = "field";
	                } else {
	                    field = field + "Field";
	                }

	                if (!(0, _common.defined)(series[field])) {
	                    result = false;
	                    break;
	                }
	            }

	            return result;
	        }
	    }, {
	        key: '_noTransitionsRedraw',
	        value: function _noTransitionsRedraw() {
	            var options = this.options;
	            var transitionsState = void 0;

	            if (options.transitions) {
	                options.transitions = false;
	                transitionsState = true;
	            }
	            this.redraw();
	            if (transitionsState) {
	                options.transitions = true;
	            }
	        }
	    }, {
	        key: '_legendItemHover',
	        value: function _legendItemHover(seriesIndex, pointIndex) {
	            var plotArea = this._plotArea;
	            var highlight = this._highlight;

	            var currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];
	            var items = void 0;

	            if ((0, _common.inArray)(currentSeries.type, [_constants2.PIE, _constants2.DONUT, _constants2.FUNNEL])) {
	                items = plotArea.findPoint(function (point) {
	                    return point.series.index === seriesIndex && point.index === pointIndex;
	                });
	            } else {
	                items = plotArea.pointsBySeriesIndex(seriesIndex);
	            }

	            highlight.show(items);
	        }
	    }, {
	        key: '_shouldAttachMouseMove',
	        value: function _shouldAttachMouseMove() {
	            var events = this._events;

	            return this._plotArea.crosshairs.length || this._tooltip && this._sharedTooltip() || (0, _common.defined)(events[_constants2.PLOT_AREA_HOVER]);
	        }
	    }, {
	        key: 'setOptions',
	        value: function setOptions(options, theme) {
	            // var this = this,
	            // dataSource = options.dataSource;

	            // options.dataSource = undefined;

	            clearMissingValues(this._originalOptions, options);
	            this._originalOptions = (0, _common.deepExtend)(this._originalOptions, options);
	            this.options = (0, _common.deepExtend)({}, this._originalOptions);
	            this._sourceSeries = null;

	            (0, _common.unbindEvents)(this.element, _defineProperty({}, MOUSEMOVE, this._mousemove));

	            // Widget.fn._setEvents.call(this, options);

	            if (theme) {
	                this._theme = theme;
	            }
	            this._initTheme(this.options, this._theme);

	            // if (dataSource) {
	            // this.setDataSource(dataSource);
	            // }

	            // if (this._hasDataSource) {
	            // this._onDataChanged();
	            // }  else {
	            this._bindCategories();
	            this.redraw();
	            // }

	            if (this._shouldAttachMouseMove()) {
	                (0, _common.bindEvents)(this.element, _defineProperty({}, MOUSEMOVE, this._mousemove));
	            }
	        }
	    }, {
	        key: 'destroy',
	        value: function destroy() {
	            var _unbindEvents2;

	            // const dataSource = this.dataSource;

	            (0, _common.unbindEvents)(this.element, (_unbindEvents2 = {}, _defineProperty(_unbindEvents2, CONTEXTMENU, this._clickHandler), _defineProperty(_unbindEvents2, _constants2.MOUSEWHEEL, this._mousewheelHandler), _unbindEvents2));
	            if (this._chartEvents) {
	                this._chartEvents.destroy();
	            }
	            // this.element.off(NS);

	            // if (dataSource) {
	            // dataSource.unbind(CHANGE, this._dataChangeHandler);
	            // }

	            (0, _common.unbindEvents)(document, _defineProperty({}, MOUSEMOVE, this._mouseMoveTrackHandler));

	            // if (this._userEvents) {
	            // this._userEvents.destroy();
	            // }

	            this._destroyView();

	            this.surface.destroy();
	            this.surface = null;

	            this._clearRedrawTimeout();

	            // Widget.fn.destroy.call(this);
	        }
	    }, {
	        key: '_destroyView',
	        value: function _destroyView() {
	            var model = this._model;
	            var selections = this._selections;


	            if (model) {
	                model.destroy();
	                this._model = null;
	            }

	            if (selections) {
	                while (selections.length > 0) {
	                    selections.shift().destroy();
	                }
	            }

	            this._unsetActivePoint();

	            if (this._tooltip) {
	                this._tooltip.destroy();
	            }

	            if (this._highlight) {
	                this._highlight.destroy();
	            }

	            if (this._zoomSelection) {
	                this._zoomSelection.destroy();
	                delete this._zoomSelection;
	            }

	            if (this._pannable) {
	                this._pannable.destroy();
	                delete this._pannable;
	            }

	            if (this._mousewheelZoom) {
	                this._mousewheelZoom.destroy();
	                delete this._mousewheelZoom;
	            }
	        }
	    }]);

	    return Chart;
	}(_kendoDrawing.Observable);

	function resolveAxisAliases(options) {
	    var aliases = AXIS_NAMES;

	    for (var idx = 0; idx < aliases.length; idx++) {
	        var alias = aliases[idx] + "Axes";
	        if (options[alias]) {
	            options[aliases[idx] + "Axis"] = options[alias];
	            delete options[alias];
	        }
	    }
	}

	function applySeriesColors(options) {
	    var series = options.series;
	    var colors = options.seriesColors || [];

	    for (var i = 0; i < series.length; i++) {
	        var currentSeries = series[i];
	        var seriesColor = colors[i % colors.length];
	        var defaults = currentSeries._defaults;

	        currentSeries.color = currentSeries.color || seriesColor;
	        if (defaults) {
	            defaults.color = defaults.color || seriesColor;
	        }
	    }
	}

	function pointByCategoryName(points, name) {
	    if (points) {
	        for (var idx = 0; idx < points.length; idx++) {
	            if (points[idx].category === name) {
	                return [points[idx]];
	            }
	        }
	    }
	}

	function applyAxisDefaults(options, themeOptions) {
	    var themeAxisDefaults = (themeOptions || {}).axisDefaults || {};

	    var _loop = function _loop(idx) {
	        var axisName = AXIS_NAMES[idx] + "Axis";
	        var axisDefaults = options.axisDefaults || {};
	        var axes = [].concat(options[axisName]);

	        axes = axes.map(function (axisOptions) {
	            // eslint-disable-line no-loop-func
	            var axisColor = (axisOptions || {}).color;
	            var result = (0, _common.deepExtend)({}, themeAxisDefaults, themeAxisDefaults[axisName], axisDefaults, axisDefaults[axisName], {
	                line: { color: axisColor },
	                labels: { color: axisColor },
	                title: { color: axisColor }
	            }, axisOptions);

	            delete result[axisName];

	            return result;
	        });

	        options[axisName] = axes.length > 1 ? axes : axes[0];
	    };

	    for (var idx = 0; idx < AXIS_NAMES.length; idx++) {
	        _loop(idx);
	    }
	}

	function applySeriesDefaults(options, themeOptions) {
	    var series = options.series;
	    var seriesLength = series.length;
	    var seriesDefaults = options.seriesDefaults;
	    var commonDefaults = (0, _common.deepExtend)({}, options.seriesDefaults);
	    var themeSeriesDefaults = themeOptions ? (0, _common.deepExtend)({}, themeOptions.seriesDefaults) : {};
	    var commonThemeDefaults = (0, _common.deepExtend)({}, themeSeriesDefaults);

	    cleanupNestedSeriesDefaults(commonDefaults);
	    cleanupNestedSeriesDefaults(commonThemeDefaults);

	    for (var i = 0; i < seriesLength; i++) {
	        var seriesType = series[i].type || options.seriesDefaults.type;

	        var baseOptions = (0, _common.deepExtend)({ data: [] }, commonThemeDefaults, themeSeriesDefaults[seriesType], { tooltip: options.tooltip }, commonDefaults, seriesDefaults[seriesType]);

	        series[i]._defaults = baseOptions;
	        series[i] = (0, _common.deepExtend)({}, baseOptions, series[i]);
	    }
	}

	function cleanupNestedSeriesDefaults(seriesDefaults) {
	    delete seriesDefaults.bar;
	    delete seriesDefaults.column;
	    delete seriesDefaults.rangeColumn;
	    delete seriesDefaults.line;
	    delete seriesDefaults.verticalLine;
	    delete seriesDefaults.pie;
	    delete seriesDefaults.donut;
	    delete seriesDefaults.area;
	    delete seriesDefaults.verticalArea;
	    delete seriesDefaults.scatter;
	    delete seriesDefaults.scatterLine;
	    delete seriesDefaults.bubble;
	    delete seriesDefaults.candlestick;
	    delete seriesDefaults.ohlc;
	    delete seriesDefaults.boxPlot;
	    delete seriesDefaults.bullet;
	    delete seriesDefaults.verticalBullet;
	    delete seriesDefaults.polarArea;
	    delete seriesDefaults.polarLine;
	    delete seriesDefaults.radarArea;
	    delete seriesDefaults.radarLine;
	    delete seriesDefaults.waterfall;
	}

	function axisRanges(axes) {
	    var ranges = {};

	    for (var i = 0; i < axes.length; i++) {
	        var axis = axes[i];
	        var _axisName = axis.options.name;
	        if (_axisName) {
	            ranges[_axisName] = axis.range();
	        }
	    }

	    return ranges;
	}

	function sortDates(dates) {
	    var comparer = arguments.length <= 1 || arguments[1] === undefined ? _dateUtils.dateComparer : arguments[1];

	    for (var i = 1, length = dates.length; i < length; i++) {
	        if (comparer(dates[i], dates[i - 1]) < 0) {
	            dates.sort(comparer);
	            break;
	        }
	    }

	    return dates;
	}

	function uniqueDates(srcDates) {
	    var comparer = arguments.length <= 1 || arguments[1] === undefined ? _dateUtils.dateComparer : arguments[1];

	    var dates = sortDates(srcDates, comparer);
	    var length = dates.length;
	    var result = length > 0 ? [dates[0]] : [];

	    for (var i = 1; i < length; i++) {
	        if (comparer(dates[i], (0, _common.last)(result)) !== 0) {
	            result.push(dates[i]);
	        }
	    }

	    return result;
	}

	function transpose(rows) {
	    var rowCount = rows.length;
	    var result = [];

	    for (var rowIx = 0; rowIx < rowCount; rowIx++) {
	        var row = rows[rowIx];
	        var colCount = row.length;

	        for (var colIx = 0; colIx < colCount; colIx++) {
	            result[colIx] = result[colIx] || [];
	            result[colIx].push(row[colIx]);
	        }
	    }

	    return result;
	}

	function clearMissingValues(originalOptions, options) {
	    for (var field in options) {
	        var fieldValue = options[field];
	        var originalValue = originalOptions[field];
	        if ((0, _common.defined)(originalValue)) {
	            var nullValue = fieldValue === null;
	            if (nullValue || !(0, _common.defined)(fieldValue)) {
	                delete originalOptions[field];
	                if (nullValue) {
	                    delete options[field];
	                }
	            } else if (originalValue && (0, _common.isObject)(fieldValue)) {
	                if ((0, _common.isObject)(originalValue)) {
	                    clearMissingValues(originalValue, fieldValue);
	                }
	            }
	        }
	    }
	}

	Chart.prototype.events = [_constants2.DATABOUND, _constants2.SERIES_CLICK, _constants2.SERIES_HOVER, _constants.AXIS_LABEL_CLICK, _constants2.LEGEND_ITEM_CLICK, _constants2.LEGEND_ITEM_HOVER, _constants2.PLOT_AREA_CLICK, _constants2.PLOT_AREA_HOVER, _constants2.DRAG_START, _constants2.DRAG, _constants2.DRAG_END, _constants2.ZOOM_START, _constants2.ZOOM, _constants2.ZOOM_END, _constants2.SELECT_START, _constants2.SELECT, _constants2.SELECT_END, _constants.NOTE_CLICK, _constants.NOTE_HOVER, _constants2.RENDER, SHOW_TOOLTIP, HIDE_TOOLTIP];

	(0, _common.setDefaultOptions)(Chart.prototype, {
	    // name: "Chart",
	    renderAs: "",
	    // theme: "default",
	    chartArea: {},
	    legend: {
	        visible: true,
	        labels: {}
	    },
	    categoryAxis: {},
	    // autoBind: true,
	    seriesDefaults: {
	        type: _constants2.COLUMN,
	        data: [],
	        highlight: {
	            visible: true
	        },
	        labels: {},
	        negativeValues: {
	            visible: false
	        }
	    },
	    series: [],
	    seriesColors: null,
	    tooltip: {
	        visible: false
	    },
	    transitions: true,
	    valueAxis: {},
	    plotArea: {},
	    title: {},
	    xAxis: {},
	    yAxis: {},
	    panes: [{}],
	    pannable: false,
	    zoomable: false
	});

	_exportMixin2.default.extend(Chart.prototype);

	exports.default = Chart;

/***/ },
/* 118 */
/***/ function(module, exports) {

	module.exports = require("../mixins/export-mixin");

/***/ },
/* 119 */
/***/ function(module, exports) {

	module.exports = require("./highlight");

/***/ },
/* 120 */
/***/ function(module, exports) {

	module.exports = require("./pan-and-zoom/pannable");

/***/ },
/* 121 */
/***/ function(module, exports) {

	module.exports = require("./pan-and-zoom/zoom-selection");

/***/ },
/* 122 */
/***/ function(module, exports) {

	module.exports = require("./pan-and-zoom/mousewheel-zoom");

/***/ },
/* 123 */
/***/ function(module, exports) {

	module.exports = require("./legend/legend");

/***/ },
/* 124 */
/***/ function(module, exports) {

	module.exports = require("./plotarea/plotarea-factory");

/***/ },
/* 125 */
/***/ function(module, exports) {

	module.exports = require("./selection");

/***/ },
/* 126 */
/***/ function(module, exports) {

	module.exports = require("./chart-events");

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = require("./tooltip/tooltip");

/***/ },
/* 128 */
/***/ function(module, exports) {

	module.exports = require("./tooltip/shared-tooltip");

/***/ },
/* 129 */
/***/ function(module, exports) {

	module.exports = require("./plotarea/categorical-plotarea");

/***/ },
/* 130 */
/***/ function(module, exports) {

	module.exports = require("./plotarea/plotarea-base");

/***/ },
/* 131 */
/***/ function(module, exports) {

	module.exports = require("./utils/get-field");

/***/ },
/* 132 */
/***/ function(module, exports) {

	module.exports = require("./utils/get-date-field");

/***/ },
/* 133 */
/***/ function(module, exports) {

	module.exports = require("./utils/is-date-axis");

/***/ },
/* 134 */
/***/ function(module, exports) {

	module.exports = require("../common");

/***/ },
/* 135 */
/***/ function(module, exports) {

	module.exports = require("../date-utils");

/***/ },
/* 136 */
/***/ function(module, exports) {

	module.exports = require("./animations");

/***/ },
/* 137 */
/***/ function(module, exports) {

	module.exports = require("./register-charts");

/***/ }
/******/ ]);