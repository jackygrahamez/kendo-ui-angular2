import 'core-js/es6';
import { drawing as draw } from '@progress/kendo-drawing';

import { NumericAxis, Box, Point } from '../../src/core';
import CategoricalPlotArea from '../../src/chart/plotarea/categorical-plotarea';

import { deepExtend, map, last, alignPathToPixel } from '../../src/common';

import autoMajorUnit from '../../src/core/utils/auto-major-unit';
import autoAxisMin from '../../src/core/utils/auto-axis-min';
import autoAxisMax from '../../src/core/utils/auto-axis-max';

import { ok, equal, close, closeTextPosition, sameRectPath, arrayClose, each, sameLinePath, equalTexts } from '../../test/test-helpers';
import { clickChart, createChart, destroyChart, getChartDomElement }  from '../test-helpers';
import '../../test/text-measure';
import '../../test/intl';

const chartBox = new Box(0, 0, 800, 600);
const TOLERANCE = 1.5;
let numericAxis, gridLayout;


function getBackground() {
     return numericAxis._backgroundPath;
}

function getLine() {
    return numericAxis._lineGroup.children[0];
}

function getTicks() {
    return numericAxis._lineGroup.children.slice(1);
}

function getAxisTextBoxes() {
    return map(numericAxis.labels, function(item) {
        return item.visual;
    });
}

function getAxisTexts() {
    return map(getAxisTextBoxes(), function(item) {
        return last(item.children);
    });
}

function createNumericAxis(options) {
    numericAxis = new NumericAxis(0, 1, options || {});
    numericAxis.reflow(chartBox);
    numericAxis.renderVisual();
}

function moduleSetup() {
    numericAxis = new NumericAxis(0, 1, {});
}

describe('Automatic Major Unit', () => {
    beforeEach(moduleSetup);

    // min, max, expected Major Unit
    const referenceUnits = [
        // [0, max] (max >= 0)
        [0, 0, 0.1],
        [0, 0.1, 0.02],
        [0, 0.2, 0.05],
        [0, 0.5, 0.1],
        [0, 1, 0.2],
        [0, 2, 0.5],
        [0, 5, 1],
        [0, 10, 2],
        [0, 20, 5],
        [0, 47, 5],
        [0, 48, 10],
        [0, 95, 10],
        [0, 96, 20],
        [0, 190, 20],
        [0, 191, 50],
        [0, 476, 50],
        [0, 477, 100],
        [0, 952, 100],
        [0, 953, 200],
        [0, 1904, 200],
        [0, 1905, 500],

        // [min, max] (min > 0, max >= min)
        [1, 1, 0.2],
        [1, 1.1, 0.02],
        [1, 1.2, 0.05],
        [1000, 1000, 200],
        [1000, 1050, 10],
        [1000, 1100, 20],
        [1000, 1200, 50]
    ];

    it("Major unit calculation for positive values", () => {
        for (let i = 0; i < referenceUnits.length; i++) {
            const [ min, max, mu ] = referenceUnits[i];

            equal(autoMajorUnit(min, max), mu, "[" + min + ", " + max  + "]");
        }
    });

    it("Major unit calculation for positive values with big precision should fallback to the default value", () => {
        equal(autoMajorUnit(10.1234566667, 10.1234566668), 2);
    });

    it("Major unit calculation for negative values", () => {
        for (let i = 0; i < referenceUnits.length; i++) {
            const d = referenceUnits[i];
            const min = -d[1];
            const max = -d[0];
            const mu = d[2];

            equal(autoMajorUnit(min, max), mu, "[" + min + ", " + max + "]");
        }
    });

    it("Major unit calculation for mixed positive / negative values", () => {
        for (let i = 0; i < referenceUnits.length; i++) {
            const d = referenceUnits[i];

            if (d[0] != 0) {
                // Skip tests where min is not 0
                continue;
            }

            // Take a test triplet [min, max, mu] and transform it to [-max/2, max/2, mu]
            const min = -d[1] / 2;
            const max = d[1] / 2;
            const mu = d[2];

            equal(autoMajorUnit(min, max), mu, "[" + min + ", " + max + "]");
        }
    });
});

(function() {
    const TOLERANCE = 0.0000000001;
    // min, max, expected axis minimum, expected axis maximum
    const referenceAxisLimits = [
        [0, 0, 0, 1],
        [0, 0.5, 0, 0.5],
        [0, 2, 0, 2],
        [0, 5, 0, 5],
        [0, 18, 0, 18],
        [0, 20, 0, 20],
        [0, 50, 0, 50],
        [0, 200, 0, 200],
        [0, 500, 0, 500],
        [0, 1800, 0, 1800],

        // Axis limits for close, positive values
        [1.0000001, 1.0000002, 1.00000005, 1.0000002],
        [1, 1, 0, 1],
        [1, 1.1, 0.95, 1.1],
        [1000, 1000, 0, 1000],
        [1000, 1050, 975, 1050],
        [1000, 1100, 950, 1100],
        [1000, 1200, 900, 1200]
    ];
   // -----------------------------------------------------------------
   describe('Automatic Axis Maximum', () => {
       beforeEach(moduleSetup);

        it("Axis maximum for positive values", () => {
            for (let i = 0; i < referenceAxisLimits.length; i++) {
                const [ min, max, mu, axisMax ] = referenceAxisLimits[i];

                close(autoAxisMax(min, max), axisMax, TOLERANCE, "[" + min + ", " + max + "]");
            }
        });

        it("Axis maximum for negative values", () => {
            for (let i = 0; i < referenceAxisLimits.length; i++) {
                const d = referenceAxisLimits[i];

                if (d[0] == 0 && d[1] == 0) {
                    // Skip the [0, 0] test
                    continue;
                }

                const min = -d[1];
                const max = -d[0];
                const axisMax = -d[2];

                close(autoAxisMax(min, max), axisMax, TOLERANCE, "[" + min + ", " + max + "]");
            }
        });

        it("Axis maximum for mixed positive / negative values", () => {
            for (let i = 0; i < referenceAxisLimits.length; i++) {
                const d = referenceAxisLimits[i];

                if (d[0] != 0 || d[1] == 0) {
                    // Skip the [0, 0] and [x, y] tests
                    continue;
                }

                const min = -d[1];
                const max = d[1];
                const axisMax = d[3];

                close(autoAxisMax(min, max), axisMax, TOLERANCE, "[" + min + ", " + max + "]");
            }
        });
    });

    // -----------------------------------------------------------------
    describe('Automatic Axis Minimum', () => {
        beforeEach(moduleSetup);

        it("Axis minimum for positive values", () => {
            for (let i = 0; i < referenceAxisLimits.length; i++) {
                const [ min, max, axisMin ] = referenceAxisLimits[i];
                close(autoAxisMin(min, max), axisMin, TOLERANCE, "[" + min + ", " + max + "]");
            }
        });

        it("Axis minimum for negative values", () => {
            for (let i = 0; i < referenceAxisLimits.length; i++) {
                const d = referenceAxisLimits[i];

                if (d[0] == 0 && d[1] == 0) {
                    // Skip the [0, 0] test
                    continue;
                }

                const min = -d[1];
                const max = -d[0];
                const axisMin = -d[3];

                close(autoAxisMin(min, max), axisMin, TOLERANCE, "[" + min + ", " + max + "]");
            }
        });

        it("Axis minimum for mixed positive/negative values", () => {
            for (let i = 0; i < referenceAxisLimits.length; i++) {
                const d = referenceAxisLimits[i];

                if (d[0] != 0 || d[1] == 0) {
                    // Skip the [0, 0] and [x, y] tests
                    continue;
                }

                const min = -d[1];
                const max = d[1];
                const axisMin = -d[3];

                close(autoAxisMin(min, max), axisMin, TOLERANCE, "[" + min + ", " + max + "]");
            }
        });
    });
})();

(function() {
    // ------------------------------------------------------------
    describe('Numeric Axis / Configuration', () => {
        beforeEach(moduleSetup);

        it("Major unit is calculated for user set min/max", () => {
            numericAxis = new NumericAxis(1000, 10000, {
                min: 10,
                max: 100
            });

            equal(numericAxis.options.majorUnit, 10);
        });

        it("Major unit is calculated for user set min and automatic max", () => {
            numericAxis = new NumericAxis(1000, 10000, {
                min: 9000
            });

            equal(numericAxis.options.majorUnit, 500);
        });

        it("Major unit is calculated for user set max and automatic min", () => {
            numericAxis = new NumericAxis(1000, 10000, {
                max: 2000
            });

            equal(numericAxis.options.majorUnit, 500);
        });

        it("Major unit is calculated for series when user min/max are not set", () => {
        numericAxis = new NumericAxis(0, 190, {});

            equal(numericAxis.options.majorUnit, 20);
        });

        it("Major unit is calculated when axis minimum is automatically set to 0", () => {
            numericAxis = new NumericAxis(45, 60, {});

            equal(numericAxis.options.majorUnit, 10);
        });

        it("setting narrowRange prevents axis minimum from being extend to 0", () => {
            numericAxis = new NumericAxis(45, 60, { narrowRange: true });

            equal(numericAxis.options.min, 35);
        });

        it("setting narrowRange does not set axis minimum below 0", () => {
            numericAxis = new NumericAxis(25, 103, { narrowRange: true });

            equal(numericAxis.options.min, 0);
        });

        it("setting narrowRange prevents axis maximum from being extend to 0", () => {
            numericAxis = new NumericAxis(-60, -45, { narrowRange: true });

            equal(numericAxis.options.max, -35);
        });

        it("setting narrowRange does not set axis max above 0", () => {
            numericAxis = new NumericAxis(-103, -25, { narrowRange: true });

            equal(numericAxis.options.max, 0);
        });

        it("setting narrowRange to false forces axis minimum to 0 for any delta", () => {
            numericAxis = new NumericAxis(100, 100.1, { narrowRange: false });

            equal(numericAxis.options.min, 0);
        });

        it("setting narrowRange to false forces axis maximum to 0 for any delta", () => {
            numericAxis = new NumericAxis(-100.1, -100, { narrowRange: false });

            equal(numericAxis.options.max, 0);
        });

        it("Automatic maximum is rounded to set major unit", () => {
            numericAxis = new NumericAxis(0, 3, { majorUnit: 1 });
            equal(numericAxis.options.max, 4);
        });

        it("Automatic maximum is rounded to auto major unit", () => {
            numericAxis = new NumericAxis(45, 60, {});
            equal(numericAxis.options.max, 70);
        });

        it("Automatic minimum is rounded to auto major unit", () => {
            numericAxis = new NumericAxis(99, 101, {});
            equal(numericAxis.options.min, 98);
        });

        it("Maximum is set to 1 when min = max = 0", () => {
            numericAxis = new NumericAxis(0, 3, { min: 0, max: 0 });
            equal(numericAxis.options.max, 1);
        });

        it("Major unit is set to 0.2 when min = max = 0", () => {
            numericAxis = new NumericAxis(0, 3, { min: 0, max: 0 });
            equal(numericAxis.options.majorUnit, 0.2);
        });

        it("Minimum is set to 0 when min = max != 0", () => {
            numericAxis = new NumericAxis(0, 3, { min: 1, max: 1 });
            equal(numericAxis.options.min, 0);
        });

        it("Minimum is set to 1 when min is 0 max is 10 and majorUnit is 5", () => {
            numericAxis = new NumericAxis(0, 0, { min: 0, max: 10, majorUnit: 5 });
            equal(numericAxis.options.minorUnit, 1);
        });

        it("reports range minimum equal to options.min", () => {
            equal(numericAxis.range().min, 0);
        });

        it("reports range maximum equal to options.max", () => {
            equal(numericAxis.range().max, 1.2);
        });

        it("Automatic maximum is extended if maximum is within 33% of major unit", () => {
            numericAxis = new NumericAxis(0, 34, {});
            equal(numericAxis.options.max, 40);
        });

        it("Automatic maximum is not extended if maximum is not within 33% of major unit", () => {
            numericAxis = new NumericAxis(0, 33, {});
            equal(numericAxis.options.max, 35);
        });

        it("Automatic maximum is not extended if roundToMajorUnit is false", () => {
            numericAxis = new NumericAxis(0, 34, { roundToMajorUnit: false });
            equal(numericAxis.options.max, 35);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Configuration / Negative values', () => {
        beforeEach(moduleSetup);

        it("Automatic maximum is rounded to auto major unit", () => {
            numericAxis = new NumericAxis(-60, -45, {});
            equal(numericAxis.options.max, 0);
        });

        it("Automatic minimum is rounded to auto major unit", () => {
            numericAxis = new NumericAxis(-60, -45, {});
            equal(numericAxis.options.min, -70);
        });

        it("Major unit is calculated when axis maximum is automatically set to 0", () => {
            numericAxis = new NumericAxis(-60, -45, {});

            equal(numericAxis.options.majorUnit, 10);
        });

        it("Automatic minimum is extended if maximum is within 33% of major unit", () => {
            numericAxis = new NumericAxis(-34, 0, {});
            equal(numericAxis.options.min, -40);
        });

        it("Automatic minimum is not extended if maximum is not within 33% of major unit", () => {
            numericAxis = new NumericAxis(-33, 0, {});
            equal(numericAxis.options.min, -35);
        });

        it("Automatic minimum is not extended if roundToMajorUnit is false", () => {
            numericAxis = new NumericAxis(-34, 0, { roundToMajorUnit: false });
            equal(numericAxis.options.min, -35);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Configuration / Labels', () => {

        it("labels can be hidden", () => {
            createNumericAxis({ labels: { visible: false } });
            equal(numericAxis.labels.length, 0);
        });

        it("labels have rotation angle", 1, () => {
            createNumericAxis({ labels: { rotation: 42.5 } });

            equal(numericAxis.labels[0].options.rotation, 42.5);
        });

        it("creates labels with full format", 1, () => {
            createNumericAxis({ labels: { format: "{0:C}"} });
            equalTexts(getAxisTexts(), ["$0.00", "$0.20", "$0.40", "$0.60", "$0.80", "$1.00", "$1.20"]);
        });

        it("creates labels with simple format", 1, () => {
            createNumericAxis({ labels: { format: "C"} });
            equalTexts(getAxisTexts(), ["$0.00", "$0.20", "$0.40", "$0.60", "$0.80", "$1.00", "$1.20"]);
        });

        it("labels have set zIndex", 1, () => {
            createNumericAxis({ zIndex: 2 });

            equal(getAxisTextBoxes()[0].options.zIndex, 2);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Configuration / Labels / rotation', () => {

        it("normalizes labels rotation options if object is passed", () => {
            createNumericAxis({
                labels: {
                    rotation: {
                        angle: 30,
                        align: "center"
                    }
                }
            });

            equal(numericAxis.labels[0].options.rotation, 30);
            equal(numericAxis.labels[0].options.alignRotation, "center");
        });

        it("sets labels rotation to zero if auto is set as value", () => {
            createNumericAxis({
                labels: {
                    rotation: {
                        angle: "auto"
                    }
                }
            });

            equal(numericAxis.labels[0].options.rotation, 0);

            createNumericAxis({
                labels: {
                    rotation: "auto"
                }
            });

            equal(numericAxis.labels[0].options.rotation, 0);
        });

        it("sets autoRotateLabels option to true if auto is set as rotation value", () => {
            createNumericAxis({
                labels: {
                    rotation: {
                        angle: "auto"
                    }
                }
            });

            equal(numericAxis.options.autoRotateLabels, true);

            createNumericAxis({
                labels: {
                    rotation: "auto"
                }
            });

            equal(numericAxis.options.autoRotateLabels, true);
        });
    });

})();


describe('valueRange', () => {
    beforeEach(() => {
        numericAxis = new NumericAxis(5.7, 37, {});
    });

    it("returns series min and max value", () => {
        const range = numericAxis.valueRange();
        equal(range.min, 5.7);
        equal(range.max, 37);
    });
});

(function() {
    const FIRST_LABEL_WIDTH = 10;
    const LAST_LABEL_WIDTH = 26;
    const MAX_LABEL_WIDTH = 28;
    const LABEL_HEIGHT = 17;
    const MAJOR_TICK_HEIGHT = 4;
    const MINOR_TICK_HEIGHT = 3;
    const MARGIN = 5;
    const PADDING = 5;

    // ------------------------------------------------------------
    describe('Numeric Axis / Vertical / Rendering', () => {

        it("creates axis line", () => {
            const expectedLine = draw.Path.fromPoints([[MAX_LABEL_WIDTH + MARGIN, chartBox.y1],
                [MAX_LABEL_WIDTH + MARGIN, chartBox.y2]]);
            alignPathToPixel(expectedLine);
            createNumericAxis();

            sameLinePath(getLine(), expectedLine, TOLERANCE);
        });

        it("creates background box", () => {
            createNumericAxis({ background: "red" });

            const rect = getBackground();
            const box = draw.Path.fromRect(numericAxis.box.toRect())

            sameLinePath(rect, box, TOLERANCE);
        });

        it("should not create axis line if visible is false", () => {
            createNumericAxis({ line: { visible: false }});
            ok(!numericAxis._lineGroup);
        });

        it("should not render axis if visible is false", () => {
            createNumericAxis({ visible: false });
            ok(!numericAxis.visual);
        });

        it("creates axis line when max is not multiple of majorUnit", () => {
            const expectedLine = draw.Path.fromPoints([[MAX_LABEL_WIDTH + MARGIN, chartBox.y1],
                [MAX_LABEL_WIDTH + MARGIN, chartBox.y2]]);
            alignPathToPixel(expectedLine);
            createNumericAxis({ min: 0, max: 1, majorUnit: .3 });

            sameLinePath(getLine(), expectedLine, TOLERANCE);
        });

        it("creates axis with dash type", () => {
            createNumericAxis({
                line: {
                    dashType: "dot"
                }
            });
            equal(getLine().options.stroke.dashType, "dot");
        });

        it("creates labels", () => {
            createNumericAxis();

            equalTexts(getAxisTexts(), ["0", "0.2", "0.4", "0.6", "0.8", "1", "1.2"]);
        });

        it("labels have set color", 1, () => {
            createNumericAxis({
                labels: {
                    color: "#f00"
                }
            });

            equal(getAxisTexts()[0].options.fill.color, "#f00");
        });

        it("labels have set background", 1, () => {
            createNumericAxis({
                labels: {
                    background: "#f0f"
                }
            });

            equal(getAxisTextBoxes()[0].children[0].options.fill.color, "#f0f");
        });

        it("labels have set template", 1, () => {
            createNumericAxis({
                labels: {
                    template: "|${ data.value }|"
                }
            });

            equal(getAxisTexts()[0].content(), "|0|");
        });

        it("labels are distributed vertically", () => {
            createNumericAxis();
            closeTextPosition("y", getAxisTexts(), [591.5, 491.6, 391.8, 291, 192.1, 92.3, -7.5], TOLERANCE);
        });

        it("labels are distributed vertically in reverse", () => {
            createNumericAxis({
                reverse: true
            });

            closeTextPosition("y", getAxisTexts(), [591.5, 491.6, 391.8, 291, 192.1, 92.3, -7.5].reverse(), TOLERANCE);
        });

        it("labels are aligned right", () => {
            createNumericAxis();
            closeTextPosition("x", getAxisTexts(), [16, 0, 0, 0, 0, 16, 0], TOLERANCE);
        });

        it("labels are aligned right with margin and padding", () => {
            createNumericAxis({
                labels: {
                    margin: MARGIN,
                    padding: PADDING
                }
            });

            closeTextPosition("x", getAxisTexts(), [ 26, 10, 10, 10, 10, 26, 10 ], TOLERANCE);
        });

        it("major ticks are distributed vertically", () => {
            createNumericAxis();

            arrayClose(map(getTicks(), function(line) {return line.segments[0].anchor().y;}),
                 [599.5, 499.5, 399.5, 300, 200.5, 100.5, 0.5], TOLERANCE);
        });

        it("excess space is allocated after last major tick", () => {
            createNumericAxis({
                max: 1.2,
                majorUnit: 0.5
            });
            arrayClose(map(getTicks(), function(line) {return line.segments[0].anchor().y;}),
                 [599.5, 348.5, 100.5], TOLERANCE);
        });

        it("major ticks are distributed vertically in reverse", () => {
            createNumericAxis({
                reverse: true
            });

            arrayClose(map(getTicks(), function(line) {return line.segments[0].anchor().y;}),
                 [599.5, 499.5, 399.5, 300, 200.5, 100.5, 0.5].reverse(), TOLERANCE);
        });

        it("excess space is allocated after last major tick in reverse", () => {
            createNumericAxis({
                reverse: true,
                max: 1.2,
                majorUnit: 0.5
            });
            arrayClose(map(getTicks(), function(line) {return line.segments[0].anchor().y;}),
                 [0.5, 251.5, 499.5], TOLERANCE);
        });

        it("minor ticks can be disabled", () => {
            createNumericAxis({
                line: {
                    width: 0
                }
            });

            ok(!numericAxis._lineGroup);
        });

        it("minor ticks are distributed vertically", () => {
            createNumericAxis({
                majorTicks: { visible: false },
                minorTicks: { visible: true }
            });
            arrayClose(map(getTicks(), function(line) {return line.segments[0].anchor().y;}),
                [599.5, 579.5, 559.5, 539.5, 519.5, 499.5,
                 479.5, 459.5, 439.5, 419.5, 399.5, 379.5,
                 359.5, 339.5, 319.5, 300.5, 280.5, 260.5,
                 240.5, 220.5, 200.5, 180.5, 160.5, 140.5,
                 120.5, 100.5, 80.5, 60.5, 40.5, 20.5, 0.5], TOLERANCE);
        });

        it("minor ticks are distributed vertically in reverse", () => {
            createNumericAxis({
                reverse: true,
                majorTicks: { visible: false },
                minorTicks: { visible: true }
            });
            arrayClose(map(getTicks(), function(line) {return line.segments[0].anchor().y;}),
                [599.5, 579.5, 559.5, 539.5, 519.5, 499.5,
                 479.5, 459.5, 439.5, 419.5, 399.5, 379.5,
                 359.5, 339.5, 319.5, 300.5, 280.5, 260.5,
                 240.5, 220.5, 200.5, 180.5, 160.5, 140.5,
                 120.5, 100.5, 80.5, 60.5, 40.5, 20.5, 0.5].reverse(), TOLERANCE);
        });

        it("minor ticks are rendered after last major tick", () => {
            createNumericAxis({
                min: 0,
                max: 0.3,
                majorUnit: 0.2,
                majorTicks: { visible: false },
                minorTicks: { visible: true }
            });
            arrayClose(map(getTicks(), function(line) {return line.segments[0].anchor().y;}),
                [599.5, 519.5, 439.5, 359.5, 280.5, 200.5, 120.5, 40.5], TOLERANCE);
        });

        it("major ticks are aligned to axis", 7, () => {
            createNumericAxis();

            each(getTicks(), function() {
                equal(this.segments[0].anchor().x, 29.5);
            });
        });

        it("minor ticks are aligned to axis", 31, () => {
            createNumericAxis({
                majorTicks: { visible: false },
                minorTicks: { visible: true }
            });
            each(getTicks(), function() {
                equal(this.segments[0].anchor().x, 29.5);
            });
        });

        it("Returns just one major tick if majorUnit is 0", () => {
            createNumericAxis({ majorUnit: 0 });
            equal(getTicks().length, 1);
        });

        it("major tick step of 0 is treated as 1", () => {
            createNumericAxis({
                majorTicks: { step: 0 }
            });

            equal(getTicks().length, 7);
        });

        it("minor tick step of 0 is treated as 1", () => {
            createNumericAxis({
                majorTicks: { visible: false },
                minorTicks: { visible: true, step: 0 }
            });

            equal(getTicks().length, 31);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Vertical / Label Step / Rendering', () => {
        beforeEach(() => {
            createNumericAxis({
                labels: { step: 2 }
            });
        });

        it("renders every second label", () => {
            equalTexts(getAxisTexts(), ["0", "0.4", "0.8", "1.2"]);
        });

        it("labels are distributed vertically", () => {
            closeTextPosition("y", getAxisTexts(), [591.5, 391.8, 192.1, -7.5], TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Vertical / Label Step and skip / Rendering', () => {
        beforeEach(() => {
            createNumericAxis({
                labels: { step: 2, skip: 2 }
            });
        });

        it("renders every second label, starting from the third", () => {
            equalTexts(getAxisTexts(), ["0.4", "0.8", "1.2"]);
        });

        it("labels are distributed vertically, starting from the third", () => {
            closeTextPosition("y", getAxisTexts(), [391.8, 192.1, -7.5], TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Vertical / Mirrored / Rendering', () => {
        beforeEach(() => {
            createNumericAxis({
                labels: {
                    mirror: true
                }
            });
        });

        it("labels are aligned left", 7, () => {
            closeTextPosition("x", getAxisTexts(), 9, TOLERANCE);
        });

        it("major ticks are aligned to axis", 7, () => {
            each(getTicks(), function() {
                equal(this.segments[0].anchor().x, 0.5);
            });
        });

        it("minor ticks are aligned to axis", 31, () => {
            createNumericAxis({
                majorTicks: { visible: false },
                minorTicks: { visible: true },
                labels: {
                    mirror: true
                }
            });
            each(getTicks(), function() {
                equal(this.segments[0].anchor().x, 0.5);
            });
        });
    });

    // ------------------------------------------------------------
    describe('Rendering / Horizontal', () => {
        beforeEach(() => {
            createNumericAxis({ vertical: false });
        });

        it("creates axis line", () => {
            const expectedLine = draw.Path.fromPoints([[chartBox.x1, chartBox.y1],
                [chartBox.x2, chartBox.y1]]);
            alignPathToPixel(expectedLine);

            sameLinePath(getLine(), expectedLine, TOLERANCE);
        });

        it("should not create axis line if visible is false", () => {
            createNumericAxis({ line: { visible: false }, vertical: false});

            ok(!numericAxis._lineGroup);
        });

        it("should not render axis if visible is false", () => {
            createNumericAxis({ visible: false, vertical: false });
            ok(!numericAxis._lineGroup);
        });

        it("creates labels", () => {
            equalTexts(getAxisTexts(), ["0", "0.2", "0.4", "0.6", "0.8", "1", "1.2"]);
        });

        it("labels are distributed horizontally", () => {
            closeTextPosition("x", getAxisTexts(), [-4, 121.1, 254.3, 387.5, 520.6, 661.8, 787], TOLERANCE);
        });

        it("labels are distributed horizontally in reverse", () => {
            createNumericAxis({ vertical: false, reverse: true });
            closeTextPosition("x", getAxisTexts(), [795, 653.8, 520.6, 387.5, 254.3, 129.167, -12], TOLERANCE);
        });

        it("labels are aligned top", 7, () => {
            closeTextPosition("y", getAxisTexts(), MAJOR_TICK_HEIGHT + MARGIN);
        });

        it("labels are aligned top", 7, () => {
            createNumericAxis({
                vertical: false,
                labels: {
                    margin: MARGIN,
                    padding: PADDING
                }
            });

            closeTextPosition("y", getAxisTexts(), MAJOR_TICK_HEIGHT + 2 * MARGIN + PADDING);
        });

        it("major ticks are distributed horizontally", () => {
            arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().x; }),
                 [0.5, 133.5, 266.5, 400.5, 533.5, 666.5, 799.5], TOLERANCE);
        });

        it("excess space is allocated after last major tick", () => {
            createNumericAxis({
                vertical: false,
                max: 1.2,
                majorUnit: 0.5
            });
            arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().x; }),
                 [0, 334, 666.5], TOLERANCE);
        });

        it("major ticks are distributed horizontally in reverse", () => {
            createNumericAxis({ vertical: false, reverse: true });
            arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().x; }),
                 [0.5, 133.5, 266.5, 400.5, 533.5, 666.5, 799.5].reverse(), TOLERANCE);
        });

        it("excess space is allocated after last major tick in reverse", () => {
            createNumericAxis({
                vertical: false,
                reverse: true,
                max: 1.2,
                majorUnit: 0.5
            });
            arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().x; }),
                 [799.5, 465.833, 133.5], TOLERANCE);
        });

        it("major ticks are vertical", 7, () => {
            each(getTicks(), function() {
                equal(this.segments[1].anchor().x, this.segments[0].anchor().x);
            });
        });

        it("major ticks are aligned to axis", 7, () => {
            each(getTicks(), function() {
                equal(this.segments[0].anchor().y, 0.5);
            });
        });

        it("major ticks are of predefined height", 7, () => {
            each(getTicks(), function() {
                equal(this.segments[1].anchor().y - this.segments[0].anchor().y, MAJOR_TICK_HEIGHT);
            });
        });

        it("minor ticks are distributed horizontally", () => {
            createNumericAxis({
                vertical: false,
                reverse: true,
                majorTicks: { visible: false },
                minorTicks: { visible: true }
            });

            arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().x; }),
                [0.5, 27.5, 53.5, 80.5, 107.5, 133.5, 160.5, 186.5,
                213.5, 240.5, 266.5, 293.5, 320.5, 346.5, 373.5,
                400.5, 426.5, 453.5, 479.5, 506.5, 533.5, 559.5,
                586.5, 613.5, 639.5, 666.5, 692.5, 719.5, 746.5, 772.5, 799.5].reverse(), TOLERANCE);
        });

        it("minor ticks are distributed horizontally in reverse", () => {
            createNumericAxis({
                majorTicks: { visible: false },
                minorTicks: { visible: true },
                vertical: false
            });
            arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().x; }),
                [0.5, 27.5, 53.5, 80.5, 107.5, 133.5, 160.5, 186.5,
                213.5, 240.5, 266.5, 293.5, 320.5, 346.5, 373.5,
                400.5, 426.5, 453.5, 479.5, 506.5, 533.5, 559.5,
                586.5, 613.5, 639.5, 666.5, 692.5, 719.5, 746.5, 772.5, 799.5], TOLERANCE);
        });

        it("minor ticks are rendered after last major tick", () => {
            createNumericAxis({
                vertical: false,
                min: 0,
                max: 0.3,
                majorUnit: 0.2,
                majorTicks: { visible: false },
                minorTicks: { visible: true }
            });
            arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().x; }),
                [0.5, 107.5, 213.5, 320.5, 426.5, 533.5, 639.5, 746.5], TOLERANCE);
        });

        it("minor ticks are vertical", 31, () => {
            createNumericAxis({
                majorTicks: { visible: false },
                minorTicks: { visible: true },
                vertical: false
            });

            each(getTicks(), function() {
                equal(this.segments[0].anchor().x, this.segments[1].anchor().x);
            });
        });

        it("minor ticks are aligned to axis", 31, () => {
            createNumericAxis({
                majorTicks: { visible: false },
                minorTicks: { visible: true },
                vertical: false
            });
            each(getTicks(), function() {
                equal(this.segments[0].anchor().y, 0.5);
            });
        });

        it("minor ticks are of predefined height", 31, () => {
            createNumericAxis({
                majorTicks: { visible: false },
                minorTicks: { visible: true },
                vertical: false
            });
            each(getTicks(), function() {
                equal(this.segments[1].anchor().y - this.segments[0].anchor().y, MINOR_TICK_HEIGHT);
            });
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Horizontal / Label Step / Rendering', () => {
        beforeEach(() => {
            createNumericAxis({
                labels: { step: 2 },
                vertical: false
            });
        });

        it("renders every second label", () => {
            equalTexts(getAxisTexts(), ["0", "0.4", "0.8", "1.2"]);
        });

        it("labels are distributed horizontally", () => {
            closeTextPosition("x", getAxisTexts(), [-4, 253, 520.6, 787], TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Horizontal / Label Step and skip / Rendering', () => {
        beforeEach(() => {
            createNumericAxis({
                labels: { step: 2, skip: 2 },
                vertical: false
            });
        });

        it("renders every second label, starting from the third label", () => {
            equalTexts(getAxisTexts(), ["0.4", "0.8", "1.2"]);
        });

        it("labels are distributed horizontally, starting from the thrid label", () => {
            closeTextPosition("x", getAxisTexts(), [254.3, 520.6, 787], TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Horizontal / Mirrored / Rendering', () => {
        beforeEach(() => {
            createNumericAxis({
                vertical: false,
                labels: {
                    mirror: true
                }
            });
        });

        it("labels are aligned bottom", 7, () => {
            closeTextPosition("y", getAxisTexts(), 0);
        });

        it("major ticks are aligned to axis", 7, () => {
            each(getTicks(), function() {
                equal(this.segments[0].anchor().y, 20.5);
            });
        });

        it("minor ticks are aligned to axis", 31, () => {
            createNumericAxis({
                majorTicks: { visible: false },
                minorTicks: { visible: true },
                vertical: false,
                labels: {
                    mirror: true
                }
            });
            each(getTicks(), function() {
                 equal(this.segments[0].anchor().y, 20.5);
            });
        });
    });

})();

(function() {

    describe('Slots / Vertical', () => {
        beforeEach(() => {
            createNumericAxis();
        });

        it("positions slot for [0, 0.5]", () => {
            const slot = numericAxis.getSlot(0, 0.5);
            arrayClose([slot.y1, slot.y2], [348.5, 599], TOLERANCE);
        });

        it("positions slot for [0, 0.5] when reversed", () => {
            createNumericAxis({
                reverse: true
            });
            const slot = numericAxis.getSlot(0, 0.5);
            arrayClose([slot.y1, slot.y2], [0, 251], TOLERANCE);
        });

        it("positions slot for [0.5, 1]", () => {
            const slot = numericAxis.getSlot(0.5, 1);
            arrayClose([slot.y1, slot.y2], [99.8, 348.5], TOLERANCE);
        });

        it("positions slot for [0.5, 1] when reversed", () => {
            numericAxis.options.reverse = true;
            const slot = numericAxis.getSlot(0.5, 1);
            arrayClose([slot.y1, slot.y2], [249.5, 499.1], TOLERANCE);
        });

        it("slot width is 0", () => {
            const slot = numericAxis.getSlot(0, 0.5);
            close(slot.width(), 0);
        });

        it("a value capped to minimum value", () => {
            const slot = numericAxis.getSlot(-1000, 1, true);
            arrayClose([slot.y1, slot.y2], [99.8, 599], TOLERANCE);
        });

        it("a value is not capped to minimum value", () => {
            const slot = numericAxis.getSlot(-100, 1);
            arrayClose([slot.y1, slot.y2], [99.8, 50515.6], TOLERANCE);
        });

        it("b value capped to maximum value", () => {
            const slot = numericAxis.getSlot(0, 1000, true);
            arrayClose([slot.y1, slot.y2], [0, 599], TOLERANCE);
        });

        it("b value is not capped to maximum value", () => {
            const slot = numericAxis.getSlot(0, 100);
            arrayClose([slot.y1, slot.y2], [-49317.6, 599], TOLERANCE);
        });

        it("slot method returns slot as rect", () => {
            const box = numericAxis.getSlot(0, 100);
            const slot = numericAxis.slot(0, 100);
            ok(slot.equals(box.toRect()));
        });
    });

    // ------------------------------------------------------------
    describe('Slots / Vertical / Negative Values', () => {
        beforeEach(() => {
            moduleSetup();

            numericAxis = new NumericAxis(-1, 0, {});
            numericAxis.reflow(chartBox);
        });

        it("positions slot for [-0.5, 0]", () => {
            const slot = numericAxis.getSlot(-0.5, 0);
            arrayClose([slot.y1, slot.y2], [0, 249.5], TOLERANCE);
        });

        it("positions slot for [-1, -0.5]", () => {
            const slot = numericAxis.getSlot(-1, -0.5);
            arrayClose([slot.y1, slot.y2], [249.5, 499.1], TOLERANCE);
        });

        it("a value capped to maximum value", () => {
            const slot = numericAxis.getSlot(1000, -1, true);
            arrayClose([slot.y1, slot.y2], [0, 499.1], TOLERANCE);
        });

        it("a value is not capped to maximum value", () => {
            const slot = numericAxis.getSlot(100, -1);
            arrayClose([slot.y1, slot.y2], [-49916.6, 499.1], TOLERANCE);
        });

        it("b value capped to minimum value", () => {
            const slot = numericAxis.getSlot(0, -1000, true);
            arrayClose([slot.y1, slot.y2], [0, 599], TOLERANCE);
        });

        it("b value is not capped to minimum value", () => {
            const slot = numericAxis.getSlot(0, -100);
            arrayClose([slot.y1, slot.y2], [0, 49916.6], TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Slots / Horizontal', () => {
        beforeEach(() => {
            moduleSetup();

            numericAxis = new NumericAxis(0, 1, { vertical: false });
            numericAxis.reflow(chartBox);
        });

        it("positions slot for [0, 0.5]", () => {
            const slot = numericAxis.getSlot(0, 0.5);
            arrayClose([slot.x1, slot.x2], [0, 332.9], TOLERANCE);
        });

        it("positions slot for [0, 0.5] when reversed", () => {
            numericAxis.options.reverse = true;
            const slot = numericAxis.getSlot(0, 0.5);
            arrayClose([slot.x1, slot.x2], [466, 799], TOLERANCE);
        });

        it("positions slot for [0.5, 1]", () => {
            const slot = numericAxis.getSlot(0.5, 1);
            arrayClose([slot.x1, slot.x2], [332.9, 665.8], TOLERANCE);
        });

        it("positions slot for [0.5, 1] when reversed", () => {
            numericAxis.options.reverse = true;
            const slot = numericAxis.getSlot(0.5, 1);
            arrayClose([slot.x1, slot.x2], [133.3, 466], TOLERANCE);
        });

        it("slot height is 0", () => {
            const slot = numericAxis.getSlot(0, 0.5);
            close(slot.height(), 0);
        });

        it("a value capped to minimum value", () => {
            const slot = numericAxis.getSlot(-1000, 1, true);
            arrayClose([slot.x1, slot.x2], [0, 665.8], TOLERANCE);
        });

        it("a value is not capped to minimum value", () => {
            const slot = numericAxis.getSlot(-100, 1);
            arrayClose([slot.x1, slot.x2], [-66583.3, 665.8], TOLERANCE);
        });

        it("b value capped to maximum value", () => {
            const slot = numericAxis.getSlot(0, 1000, true);
            arrayClose([slot.x1, slot.x2], [0, 799], TOLERANCE);
        });

        it("b value is not capped to maximum value", () => {
            const slot = numericAxis.getSlot(0, 100);
            arrayClose([slot.x1, slot.x2], [0, 66583.3], TOLERANCE);
        });

        it("slot method returns slot as rect", () => {
            const box = numericAxis.getSlot(0, 100);
            const slot = numericAxis.slot(0, 100);
            ok(slot.equals(box.toRect()));
        });
    });

    // ------------------------------------------------------------
    describe('Slots / Horizontal / Negative Values', () => {
        beforeEach(() => {
            numericAxis = new NumericAxis(-1, 0, { vertical: false });
            numericAxis.reflow(chartBox);
        });

        it("positions slot for [-0.5, 0]", () => {
            const slot = numericAxis.getSlot(-0.5, 0);
            arrayClose([slot.x1, slot.x2], [466.1, 799], TOLERANCE);
        });

        it("positions slot for [-1, -0.5]", () => {
            const slot = numericAxis.getSlot(-1, -0.5);
            arrayClose([slot.x1, slot.x2], [133.1, 466.1], TOLERANCE);
        });

        it("a value capped to maximum value", () => {
            const slot = numericAxis.getSlot(1000, -1, true);
            arrayClose([slot.x1, slot.x2], [133.166, 799], TOLERANCE);
        });

        it("a value is not capped to maximum value", () => {
            const slot = numericAxis.getSlot(100, -1);
            arrayClose([slot.x1, slot.x2], [133.1, 67382.3], TOLERANCE);
        });

        it("b value capped to minimum value", () => {
            const slot = numericAxis.getSlot(0, -1000, true);
            arrayClose([slot.x1, slot.x2], [0, 799]);
        });

        it("b value is not capped to minimum value", () => {
            const slot = numericAxis.getSlot(0, -100);
            arrayClose([slot.x1, slot.x2], [-65784.3, 799], TOLERANCE);
        });
    });
})();

(function() {
    const TOLERANCE = 0.01;
    let numericAxis;

    // ------------------------------------------------------------
    describe('Numeric Axis / getValue / Horizontal', () => {
        beforeEach(() => {
            numericAxis = new NumericAxis(0, 1, {
                vertical: false,
                labels: { visible: false }
            });
            numericAxis.reflow(chartBox);
        });

        it("returns null for coordinates left of axis", () => {
            equal(numericAxis.getValue(new Point(-1, 0)), null);
        });

        it("returns null for coordinates right of axis", () => {
            equal(numericAxis.getValue(new Point(1000, 0)), null);
        });

        it("returns minimum value for leftmost point", () => {
            equal(numericAxis.getValue(new Point(0, 0)), 0);
        });

        it("returns maximum value for righttmost point", () => {
            equal(numericAxis.getValue(new Point(799, 0)), 1.2);
        });

        it("returns value for middle point", () => {
            close(numericAxis.getValue(new Point(335, 0)), 0.5, TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / getValue / Horizontal / Reverse', () => {
        beforeEach(() => {
            numericAxis = new NumericAxis(0, 1, {
                vertical: false,
                reverse: true,
                labels: { visible: false }
            });

            numericAxis.reflow(chartBox);
        });

        it("returns minimum value for righttmost point", () => {
            equal(numericAxis.getValue(new Point(799, 0)), 0);
        });

        it("returns maximum value for leftmost point", () => {
            equal(numericAxis.getValue(new Point(0, 0)), 1.2);
        });

        it("returns value for middle point", () => {
            close(numericAxis.getValue(new Point(465, 0)), 0.5, TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / getValue / Vertical', () => {
        beforeEach(() => {
            numericAxis = new NumericAxis(0, 1, {
                vertical: true,
                labels: { visible: false }
            });
            numericAxis.reflow(chartBox);
        });

        it("returns null for coordinates above the axis", () => {
            equal(numericAxis.getValue(new Point(0, -1)), null);
        });

        it("returns null for coordinates below the axis", () => {
            equal(numericAxis.getValue(new Point(0, 1000)), null);
        });

        it("returns minimum value for bottommost point", () => {
            equal(numericAxis.getValue(new Point(0, 599)), 0);
        });

        it("returns maximum value for topmost point", () => {
            equal(numericAxis.getValue(new Point(0, 0)), 1.2);
        });

        it("returns value for middle point", () => {
            close(numericAxis.getValue(new Point(0, 350)), 0.5, TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / getValue / Vertical / Reverse', () => {
        beforeEach(() => {
            numericAxis = new NumericAxis(0, 1, {
                vertical: true,
                reverse: true,
                labels: { visible: false }
            });

            numericAxis.reflow(chartBox);
        });

        it("returns minimum value for topmost  point", () => {
            equal(numericAxis.getValue(new Point(0, 0)), 0);
        });

        it("returns maximum value for bottommost point", () => {
            equal(numericAxis.getValue(new Point(0, 599)), 1.2);
        });

        it("returns value for middle point", () => {
            close(numericAxis.getValue(new Point(0, 250)), 0.5, TOLERANCE);
        });
    });

})();

(function() {
    const lineSeriesData = [{
        name: "Value A",
        type: "line",
        data: [0, 1]
    }];
    const barSeriesData =  [{
        name: "Value A",
        type: "bar",
        data: [0, 1]
    }];
    let plotArea, plotBands;

    function getPlotBands() {
        const axis = plotArea.axisX instanceof NumericAxis ? plotArea.axisX : plotArea.axisY;
        return axis._plotbandGroup;
    }

    function createPlotArea(series, valueAxisOptions) {
        const valueAxis = valueAxisOptions || {
            plotBands: [{
                from: 0.2,
                to: 0.3,
                color: "red",
                opacity: 0.5
            }],
            labels: {
                font: "16px Verdana, sans-serif"
            }
        };
        plotArea = new CategoricalPlotArea(series, {
            valueAxis: valueAxis,
            categoryAxis: {
                categories: ["A"],
                labels: {
                    font: "16px Verdana, sans-serif"
                }
            }
        });

        plotArea.reflow(chartBox);
        plotArea.renderVisual();
        plotBands = getPlotBands().children[0];
    }

    // ------------------------------------------------------------
    describe('Numeric Axis / Plot Bands / Horizontal', () => {
        beforeEach(() => {
            createPlotArea(lineSeriesData);
        });

        it("renders box", () => {
            sameRectPath(plotBands, [33, 433, 799, 481], TOLERANCE);
        });

        it("renders color", () => {
            equal(plotBands.options.fill.color, "red");
        });

        it("renders opacity", () => {
            equal(plotBands.options.fill.opacity, 0.5);
        });

        it("renders z index", () => {
            equal(getPlotBands().options.zIndex, -1);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Plot Bands / Vertical', () => {
        beforeEach(() => {

            createPlotArea(barSeriesData);
        });

        it("renders box", () => {
            sameRectPath(plotBands, [147, 0, 211, 576], TOLERANCE);
        });

        it("renders color", () => {
            equal(plotBands.options.fill.color, "red");
        });

        it("renders opacity", () => {
            equal(plotBands.options.fill.opacity, 0.5);
        });

        it("renders z index", () => {
            equal(getPlotBands().options.zIndex, -1);
        });
    });

    describe('Numeric Axis / Plot Bands / limit', () => {
        beforeEach(() => {
            createPlotArea(lineSeriesData, {
                min: 4,
                max: 10,
                plotBands: [{
                    from: 3,
                    to: 7,
                    color: "red",
                    opacity: 0.5
                }],
                labels: {
                    font: "16px Verdana, sans-serif"
                }
            });
        });

        it("limits plotBands slot", () => {
            arrayClose([plotBands.segments[0].anchor().y, plotBands.segments[3].anchor().y],
                 [291, 576], TOLERANCE);
        });

        it("do not render plotBands if the have zero size", () => {
            const axis = new NumericAxis(3, 10, {
                plotBands: [{
                    from: 1,
                    to: 2,
                    color: "red",
                    opacity: 0.5
                }, {
                    from: 3,
                    to: 3,
                    color: "red",
                    opacity: 0.5
                }],
                labels: {
                    font: "16px Verdana, sans-serif"
                },
                min: 3
            });
            axis.reflow(chartBox);

            plotArea = new CategoricalPlotArea([{}], { });
            plotArea.reflow(chartBox);
            axis.plotArea = plotArea;
            axis.pane = { axes: [] };
            axis.renderVisual();

            equal(axis._plotbandGroup.children.length, 0);
        });
    });

})();


(function() {
    const lineSeriesData = [{
        name: "Value A",
        type: "line",
        data: [100]
    }];
    const barSeriesData =  [{
        name: "Value A",
        type: "bar",
        data: [100]
    }];
    let plotArea, title, titleTextBox, titleBackground, titleBox;

    function createPlotArea(series, plotOptions) {
        plotArea = new CategoricalPlotArea(series, deepExtend({
            valueAxis: {
                title: {
                    font: "16px Verdana, sans-serif",
                    text: "text",
                    color: "red",
                    background: "green",
                    opacity: 0.33,
                    position: "center"
                },
                labels: {
                    font: "16px Verdana, sans-serif"
                }
            },
            categoryAxis: {
                categories: ["A"],
                labels: {
                    font: "16px Verdana, sans-serif"
                }
            }
        }, plotOptions));

        plotArea.reflow(chartBox);
        plotArea.renderVisual();
        numericAxis = plotArea.axisX instanceof NumericAxis ? plotArea.axisX : plotArea.axisY;
        if (numericAxis.title) {
            titleTextBox = numericAxis.title.visual;
            titleBackground = titleTextBox.children[0];
            title = titleTextBox.children[1];
        }
    }

    // ------------------------------------------------------------
    describe('Numeric Axis / Title / Horizontal', () => {
        beforeEach(() => {
            createPlotArea(barSeriesData);
            titleBox = plotArea.axisX.title.box;
        });

        it("does not change line box width", () => {
            const box = plotArea.axisX.lineBox();
            equal([box.x1, box.x2], [17, 788]);
        });

        it("positioned at center", () => {
            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 387, 585, 419, 600 ], TOLERANCE);
        });

        it("positioned left", () => {
            createPlotArea(barSeriesData, { valueAxis: { title: { position: "left" }}});
            titleBox = plotArea.axisX.title.box;

            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 17, 585, 49, 600 ], TOLERANCE);
        });

        it("positioned right", () => {
            createPlotArea(barSeriesData, { valueAxis: { title: { position: "right" }}});
            titleBox = plotArea.axisX.title.box;

            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 757, 585, 789, 600 ], TOLERANCE);
        });

        it("renders color", () => {
            equal(title.options.fill.color, "red");
        });

        it("renders opacity", () => {
            equal(titleBackground.options.fill.opacity, 0.33);
        });

        it("renders zIndex", () => {
            equal(titleTextBox.options.zIndex, 1);
        });

        it("hidden when visible is false", () => {
            createPlotArea(barSeriesData, { valueAxis: { title: { visible: false }}});
            equal(plotArea.axisX.title, undefined);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Horizontal / Mirrored / Title', () => {
        beforeEach(() => {
            createPlotArea(barSeriesData, { valueAxis: { labels: { mirror: true } } });
            titleBox = plotArea.axisX.title.box;
        });

        it("does not change line box width", () => {
            const box = plotArea.axisX.lineBox();
            arrayClose([box.x1, box.x2], [17, 788]);
        });

        it("positioned at center", () => {
            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 387, 560, 419, 575 ], TOLERANCE);
        });

        it("positioned left", () => {
            createPlotArea(barSeriesData, {
                valueAxis: { labels: { mirror: true }, title: { position: "left" }}
            });

            titleBox = plotArea.axisX.title.box;

            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 17, 560, 49, 575 ], TOLERANCE);
        });

        it("positioned right", () => {
            createPlotArea(barSeriesData, {
                valueAxis: { labels: { mirror: true }, title: { position: "right" }}
            });

            titleBox = plotArea.axisX.title.box;

            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 757, 560, 789, 575 ], TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Title / Vertical', () => {
        beforeEach(() => {
            createPlotArea(lineSeriesData);
            titleBox = plotArea.axisY.title.box;
        });

        it("does not change line box height", () => {
            const box = plotArea.axisY.lineBox();
            arrayClose([box.y1, box.y2], [9, 576], TOLERANCE);
        });

        it("position at center", () => {
            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 0, 276.5, 15, 307.5 ], TOLERANCE);
        });

        it("positioned bottom", () => {
            createPlotArea(lineSeriesData, { valueAxis: { title: { position: "bottom" }}});
            titleBox = plotArea.axisY.title.box;

            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 0, 545, 16, 577 ], TOLERANCE);
        });

        it("positioned top", () => {
            createPlotArea(lineSeriesData, { valueAxis: { title: { position: "top" }}});
            titleBox = plotArea.axisY.title.box;

            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 0, 7.5, 15, 39.5 ], TOLERANCE);
        });

        it("renders color", () => {
            equal(title.options.fill.color, "red");
        });

        it("renders opacity", () => {
            equal(titleBackground.options.fill.opacity, 0.33);
        });

        it("renders zIndex", () => {
            equal(titleTextBox.options.zIndex, 1);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Vertical / Mirrored / Title', () => {
        beforeEach(() => {
            createPlotArea(lineSeriesData, { valueAxis: { labels: { mirror: true } } });
            titleBox = plotArea.axisY.title.box;
        });

        it("does not change line box height", () => {
            const box = plotArea.axisY.lineBox();
            arrayClose([box.y1, box.y2], [9, 576], TOLERANCE);
        });

        it("position at center", () => {
            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 33, 276.5, 48, 307.5 ], TOLERANCE);
        });

        it("positioned bottom", () => {
            createPlotArea(lineSeriesData, {
                valueAxis: { labels: { mirror: true }, title: { position: "bottom" }}
            });

            titleBox = plotArea.axisY.title.box;

            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 33, 545, 48, 577 ], TOLERANCE);
        });

        it("positioned top", () => {
            createPlotArea(lineSeriesData, {
                valueAxis: { labels: { mirror: true }, title: { position: "top" }}
            });

            titleBox = plotArea.axisY.title.box;

            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 33, 7.5, 48, 39.5 ], TOLERANCE);
        });
    });

})();

(function() {
    let chart, plotArea, label;

    function axisLabelClick(clickHandler, options) {
        chart = createChart(deepExtend({
            series: [{
                type: "line",
                data: [1, 2, 3]
            }],
            axisLabelClick: clickHandler
        }, options));

        plotArea = chart._model.children[1];
        label = getChartDomElement(plotArea.valueAxis.labels[1]);

        clickChart(chart, label);
    }

    // ------------------------------------------------------------
    describe('Numeric Axis / Events / axisLabelClick', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when clicking axis labels", 1, () => {
            axisLabelClick(function() { ok(true); });
        });

        it("event arguments contain axis options", 1, () => {
            axisLabelClick(function(e) {
                equal(e.axis.type, "numeric");
            });
        });

        it("event arguments contain DOM element", 1, () => {
            axisLabelClick(function(e) {
                ok(e.element === label);
            });
        });

        it("event arguments contain category index", 1, () => {
            axisLabelClick(function(e) {
                equal(e.index, 1);
            });
        });

        it("category index is correct when step is defined", 1, () => {
            axisLabelClick(function(e) {
                equal(e.index, 2);
            }, {
                valueAxis: {
                    labels: {
                        step: 2
                    }
                }
            });
        });

        it("event arguments contain category name as text", 1, () => {
            axisLabelClick(function(e) {
                equal(e.text, "0.5");
            });
        });

        it("event arguments contain category name as value", 1, () => {
            axisLabelClick(function(e) {
                equal(e.value, 0.5);
            });
        });
    });

})();

(function() {
    const axisBox = new Box(0, 0, 800, 600);
    let numericAxis, r;

    // ------------------------------------------------------------
    describe('Numeric Axis / Vertical / translateRange', () => {
        beforeEach(() => {
            numericAxis = new NumericAxis(0, 1, {});
            numericAxis.reflow(axisBox);
        });

        it("positive delta translates range down", () => {
            r = numericAxis.translateRange(600);
            equal(Math.round(r.min), -1);
            equal(Math.round(r.max), -0);
        });

        it("negative delta translates range up", () => {
            r = numericAxis.translateRange(-600);
            equal(Math.round(r.min), 1);
            equal(Math.round(r.max), 2);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Vertical / Reverse / translateRange', () => {
        beforeEach(() => {
            numericAxis = new NumericAxis(0, 1, { reverse: true });
            numericAxis.reflow(axisBox);
        });

        it("positive delta translates range down", () => {
            r = numericAxis.translateRange(600);
            equal(Math.round(r.min), 1);
            equal(Math.round(r.max), 2);
        });

        it("negative delta translates range up", () => {
            r = numericAxis.translateRange(-600);
            equal(Math.round(r.min), -1);
            equal(Math.round(r.max), -0);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Horizontal / translateRange', () => {
        beforeEach(() => {
            numericAxis = new NumericAxis(0, 1, { vertical: false });
            numericAxis.reflow(axisBox);
        });

        it("positive delta translates range right", () => {
            r = numericAxis.translateRange(800);
            equal(Math.round(r.min), 1);
            equal(Math.round(r.max), 2);
        });

        it("negative delta translates range right", () => {
            r = numericAxis.translateRange(-800);
            equal(Math.round(r.min), -1);
            equal(Math.round(r.max), -0);
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Horizontal / Reverse / translateRange', () => {
        beforeEach(() => {
            numericAxis = new NumericAxis(0, 1, { vertical: false, reverse: true });
            numericAxis.reflow(axisBox);
        });

        it("positive delta translates range right", () => {
            r = numericAxis.translateRange(800);
            equal(Math.round(r.min), -1);
            equal(Math.round(r.max), -0);
        });

        it("negative delta translates range right", () => {
            r = numericAxis.translateRange(-800);
            equal(Math.round(r.min), 1);
            equal(Math.round(r.max), 2);
        });
    });

})();

(function() {
    const ACTUAL_TICK_SIZE = 5;
    const MARGIN = 5;
    let axisBox, axis;

    function LabelMock(box) {
        this.box = box;
        this.options = {};
        this.reflow = function(box) {
            this.box = box;
        };
    }

    // ------------------------------------------------------------
    describe('Numeric Axis / Horizontal / reflow', () => {
        beforeEach(() => {
            axis = new NumericAxis(0, 1, { vertical: false, margin: MARGIN });
            axis.labels = [new LabelMock(new Box(0, 0, 20, 20)), new LabelMock(new Box(0, 0, 20, 30))];
            axis.parent = {
                box: new Box(0, 0, 100, 100),
                getRoot: function() {
                    return this;
                }
            };
            axisBox = new Box(0, 0, 50, 50);
            axis.getActualTickSize = function() {
                return ACTUAL_TICK_SIZE;
            };
        });

        it("box height is equal to the maximum label height plus the tick size plus the margin ", () => {
            axis.reflow(axisBox);
            equal(axis.box.height(), 30 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("box height includes title height if title is set", () => {
            axis.title = new LabelMock(new Box(0, 0, 20, 40));
            axis.reflow(axisBox);
            equal(axis.box.height(), 70 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("only labels with height that can be fitted in the container box are taken into account", () => {
            axis.labels.push(new LabelMock(new Box(0, 0, 20, 101 - ACTUAL_TICK_SIZE - MARGIN)));
            axis.reflow(axisBox);
            equal(axis.box.height(), 30 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("only labels with height that can be fitted in the container box including the title are taken into account", () => {
            axis.title = new LabelMock(new Box(0, 0, 20, 40));
            axis.labels.push(new LabelMock(new Box(0, 0, 20, 61 - ACTUAL_TICK_SIZE - MARGIN)));
            axis.reflow(axisBox);
            equal(axis.box.height(), 70 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("sets label rotation origin to top", () => {
            axis.reflow(axisBox);
            equal(axis.labels[0].options.rotationOrigin, "top");
        });

        it("sets label rotation origin to bottom if labels are mirrored", () => {
            axis.options.labels.mirror = true;
            axis.reflow(axisBox);
            equal(axis.labels[0].options.rotationOrigin, "bottom");
        });
    });

    // ------------------------------------------------------------
    describe('Numeric Axis / Vertical / reflow', () => {
        beforeEach(() => {
            axis = new NumericAxis(0, 1, { vertical: true, margin: MARGIN });
            axis.labels = [new LabelMock(new Box(0, 0, 20, 20)), new LabelMock(new Box(0, 0, 30, 20))];
            axis.parent = {
                box: new Box(0, 0, 100, 100),
                getRoot: function() {
                    return this;
                }
            };
            axisBox = new Box(0, 0, 50, 50);
            axis.getActualTickSize = function() {
                return ACTUAL_TICK_SIZE;
            };
        });

        it("box width is equal to the maximum label width plus the tick size plus the margin", () => {
            axis.reflow(axisBox);
            equal(axis.box.width(), 30 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("box width includes title width if title is set", () => {
            axis.title = new LabelMock(new Box(0, 0, 40, 20));
            axis.reflow(axisBox);
            equal(axis.box.width(), 70 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("only labels with width that can be fitted in the container box are taken into account", () => {
            axis.labels.push(new LabelMock(new Box(0, 0, 101 - ACTUAL_TICK_SIZE - MARGIN, 20)));
            axis.reflow(axisBox);
            equal(axis.box.width(), 30 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("only labels with width that can be fitted in the container box including the title are taken into account", () => {
            axis.title = new LabelMock(new Box(0, 0, 40, 20));
            axis.labels.push(new LabelMock(new Box(0, 0, 61 - ACTUAL_TICK_SIZE - MARGIN, 20)));
            axis.reflow(axisBox);
            equal(axis.box.width(), 70 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("sets label rotation origin to right", () => {
            axis.reflow(axisBox);
            equal(axis.labels[0].options.rotationOrigin, "right");
        });

        it("sets label rotation origin to bottom if labels are mirrored", () => {
            axis.options.labels.mirror = true;
            axis.reflow(axisBox);
            equal(axis.labels[0].options.rotationOrigin, "left");
        });
    });

})();

(function() {
    let axisBox, axis;

    function LabelMock(box) {
        this.box = box;
        this.options = {};
        this.reflow = function() {};
    }

    function setupAxis(options) {
        axis = new NumericAxis(0, 1, deepExtend({
            vertical: false,
            labels: {
                rotation: "auto"
            },
            majorUnit: 0.5,
            max: 1,
            min: 0
        }, options));
        axisBox = new Box(0, 0, 50, 50);
        axis.labels = [new LabelMock(new Box(0, 0, 20, 20)), new LabelMock(new Box(0, 0, 30, 20))];
    }

    // ------------------------------------------------------------
    describe('Numeric Axis / autoRotateLabels', () => {
        beforeEach(() => {
            setupAxis();
        });

        it("rotates labels with -45 degrees if there is a label with width bigger than the slot width", () => {
            axis.reflow(axisBox);
            axis.autoRotateLabels();

            equal(axis.labels[0].options.rotation, -45);
            equal(axis.labels[1].options.rotation, -45);
        });

        it("rotates labels with -90 degrees if there is a label with height bigger than the slot width", () => {
            axis.labels[1].box.y2 = 30;
            axis.reflow(axisBox);
            axis.autoRotateLabels();

            equal(axis.labels[0].options.rotation, -90);
            equal(axis.labels[1].options.rotation, -90);
        });

        it("does not rotate labels with -90 degrees if there is a label with height bigger than the slot width but its width is smaller", () => {
            axis.labels[1].box.x2 = 20;
            axis.labels[1].box.y2 = 30;
            axis.reflow(axisBox);
            axis.autoRotateLabels();

            ok(!axis.labels[0].options.rotation);
            ok(!axis.labels[1].options.rotation);
        });

        it("reflows rotated labels", 2, () => {
            axis.reflow(axisBox);
            axis.labels[0].reflow = axis.labels[1].reflow = function() {
                ok(true);
            };
            axis.autoRotateLabels();
        });

        it("does not rotate labels if there isn't a label with width bigger than the slot width", () => {
            axis.labels[1].box.x1 = 20;
            axis.reflow(axisBox);
            axis.autoRotateLabels();

            ok(!axis.labels[0].options.rotation);
            ok(!axis.labels[1].options.rotation);
        });

        it("does not rotate labels if the axis is vertical", () => {
            axis.options.vertical = true;
            axis.reflow(axisBox);
            axis.autoRotateLabels();

            ok(!axis.labels[0].options.rotation);
            ok(!axis.labels[1].options.rotation);
        });

        it("does not rotate labels if auto rotation is not enabled", () => {
            setupAxis({
                labels: {
                    rotation: 0
                }
            });
            axis.reflow(axisBox);
            axis.autoRotateLabels();

            ok(!axis.labels[0].options.rotation);
            ok(!axis.labels[1].options.rotation);
        });
    });
})();
