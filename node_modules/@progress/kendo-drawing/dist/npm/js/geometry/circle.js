module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(162);


/***/ },

/***/ 104:
/***/ function(module, exports) {

	module.exports = require("../mixins/observers-mixin");

/***/ },

/***/ 152:
/***/ function(module, exports) {

	module.exports = require("../accessors/define-accessors");

/***/ },

/***/ 154:
/***/ function(module, exports) {

	module.exports = require("./math/rad");

/***/ },

/***/ 158:
/***/ function(module, exports) {

	module.exports = require("./math/ellipse-extreme-angles");

/***/ },

/***/ 160:
/***/ function(module, exports) {

	module.exports = require("./point");

/***/ },

/***/ 161:
/***/ function(module, exports) {

	module.exports = require("./rect");

/***/ },

/***/ 162:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _defineAccessors = __webpack_require__(152);

	var _defineAccessors2 = _interopRequireDefault(_defineAccessors);

	var _observersMixin = __webpack_require__(104);

	var _observersMixin2 = _interopRequireDefault(_observersMixin);

	var _point = __webpack_require__(160);

	var _point2 = _interopRequireDefault(_point);

	var _rect = __webpack_require__(161);

	var _rect2 = _interopRequireDefault(_rect);

	var _rad = __webpack_require__(154);

	var _rad2 = _interopRequireDefault(_rad);

	var _ellipseExtremeAngles = __webpack_require__(158);

	var _ellipseExtremeAngles2 = _interopRequireDefault(_ellipseExtremeAngles);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var PI_DIV_2 = Math.PI / 2;

	var Circle = function () {
	    function Circle() {
	        var center = arguments.length <= 0 || arguments[0] === undefined ? new _point2.default() : arguments[0];
	        var radius = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	        _classCallCheck(this, Circle);

	        this.setCenter(center);
	        this.setRadius(radius);
	    }

	    _createClass(Circle, [{
	        key: 'setCenter',
	        value: function setCenter(value) {
	            this._observerField("center", _point2.default.create(value));
	            this.geometryChange();
	            return this;
	        }
	    }, {
	        key: 'getCenter',
	        value: function getCenter() {
	            return this.center;
	        }
	    }, {
	        key: 'equals',
	        value: function equals(other) {
	            return other && other.center.equals(this.center) && other.radius === this.radius;
	        }
	    }, {
	        key: 'clone',
	        value: function clone() {
	            return new Circle(this.center.clone(), this.radius);
	        }
	    }, {
	        key: 'pointAt',
	        value: function pointAt(angle) {
	            return this._pointAt((0, _rad2.default)(angle));
	        }
	    }, {
	        key: 'bbox',
	        value: function bbox(matrix) {
	            var extremeAngles = (0, _ellipseExtremeAngles2.default)(this.center, this.radius, this.radius, matrix);
	            var minPoint = _point2.default.maxPoint();
	            var maxPoint = _point2.default.minPoint();

	            for (var i = 0; i < 4; i++) {
	                var currentPointX = this._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);
	                var currentPointY = this._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);
	                var currentPoint = new _point2.default(currentPointX.x, currentPointY.y);

	                minPoint = _point2.default.min(minPoint, currentPoint);
	                maxPoint = _point2.default.max(maxPoint, currentPoint);
	            }

	            return _rect2.default.fromPoints(minPoint, maxPoint);
	        }
	    }, {
	        key: '_pointAt',
	        value: function _pointAt(angle) {
	            var center = this.center;
	            var radius = this.radius;


	            return new _point2.default(center.x + radius * Math.cos(angle), center.y + radius * Math.sin(angle));
	        }
	    }, {
	        key: 'containsPoint',
	        value: function containsPoint(point) {
	            var center = this.center;
	            var radius = this.radius;

	            var inCircle = Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2) <= Math.pow(radius, 2);
	            return inCircle;
	        }
	    }, {
	        key: '_isOnPath',
	        value: function _isOnPath(point, width) {
	            var center = this.center;
	            var radius = this.radius;

	            var pointDistance = center.distanceTo(point);

	            return radius - width <= pointDistance && pointDistance <= radius + width;
	        }
	    }]);

	    return Circle;
	}();

	(0, _defineAccessors2.default)(Circle.prototype, ["radius"]);
	_observersMixin2.default.extend(Circle.prototype);

	exports.default = Circle;

/***/ }

/******/ });