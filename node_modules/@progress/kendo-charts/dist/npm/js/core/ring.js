module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(527);


/***/ },

/***/ 60:
/***/ function(module, exports) {

	module.exports = require("../common/constants");

/***/ },

/***/ 461:
/***/ function(module, exports) {

	module.exports = require("./box");

/***/ },

/***/ 466:
/***/ function(module, exports) {

	module.exports = require("./point");

/***/ },

/***/ 469:
/***/ function(module, exports) {

	module.exports = require("../common/rad");

/***/ },

/***/ 474:
/***/ function(module, exports) {

	module.exports = require("../common/round");

/***/ },

/***/ 527:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _box = __webpack_require__(461);

	var _box2 = _interopRequireDefault(_box);

	var _point = __webpack_require__(466);

	var _point2 = _interopRequireDefault(_point);

	var _constants = __webpack_require__(60);

	var _rad = __webpack_require__(469);

	var _rad2 = _interopRequireDefault(_rad);

	var _clockwise = __webpack_require__(528);

	var _clockwise2 = _interopRequireDefault(_clockwise);

	var _round = __webpack_require__(474);

	var _round2 = _interopRequireDefault(_round);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Ring = function () {
	    function Ring(center, innerRadius, radius, startAngle, angle) {
	        _classCallCheck(this, Ring);

	        this.center = center;
	        this.innerRadius = innerRadius;
	        this.radius = radius;
	        this.startAngle = startAngle;
	        this.angle = angle;
	    }

	    _createClass(Ring, [{
	        key: 'clone',
	        value: function clone() {
	            return new Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);
	        }
	    }, {
	        key: 'middle',
	        value: function middle() {
	            return this.startAngle + this.angle / 2;
	        }
	    }, {
	        key: 'setRadius',
	        value: function setRadius(newRadius, innerRadius) {
	            if (innerRadius) {
	                this.innerRadius = newRadius;
	            } else {
	                this.radius = newRadius;
	            }

	            return this;
	        }

	        // TODO: Remove and replace with Point.onCircle

	    }, {
	        key: 'point',
	        value: function point(angle, innerRadius) {
	            var radianAngle = (0, _rad2.default)(angle);
	            var ax = Math.cos(radianAngle);
	            var ay = Math.sin(radianAngle);
	            var radius = innerRadius ? this.innerRadius : this.radius;
	            var x = (0, _round2.default)(this.center.x - ax * radius, _constants.COORD_PRECISION);
	            var y = (0, _round2.default)(this.center.y - ay * radius, _constants.COORD_PRECISION);

	            return new _point2.default(x, y);
	        }
	    }, {
	        key: 'adjacentBox',
	        value: function adjacentBox(distance, width, height) {
	            var sector = this.clone().expand(distance);
	            var midAndle = sector.middle();
	            var midPoint = sector.point(midAndle);
	            var hw = width / 2;
	            var hh = height / 2;
	            var sa = Math.sin((0, _rad2.default)(midAndle));
	            var ca = Math.cos((0, _rad2.default)(midAndle));
	            var x = midPoint.x - hw;
	            var y = midPoint.y - hh;

	            if (Math.abs(sa) < 0.9) {
	                x += hw * -ca / Math.abs(ca);
	            }

	            if (Math.abs(ca) < 0.9) {
	                y += hh * -sa / Math.abs(sa);
	            }

	            return new _box2.default(x, y, x + width, y + height);
	        }
	    }, {
	        key: 'containsPoint',
	        value: function containsPoint(p) {
	            var center = this.center;
	            var innerRadius = this.innerRadius;
	            var radius = this.radius;
	            var startAngle = this.startAngle;
	            var endAngle = this.startAngle + this.angle;
	            var dx = p.x - center.x;
	            var dy = p.y - center.y;
	            var vector = new _point2.default(dx, dy);
	            var startPoint = this.point(startAngle);
	            var startVector = new _point2.default(startPoint.x - center.x, startPoint.y - center.y);
	            var endPoint = this.point(endAngle);
	            var endVector = new _point2.default(endPoint.x - center.x, endPoint.y - center.y);
	            var dist = (0, _round2.default)(dx * dx + dy * dy, _constants.COORD_PRECISION);

	            return (startVector.equals(vector) || (0, _clockwise2.default)(startVector, vector)) && !(0, _clockwise2.default)(endVector, vector) && dist >= innerRadius * innerRadius && dist <= radius * radius;
	        }
	    }, {
	        key: 'getBBox',
	        value: function getBBox() {
	            var box = new _box2.default(_constants.MAX_VALUE, _constants.MAX_VALUE, _constants.MIN_VALUE, _constants.MIN_VALUE);
	            var startAngle = (0, _round2.default)(this.startAngle % 360);
	            var endAngle = (0, _round2.default)((startAngle + this.angle) % 360);
	            var innerRadius = this.innerRadius;
	            var allAngles = [0, 90, 180, 270, startAngle, endAngle].sort(numericComparer);
	            var startAngleIndex = allAngles.indexOf(startAngle);
	            var endAngleIndex = allAngles.indexOf(endAngle);
	            var angles = void 0;

	            if (startAngle === endAngle) {
	                angles = allAngles;
	            } else {
	                if (startAngleIndex < endAngleIndex) {
	                    angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);
	                } else {
	                    angles = [].concat(allAngles.slice(0, endAngleIndex + 1), allAngles.slice(startAngleIndex, allAngles.length));
	                }
	            }

	            for (var i = 0; i < angles.length; i++) {
	                var point = this.point(angles[i]);
	                box.wrapPoint(point);
	                box.wrapPoint(point, innerRadius);
	            }

	            if (!innerRadius) {
	                box.wrapPoint(this.center);
	            }

	            return box;
	        }
	    }, {
	        key: 'expand',
	        value: function expand(value) {
	            this.radius += value;
	            return this;
	        }
	    }]);

	    return Ring;
	}();

	function numericComparer(a, b) {
	    return a - b;
	}

	exports.default = Ring;

/***/ },

/***/ 528:
/***/ function(module, exports) {

	module.exports = require("../common/clockwise");

/***/ }

/******/ });