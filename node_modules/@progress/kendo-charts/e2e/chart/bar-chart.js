import 'core-js/es6';

import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';
import { $ } from 'e2e-utils';

import { RootElement, Title, Box } from '../../src/core';
import BarChart from '../../src/chart/bar-chart/bar-chart';
import BarLabel from '../../src/chart/bar-chart/bar-label';
import Bar from '../../src/chart/bar-chart/bar';
import ClusterLayout from '../../src/chart/cluster-layout';
import StackWrap from '../../src/chart/stack-wrap';
import Legend from '../../src/chart/legend/legend';
import CategoricalPlotArea from '../../src/chart/plotarea/categorical-plotarea';
import categoriesCount from '../../src/chart/utils/categories-count';
import { deepExtend, map, last, alignPathToPixel } from '../../src/common';

import { ok, equal, arrayClose, close, notClose, createSpy, sameLinePath, sameBox, each } from '../../test/test-helpers';
import { clickChart, triggerEvent, createChart, destroyChart, getChartDomElement }  from '../test-helpers';

const chartBox = new Box(0, 0, 800, 600);
let series, visual, chart;

function BarStub(box) {
    this.box = box;
}

BarStub.prototype = {
    reflow: function(box) {
        this.box = box;
    }
};

function setupBarChart(plotArea, options) {
    options.gap = 1.5;
    series = new BarChart(plotArea, options);

    const root = new RootElement();
    root.append(series);
    root.reflow();

    root.renderVisual();
}

function stubPlotArea(getCategorySlot, getValueSlot, options) {
    return new function() {
        this.categoryAxis = this.primaryCategoryAxis = {
            getSlot: getCategorySlot,
            options: {
                axisCrossingValue: 0,
                categories: options.categoryAxis.categories
            }
        };

        this.valueAxis = {
            getSlot: getValueSlot,
            options: {
                axisCrossingValue: 0
            },
            startValue: function() {
                return 0;
            }
        };

        this.namedCategoryAxes = { };
        this.namedValueAxes = {};

        this.seriesCategoryAxis = function(series) {
            return series.categoryAxis ? this.namedCategoryAxes[series.categoryAxis] : this.primaryCategoryAxis;
        };

        this.options = options;
    };
}

function pointTextBox(idx) {
    return series.points[idx].label.textBox;
}

function pointText(idx) {
    return pointTextBox(idx).visual.children[1];
}

(function() {
    const positiveSeries = { data: [1, 2], labels: {} };
    const negativeSeries = { data: [-1, -2], labels: {} };
    const sparseSeries = { data: [undefined, 2], labels: {} };
    const VALUE_AXIS_MAX = 2;
    const TOLERANCE = 0.1;
    let CATEGORY_AXIS_Y = 2;

    const getCategorySlot = function(categoryIndex) {
        return new Box(categoryIndex, CATEGORY_AXIS_Y,
        categoryIndex + 1, CATEGORY_AXIS_Y);
    };

    const getValueSlot = function(from, to) {
        const reverse = this.options.reverse;
        const fromY = CATEGORY_AXIS_Y + (reverse ? from : -from);
        const toY = CATEGORY_AXIS_Y + (reverse ? to : -to);
        const slotTop = Math.min(fromY, toY);
        const slotBottom = Math.max(fromY, toY);

        return new Box(0, slotTop, 0, slotBottom);
    };

    const plotArea = stubPlotArea(getCategorySlot, getValueSlot, {
            categoryAxis: {
                categories: ["A", "B"]
            }
        }
    );

    // ------------------------------------------------------------
    describe('Bar Chart', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
                series: [
                    {
                        data: [1, 2]
                    }, {
                        data: [1, 2],
                        zIndex: 1
                    }
                ]
            });
            visual = series.visual;
        });

        it("creates animation", () => {
            ok(series.animation);
        });

        it("sets animation origin to the start of the category axis", () => {
            const slot = plotArea.categoryAxis.getSlot(0);
            ok(series.animation.options.origin.equals({x: slot.x1, y: slot.y1}));
        });

        it("sets animation origin to the value axis start slot if the chart is stacked", () => {
            const plotArea = stubPlotArea(getCategorySlot, function(a, b) {
                    return new Box(0, a, 0, (b || a));
                }, {
                    categoryAxis: {
                        categories: ["A", "B"]
                    }
                }
            );

            plotArea.valueAxis.startValue = function() {
                return 1;
            };

            setupBarChart(plotArea, {
                series: [
                    {
                        data: [-1]
                    }, {
                        data: [1]
                    }
                ],
                isStacked: true
            });

            ok(series.animation.options.origin.equals({x: 0, y: 1}));
        });

        it("does not create animation on bars", () => {
            ok(!series.points[0].animation);
        });

        it("does create animation on bars with zIndex", () => {
            ok(series.points[1].animation);
        });

        it("copies animation options on bars with zIndex", () => {
            equal(series.points[1].options.animation, series.options.animation);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Positive Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, { series: [ positiveSeries ] });
        });

        it("Creates bars for series data points", () => {
            equal(series.points.length, positiveSeries.data.length);
        });

        it("Reports minimum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, positiveSeries.data[0]);
        });

        it("Reports maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, positiveSeries.data[1]);
        });

        it("Reports correct range with string value", () => {
            setupBarChart(plotArea, { series: [{ data: ["1", "2", "3"] }] });

            equal(series.valueAxisRanges[undefined].min, 1);
            equal(series.valueAxisRanges[undefined].max, 3);
        });

        it("Reports number of categories", () => {
            setupBarChart(plotArea, {series: [ positiveSeries ]});
            equal(categoriesCount(series.options.series), positiveSeries.data.length);
        });

        it("bars are distributed across category axis", () => {
            const barsX = map(series.points, function(bar) {
                return bar.box.x1;
            });

            arrayClose(barsX, [0.3, 1.3], TOLERANCE);
        });

        it("bar bottoms are aligned to category axis", () => {
            const barsY = map(series.points, function(bar) {
                return bar.box.y2;
            });

            equal(barsY, [CATEGORY_AXIS_Y, CATEGORY_AXIS_Y]);
        });

        it("bars have set width", () => {
            each(series.points, function() {
                close(this.box.width(), 0.4, TOLERANCE);
            });
        });

        it("bars have set height according to value", () => {
            const barHeights = map(series.points, function(bar) {
                return bar.box.height();
            });

            equal(barHeights, [1, 2]);
        });

        it("sets bar owner", () => {
            ok(series.points[0].owner === series);
        });

        it("sets bar series", () => {
            ok(series.points[0].series === positiveSeries);
        });

        it("sets bar series index", () => {
            ok(series.points[0].seriesIx === 0);
        });

        it("sets bar category", () => {
            equal(series.points[0].category, "A");
        });

        it("sets correct category if multiple categoryAxis are used", () => {
            const plotArea = new CategoricalPlotArea([{
                type: "bar",
                categoryAxis: "A",
                data: [1, 2]
            }, {
                type: "bar",
                categoryAxis: "B",
                data: [3, 4]
            }], {
                categoryAxis: [{
                    name: "A",
                    categories: [1, 2]
                }, {
                    name: "B",
                    categories: [3, 4]
                }]
            });

            for (let chartIdx = 0; chartIdx < plotArea.charts.length; chartIdx++) {
                const chart = plotArea.charts[chartIdx];
                for (let idx = 0; idx < chart.points.length; idx++) {
                    equal(chart.points[idx].category, chart.points[idx].value);
                }
            }
        });

        it("sets bar dataItem", () => {
            equal(typeof series.points[0].dataItem, "number");
        });

        it("sets bar aboveAxis", () => {
            equal(series.points[0].aboveAxis, true);
        });

        it("sets bar aboveAxis for reversed value axis", () => {
            plotArea.valueAxis.options.reverse = true;

            setupBarChart(plotArea, { series: [ positiveSeries ] });
            equal(series.points[0].aboveAxis, false);

            plotArea.valueAxis.options.reverse = false;
        });

        it("Throws error when unable to locate value axis", () => {
            expect(function() {
                setupBarChart(plotArea, {
                    series: [{ axis: "b", data: [1] }]
                });
            }).toThrowError(/Unable to locate value axis with name b/);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Negative Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, { series: [ negativeSeries ] });
        });

        it("Reports minimum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, negativeSeries.data[1]);
        });

        it("Reports maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, negativeSeries.data[0]);
        });

        it("Reports correct range with string value", () => {
            setupBarChart(plotArea, { series: [{ data: ["-1", "-2", "-3"] }] });

            equal(series.valueAxisRanges[undefined].min, -3);
            equal(series.valueAxisRanges[undefined].max, -1);
        });

        it("bar tops are aligned to category axis", () => {
            const barsY = map(series.points, function(bar) {
                return bar.box.y1;
            });

            equal(barsY, [CATEGORY_AXIS_Y, CATEGORY_AXIS_Y]);
        });

        it("bars have set height according to value", () => {
            const barHeights = map(series.points, function(bar) {
                return bar.box.height();
            });

            equal(barHeights, [1, 2]);
        });

        it("sets bar aboveAxis", () => {
            equal(series.points[0].aboveAxis, false);
        });

        it("sets bar aboveAxis for reversed value axis", () => {
            plotArea.valueAxis.options.reverse = true;

            setupBarChart(plotArea, { series: [ negativeSeries ] });
            equal(series.points[0].aboveAxis, true);

            plotArea.valueAxis.options.reverse = false;
        });
    });

    // ------------------------------------------------------------

    describe('Bar Chart / Values exceeding value axis min or max options ', () => {

        it("values are not limited", () => {
            let calls = 0;
            const plotArea = stubPlotArea(
                function(categoryIndex) {
                    return new Box(categoryIndex, CATEGORY_AXIS_Y,
                                     categoryIndex + 1, CATEGORY_AXIS_Y);
                },
                function(value, axisCrossingValue, limit) {
                    calls++;
                    ok(!limit);
                    return new Box();
                },
                {
                    categoryAxis: {
                        categories: ["A", "B"]
                    }
                }
            );

            setupBarChart(plotArea, { series: [ {data: [1, 2]} ] });
            expect(calls).toBe(2);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Multiple Series', () => {
        beforeEach(() => {
            plotArea.namedValueAxes.secondary = plotArea.valueAxis;

            setupBarChart(plotArea, {
                series: [
                    deepExtend({ }, negativeSeries ),
                    deepExtend({ axis: "secondary" }, positiveSeries )
                ] });
            });

        it("Reports minimum value for primary axis", () => {
            equal(series.valueAxisRanges[undefined].min, negativeSeries.data[1]);
        });

        it("Reports maximum value for primary axis", () => {
            equal(series.valueAxisRanges[undefined].max, negativeSeries.data[0]);
        });

        it("Reports minimum value for secondary axis", () => {
            equal(series.valueAxisRanges.secondary.min, positiveSeries.data[0]);
        });

        it("Reports maximum value for secondary axis", () => {
            equal(series.valueAxisRanges.secondary.max, positiveSeries.data[1]);
        });

        it("Reports number of categories for two series", () => {
            equal(categoriesCount(series.options.series), positiveSeries.data.length);
        });

        it("aboveAxis is set independently for each bar", () => {
            equal(series.points[0].aboveAxis, false);
            equal(series.points[2].aboveAxis, false);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Multiple Category Axes', () => {
        beforeEach(() => {
            chart = createChart({
                series: [{
                    type: "bar",
                    data: [1],
                    categoryAxis: "secondary"
                }],
                valueAxis: {
                    axisCrossingValue: [10, 0]
                },
                categoryAxis: [{
                    categories: ["A"]
                }, {
                    name: "secondary",
                    categories: ["B"]
                }]
            });

            series = chart._model._plotArea.charts[0];
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("sets category axis to first series category axis", () => {
            equal(series.categoryAxis.options.name, "secondary");
        });

        it("bar is marked as above axis with respect to its category axis", () => {
            equal(series.points[0].aboveAxis, true);
        });

        it("bar is rendered from its category axis", () => {
            equal(series.points[0].box.x1, series.categoryAxis.lineBox().x1);
        });

        it("axis crossing value is assumed to be 0", () => {
            delete chart.options.valueAxis.axisCrossingValue;
            chart.refresh();
            series = chart._model._plotArea.charts[0];

            equal(series.points[0].aboveAxis, true);
        });

        it("axisCrossingValues alias is accepted with precedence", () => {
            chart.options.valueAxis.axisCrossingValues = [10, 10]
            chart.refresh();
            series = chart._model._plotArea.charts[0];

            equal(series.points[0].aboveAxis, false);
        });

        it("hides the series if the visible is set to false", () => {
            destroyChart(chart);
            chart = createChart({
                series: [{
                    type: "bar",
                    data: [1],
                    visible: false
                },{
                    type: "bar",
                    data: [1]
                }]
            });

            ok(series.points.length === 1);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Mismatched series', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
            series: [ { data: [1, 2, 3] },
                      positiveSeries
                ]
            });
        });

        it("Reports minimum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, 1);
        });

        it("Reports maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, 3);
        });

        it("Reports number of categories", () => {
            equal(categoriesCount(series.options.series), 3);
        });

        it("bar bottoms are aligned to category axis", () => {
            each(series.points, function() {
                equal(this.box.y2, CATEGORY_AXIS_Y);
            });
            equal(series.points.length, 6);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Missing values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
                series: [{ data: [1, 2, null] }]
            });
        });

        it("Missing values are represented as bars with zero height", () => {
            const barHeights = map(series.points, function(bar) {
                return bar.box.height();
            });

            equal(barHeights, [1, 2, 0]);
        });

        it("ignores null values when reporting minimum series value", () => {
            equal(series.valueAxisRanges[undefined].min, 1);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Cluster', () => {
        beforeEach(() => {
            setupBarChart(plotArea, { series: [ positiveSeries, negativeSeries ] });
        });

        it("bars in first category are clustered", () => {
            equal(series.points[0].box.x2, series.points[1].box.x1);
        });

        it("bars in different panes are not clustered", () => {
            const chart = createChart({
                series: [{
                    type: "column",
                    data: [1]
                }, {
                    type: "column",
                    data: [2],
                    axis: "b"
                }],
                panes: [{
                    name: "top"
                }, {
                    name: "bottom"
                }],
                valueAxis: [{
                }, {
                    name: "b",
                    pane: "bottom"
                }],
                categoryAxis: {
                    categories: ["A"]
                }
            });

            const barCharts = chart._model._plotArea.charts;
            close(barCharts[0].points[0].box.x1, barCharts[1].points[0].box.x1, TOLERANCE);
            destroyChart(chart);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Stack / Positive Values', () => {
        let oldGetSlot;

        beforeEach(() => {
            oldGetSlot = plotArea.valueAxis.getSlot;

            plotArea.valueAxis.getSlot = function(a = 0, b = a) {
                const top = VALUE_AXIS_MAX - Math.max(a, b);
                const bottom = VALUE_AXIS_MAX - Math.min(a, b);
                const slotTop = top;
                const slotBottom = bottom;

                return new Box(0, slotTop, 0, slotBottom);
            };

            setupBarChart(plotArea, {
                series: [ positiveSeries, positiveSeries ],
                isStacked: true }
            );
        });

        afterEach(() => {
           plotArea.valueAxis.getSlot = oldGetSlot;
        });

        it("reports 0 as minumum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, 1);
        });

        it("reports stacked maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, 4);
        });

        it("bars in first category are stacked", () => {
            equal(series.points[1].box.y2, series.points[0].box.y1);
        });

        it("series have 75% margin", () => {
            close(series.points[0].box.x1, 0.3, TOLERANCE);
        });

        it("bars have set height according to value", () => {
            const barHeights = map(series.points, function(bar) {
                return bar.box.height();
            });

            equal(barHeights, [1, 1, 2, 2]);
        });

        it("sets point stackValue", () => {
            equal(series.points[0].stackValue, 1);
            equal(series.points[1].stackValue, 2);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Stack / Negative Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
                series: [ negativeSeries, negativeSeries ],
                isStacked: true
            });
        });

        it("reports stacked minumum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, -4);
        });

        it("reports 0 as maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, -1);
        });

        it("ignores missing values", () => {
            setupBarChart(plotArea, {
                series: [{data: [-1]}, {data: []}],
                isStacked: true
            });
            equal(series.valueAxisRanges[undefined].max, -1);
            equal(series.valueAxisRanges[undefined].min, -1)
        });

        it("bars in first category are stacked", () => {
            equal(series.points[1].box.y1, series.points[0].box.y2);
        });

        it("stack tops are aligned to category axis", () => {
            equal([series.points[0].box.y1, series.points[2].box.y1],
                 [CATEGORY_AXIS_Y, CATEGORY_AXIS_Y]);
        });

        it("bars have set height according to value", () => {
            const barHeights = map(series.points, function(bar) {
                return bar.box.height();
            });

            equal(barHeights, [1, 1, 2, 2]);
        });

        it("stack tops are aligned to 0 line when category axis crossing value is changed", () => {
            CATEGORY_AXIS_Y = 4;

            setupBarChart(plotArea, {
                series: [ negativeSeries, negativeSeries ],
                isStacked: true
            });

            equal([series.points[0].box.y1, series.points[2].box.y1],
                      [4, 4]);

            CATEGORY_AXIS_Y = 2;
        });

        it("sets point stackValue", () => {
            equal(series.points[0].stackValue, -1);
            equal(series.points[1].stackValue, -2);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Stack / Mixed Values', () => {
        let oldGetSlot;

        beforeEach(() => {
            oldGetSlot = plotArea.valueAxis.getSlot;

            plotArea.valueAxis.getSlot = function(a = 0, b = a) {
                const top = VALUE_AXIS_MAX - Math.max(a, b);
                const bottom = VALUE_AXIS_MAX - Math.min(a, b);
                const slotTop = top;
                const slotBottom = bottom;

                return new Box(0, slotTop, 0, slotBottom);
            };

            setupBarChart(plotArea, {
                series: [{
                    data: [1, -1],
                    labels: {}
                }],
                isStacked: true
            });
        });

        afterEach(() => {
            plotArea.valueAxis.getSlot = oldGetSlot;
        });

        it("reports stacked minumum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, -1);
        });

        it("reports stacked maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, 1);
        });

        it("bars have set height according to value", () => {
            const barHeights = map(series.points, function(bar) {
                return bar.box.height();
            });

            equal(barHeights, [1, 1]);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Stack / Mixed Series', () => {
        beforeEach(() => {
            plotArea.namedValueAxes.a = plotArea.valueAxis;
            plotArea.namedValueAxes.b = plotArea.valueAxis;

            setupBarChart(plotArea, {
                series: [
                    // Both series should be on the same axis.
                    // This rule is intentionally broken for the tests.
                    deepExtend({ axis: "a" }, positiveSeries),
                    deepExtend({ axis: "b" }, negativeSeries)
                ],
                isStacked: true
            });
        });

        it("reports stacked minumum value for default axis", () => {
            equal(series.valueAxisRanges.a.min, -2);
        });

        it("reports stacked maximum value for default axis", () => {
            equal(series.valueAxisRanges.a.max, 2);
        });

        it("bars have set height according to value", () => {
            const barHeights = map(series.points, function(bar) {
                return bar.box.height();
            });

            equal(barHeights, [1, 1, 2, 2]);
        });

        it("sets point stackValue", () => {
            equal(series.points[0].stackValue, 1);
            equal(series.points[1].stackValue, -1);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Stack / Missing Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
                series: [ sparseSeries, sparseSeries ],
                isStacked: true }
            );
        });

        it("Reports minimum series value", () => {
            equal(series.valueAxisRanges[undefined].min, 2);
        });

        it("Reports maximum series value", () => {
            equal(series.valueAxisRanges[undefined].max, 4);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / 100% Stacked / Positive Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
                series: [ positiveSeries, positiveSeries ],
                isStacked: true, isStacked100: true }
            );
        });

        it("reports minumum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, 0.5);
        });

        it("reports maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, 1);
        });

        it("rounds plot values sum to 100%", () => {
            const sets = [
                [98.07039, 99.21937, 98.25632, 96.74904, 96.4993439, 99.1569748],
                [1100941, 810169, 395533, 152171, 36724]
            ];

            each(sets, function(i, data) {
                setupBarChart(plotArea, {
                    series: map(data, function(value) {
                        return {
                            data: [value]
                        };
                    }),
                    isStacked: true, isStacked100: true
                });

                const plotRange = series.plotRange(last(series.points));
                close(plotRange[1], 1, 1e-12, "Set: " + data.join(","));
            });
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / 100% Stacked / Negative Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
                series: [ negativeSeries, negativeSeries ],
                isStacked: true, isStacked100: true }
            );
        });

        it("reports minumum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, -1);
        });

        it("reports maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, -0.5);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / 100% Stacked / Mixed Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
                series: [ negativeSeries, positiveSeries ],
                isStacked: true, isStacked100: true }
            );
        });

        it("reports minumum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, -0.5);
        });

        it("reports maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, 0.5);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / 100% Stacked / Missing Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
                series: [ sparseSeries, positiveSeries ],
                isStacked: true, isStacked100: true }
            );
        });

        it("reports minumum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, 0.5);
        });

        it("reports maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, 1);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Grouped Stack / Positive Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
                series: [
                    deepExtend({ stack: "a" }, positiveSeries),
                    deepExtend({ stack: "a" }, positiveSeries),
                    deepExtend({ stack: "b" }, positiveSeries),
                    deepExtend({ stack: "b" }, positiveSeries)
                ],
                isStacked: true
            });
        });

        it("reports stacked minumum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, 1);
        });

        it("reports stacked maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, 4);
        });

        it("bars in first category, first group are stacked", () => {
            equal(series.points[1].box.y2, series.points[0].box.y1);
        });

        it("bars in first category, second group are stacked", () => {
            equal(series.points[3].box.y2, series.points[2].box.y1);
        });

        it("bars in first category, second group are in separate stack", () => {
            ok(series.points[2].box.y2 != series.points[1].box.y1);
        });

        it("groups with no stack are assigned to first stack", () => {
            setupBarChart(plotArea, {
                series: [
                    deepExtend({ stack: "a" }, positiveSeries),
                    positiveSeries
                ],
                isStacked: true
            });

            equal(series.valueAxisRanges[undefined].max, 4);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Grouped Stack / Negative Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
                series: [
                    deepExtend({ stack: "a" }, negativeSeries),
                    deepExtend({ stack: "a" }, negativeSeries),
                    deepExtend({ stack: "b" }, negativeSeries),
                    deepExtend({ stack: "b" }, negativeSeries)
                ],
                isStacked: true
            });
        });

        it("reports stacked minumum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, -4);
        });

        it("reports stacked maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, -1);
        });

        it("bars in first category, first group are stacked", () => {
            equal(series.points[1].box.y1, series.points[0].box.y2);
        });

        it("bars in first category, second group are stacked", () => {
            equal(series.points[3].box.y1, series.points[2].box.y2);
        });

        it("bars in first category, second group are in separate stack", () => {
            ok(series.points[2].box.y1 != series.points[1].box.y2);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Grouped Stack / Mixed Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
                series: [
                    deepExtend({ stack: "a" }, positiveSeries),
                    deepExtend({ stack: "a" }, positiveSeries),
                    deepExtend({ stack: "b" }, negativeSeries),
                    deepExtend({ stack: "b" }, negativeSeries)
                ],
                isStacked: true
            });
        });

        it("reports stacked minumum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, -4);
        });

        it("reports stacked maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, 4);
        });

        it("bars in first category, first group are stacked", () => {
            equal(series.points[1].box.y2, series.points[0].box.y1);
        });

        it("bars in first category, second group are stacked", () => {
            equal(series.points[3].box.y1, series.points[2].box.y2);
        });

        it("bars in first category, second group are in separate stack", () => {
            ok(series.points[2].box.y1 != series.points[1].box.y2);
        });

        it("bars in second category, first group are stacked", () => {
            equal(series.points[5].box.y2, series.points[4].box.y1);
        });

        it("bars in second category, second group are stacked", () => {
            equal(series.points[7].box.y1, series.points[6].box.y2);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Grouped Stack / Mixed Values / Reversed Axes', () => {
        beforeEach(() => {
            plotArea.valueAxis.options.reverse = true;
            setupBarChart(plotArea, {
                series: [
                    deepExtend({ stack: "a" }, positiveSeries),
                    deepExtend({ stack: "a" }, positiveSeries),
                    deepExtend({ stack: "b" }, negativeSeries),
                    deepExtend({ stack: "b" }, negativeSeries)
                ],
                isStacked: true
            });
            plotArea.valueAxis.options.reverse = false;
        });

        it("bars in first category, first group are stacked", () => {
            equal(series.points[1].box.y1, series.points[0].box.y2);
        });

        it("bars in first category, second group are stacked", () => {
            equal(series.points[3].box.y2, series.points[2].box.y1);
        });

        it("bars in second category, first group are stacked", () => {
            equal(series.points[5].box.y1, series.points[4].box.y2);
        });

        it("bars in second category, second group are stacked", () => {
            equal(series.points[7].box.y2, series.points[6].box.y1);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Grouped Stack / Group Syntax', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
                series: [
                    deepExtend({ stack: { group: "a" } }, positiveSeries),
                    deepExtend({ stack: { group: "a" } }, positiveSeries),
                    deepExtend({ stack: { group: "b" } }, positiveSeries),
                    deepExtend({ stack: { group: "b" } }, positiveSeries)
                ],
                isStacked: true
            });
        });

        it("two stacks are created", () => {
            const cluster = series.children[0];
            equal(cluster.children[0]._stackGroup, "a");
            equal(cluster.children[1]._stackGroup, "b");
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Grouped Stack / Multiple Axes', () => {
        beforeEach(() => {
            const smallSeries = { stack: "a", data: [1, 2], axis: "A" };
            const largeSeries = { stack: "b", data: [10, 20], axis: "B" };
            setupBarChart(deepExtend({
                namedValueAxes: { "A": plotArea.valueAxis, "B": plotArea.valueAxis }
            }, plotArea), {
                series: [
                    smallSeries,
                    smallSeries,
                    largeSeries,
                    largeSeries
                ],
                isStacked: true
            });
        });

        it("reports stacked minumum value for first axis", () => {
            equal(series.valueAxisRanges["A"].min, 1);
        });

        it("reports stacked maximum value for first axis", () => {
            equal(series.valueAxisRanges["A"].max, 4);
        });

        it("reports stacked minumum value for second axis", () => {
            equal(series.valueAxisRanges["B"].min, 10);
        });

        it("reports stacked maximum value for second axis", () => {
            equal(series.valueAxisRanges["B"].max, 40);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Stacked / Panes', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("bars in different panes are not stacked", () => {
            chart = createChart({
                series: [{
                    stack: true,
                    type: "column",
                    data: [1]
                }, {
                    type: "column",
                    data: [2],
                    axis: "b"
                }],
                panes: [{
                    name: "top"
                }, {
                    name: "bottom"
                }],
                valueAxis: [{
                }, {
                    name: "b",
                    pane: "bottom"
                }],
                categoryAxis: {
                    categories: ["A"]
                }
            });

            const barCharts = chart._model._plotArea.charts;
            notClose(barCharts[0].points[0].box.y1, barCharts[1].points[0].box.y2, TOLERANCE);
        });
    });

})();

(function() {
    let barLabel, barBox, text;

    describe('BarLabel', () => {

        it("renders no elements if visible option is false", () => {
            barLabel = new BarLabel("content", {visible: false});
            const root = new RootElement();
            root.append(barLabel);
            root.box = new Box();
            root.renderVisual();

            ok(!barLabel.textBox.visual);
        });
    });

    describe('BarLabel / reflow / vertical', () => {

        it("sets left and right padding to its textbox to fill the bar width", () => {
            barLabel = new BarLabel("content", {vertical: true, padding: {
                left: 0,
                right: 0
            }, margin: 0});
            text = barLabel.children[0];
            text.contentBox = new Box(0, 0, 50, 50);
            barLabel.reflow(new Box(0, 0, 100, 100));

            equal(text.options.padding.left, 25);
            equal(text.options.padding.right, 25);
        });

        it("does not set left and right padding to its textbox if its rotated", () => {
            barLabel = new BarLabel("content", {vertical: true, rotation: 45, padding: {
                left: 0,
                right: 0
            }, margin: 0});
            text = barLabel.children[0];
            text.contentBox = new Box(0, 0, 50, 50);
            barLabel.reflow(new Box(0, 0, 100, 100));

            equal(text.options.padding.left, 0);
            equal(text.options.padding.right, 0);
        });
    });

    describe('BarLabel / reflow / horizontal', () => {

        it("sets top and bottom padding to its textbox to fill the bar height", () => {
            barLabel = new BarLabel("content", {vertical: false, padding: {
                top: 0,
                bottom: 0
            }, margin: 0});
            text = barLabel.children[0];
            text.contentBox = new Box(0, 0, 50, 50);
            barLabel.reflow(new Box(0, 0, 100, 100));

            equal(text.options.padding.top, 25);
            equal(text.options.padding.bottom, 25);
        });

        it("does not set top and bottom padding to its textbox if its rotated", () => {
            barLabel = new BarLabel("content", {vertical: false, rotation: 45, padding: {
                top: 0,
                bottom: 0
            }, margin: 0});
            text = barLabel.children[0];
            text.contentBox = new Box(0, 0, 50, 50);
            barLabel.reflow(new Box(0, 0, 100, 100));

            equal(text.options.padding.top, 0);
            equal(text.options.padding.bottom, 0);
        });

        it("textbox targetbox has positive width if position is outsideEnd and the label is aboveAxis", () => {
            barLabel = new BarLabel("content", {
                vertical: false,
                padding: {
                    top: 0,
                    bottom: 0
                },
                margin: 0,
                position: "outsideEnd"
            });
            text = barLabel.children[0];
            text.contentBox = new Box(0, 0, 50, 50);
            text.reflow = function(targetBox) {
                ok(targetBox.width() > 0);
            };
            barLabel.reflow(new Box(0, 0, 100, 100));
        });
    });

    // ------------------------------------------------------------
    describe('BarLabel / Align to clip box / vertical', () => {
        beforeEach(() => {
            barLabel = new BarLabel("content", {vertical: true, padding: 0, margin: 0});
            barBox = new Box(30, 30, 70, 70);
            barLabel.reflow(barBox);
            barLabel.parent = {
                box: barBox
            };
        });

        it("label is reflowed in the intersection between the parent box and the clip box", () => {
            barLabel.reflow = function(targetBox) {
                equal(targetBox.y1, 40);
                equal(targetBox.y2, 70);
            };
            barLabel.alignToClipBox(new Box(0, 40, 100, 80));
        });

        it("label is not reflowed if the parent box is inside the clip box", () => {
            createSpy(barLabel, "reflow");
            barLabel.alignToClipBox(new Box(0, 30, 100, 70));
            expect(barLabel.reflow).not.toHaveBeenCalled();
        });
    });

    // ------------------------------------------------------------
    describe('BarLabel / Align to clip box / horizontal', () => {
        beforeEach(() => {
            barLabel = new BarLabel("content", {vertical: false, padding: 0, margin: 0});
            barBox = new Box(30, 30, 70, 70);
            barLabel.reflow(barBox);
            barLabel.parent = {
                box: barBox
            };
        });

        it("label is reflowed in the intersection between the parent box and the clip box", () => {
            barLabel.reflow = function(targetBox) {
                equal(targetBox.x1, 30);
                equal(targetBox.x2, 60);
            };
            barLabel.alignToClipBox(new Box(30, 0, 60, 100));
        });

        it("label is not reflowed if the parent box is inside the clip box", () => {
            createSpy(barLabel, "reflow");
            barLabel.alignToClipBox(new Box(30, 0, 70, 100));
            expect(barLabel.reflow).not.toHaveBeenCalled();
        });
    });

})();

(function() {
    const positiveData = [100, 150];
    const negativeData = [-100, -150];
    const VALUE_AXIS_MAX = 200;
    const CATEGORY_AXIS_Y = 200;
    const TOLERANCE = 0.1;
    const MARGIN = 10;
    const PADDING = 10;
    const COLOR = "red";
    const BACKGROUND = "blue";
    const BORDER = {
        width: 4,
        color: "green",
        dashType: "dot"
    };

    const plotArea = stubPlotArea(
        function(categoryIndex) {
            return new Box(categoryIndex, CATEGORY_AXIS_Y,
                             categoryIndex + 100, CATEGORY_AXIS_Y);
        },
        function(from, to) {
            const fromY = CATEGORY_AXIS_Y + from;
            const toY = CATEGORY_AXIS_Y + to;
            const slotTop = Math.min(fromY, toY);
            const slotBottom = Math.max(fromY, toY);

            return new Box(0, slotTop, 0, slotBottom);
        },
        {
            categoryAxis: {}
        }
    );

    // ------------------------------------------------------------
    describe('Column Chart / Labels', () => {
        beforeEach(() => {
            setupBarChart(plotArea, { series: [{
                data: [10, 0, null],
                labels: { visible: true }
            }] });
        });

        it("creates labels for 0 values", () => {
            equal(series.points[1].label.children[0].content, "0");
        });

        it("creates empty labels for null values", () => {
            equal(series.points[2].label.children[0].content, "");
        });
    });

    // ------------------------------------------------------------
    describe('Column Chart / Labels / Positive Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, { series: [{
                data: positiveData,
                labels: { position: "insideEnd", visible: true }
            }] });
        });

        it("insideEnd position", () => {
            each(series.points, function() {
                const text = this.children[0].children[0];
                equal(this.box.y1, text.box.y1);
                ok(this.box.x1 > text.box.x1 && this.box.x2 < text.box.x2);
            });
        });

        it("insideBase position", () => {
            setupBarChart(plotArea, { series: [{
                data: positiveData,
                labels: {
                    position: "insideBase",
                    visible: true
                }
            }] });
            each(series.points, function() {
                const text = this.children[0].children[0];
                equal(this.box.y2, text.box.y2);
                ok(this.box.x1 > text.box.x1 && this.box.x2 < text.box.x2);
            });
        });

        it("outsideEnd position", () => {
            setupBarChart(plotArea, { series: [{
                data: positiveData,
                labels: {
                    position: "outsideEnd",
                    visible: true
                }
            }] });
            each(series.points, function() {
                const text = this.children[0].children[0];
                equal(this.box.y1 - text.box.height(), text.box.y1);
                ok(this.box.x1 > text.box.x1 && this.box.x2 < text.box.x2);
            });
        });

        it("center position", function() {
            setupBarChart(plotArea, { series: [{
                data: positiveData,
                labels: {
                    position: "center",
                    visible: true
                }
            }] });
            each(series.points, function() {
                const text = this.children[0].children[0];
                const margin = (this.box.height() - text.box.height()) / 2;
                equal(this.box.y1 + margin, text.box.y1);
                ok(this.box.x1 > text.box.x1 && this.box.x2 < text.box.x2);
            });
        });

        it("creates labels with full format", () => {
            setupBarChart(plotArea, { series: [{
                data: positiveData,
                labels: {
                    format: "{0:C}",
                    visible: true
                }
            }] });

            equal(map(series.points, function(bar) {
                return bar.children[0].children[0].content }
            ), ["$100.00", "$150.00"]);
        });

        it("creates labels with simple format", () => {
            setupBarChart(plotArea, { series: [{
                data: positiveData,
                labels: {
                    format: "C",
                    visible: true
                }
            }] });

            equal(map(series.points, function(bar) {
                return bar.children[0].children[0].content }
            ), ["$100.00", "$150.00"]);
        });

        it("width equals bar width", () => {
            each(series.points, function() {
                const label = this.children[0].children[0];
                equal(label.paddingBox.width(), this.box.width(), 0.1);
            });
        });

        it("labels have zIndex", () => {
            equal(series.points[0].children[0].options.zIndex, 2);
        });
    });

    // ------------------------------------------------------------
    describe('Column Chart / Labels / Negative Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, { series: [{
                    data: negativeData,
                    labels: { position: "insideEnd", visible: true }
                }]
            });
        });

        it("insideEnd position", () => {
            each(series.points, function() {
                const text = this.children[0].children[0];
                equal(this.box.y2, text.box.y2);
                ok(this.box.x1 > text.box.x1 && this.box.x2 < text.box.x2);
            });
        });

        it("insideBase position", () => {
            setupBarChart(plotArea, { series: [{
                data: negativeData,
                    labels: {
                    position: "insideBase",
                    visible: true
                }
            }] });
            each(series.points, function() {
                const text = this.children[0].children[0];
                equal(this.box.y1, text.box.y1);
                ok(this.box.x1 > text.box.x1 && this.box.x2 < text.box.x2);
            });
        });

        it("outsideEnd position", () => {
            setupBarChart(plotArea, { series: [{
                data: negativeData,
                labels: {
                    position: "outsideEnd",
                    visible: true
                }
            }] });
            each(series.points, function() {
                const text = this.children[0].children[0];
                equal(this.box.y2, text.box.y1);
                ok(this.box.x1 > text.box.x1 && this.box.x2 < text.box.x2);
            });
        });

        it("center position", () => {
            setupBarChart(plotArea, { series: [{
                data: negativeData,
                labels: {
                    position: "center",
                    visible: true
                }
            }] });
            each(series.points, function() {
                const text = this.children[0].children[0];
                const margin = (this.box.height() - text.box.height()) / 2;
                equal(this.box.y1 + margin, text.box.y1);
                ok(this.box.x1 > text.box.x1 && this.box.x2 < text.box.x2);
            });
        });

        it("format", () => {
            setupBarChart(plotArea, { series: [{
                data: positiveData,
                labels: {
                    format: "{0:C}",
                    visible: true
                }
            }] });

            equal(map(series.points, function(bar) {
                return bar.children[0].children[0].content }
            ), ["$100.00", "$150.00"]);
        });
    });

    // ------------------------------------------------------------
    describe('Column Chart / Labels / Rendering', () => {

        it("color", () => {
            setupBarChart(plotArea, { series: [{
                data: [ 100 ],
                labels: {
                    color: COLOR,
                    visible: true
                }
            }] });
            equal(pointText(0).options.fill.color, COLOR);
        });

        it("background color", () => {
            setupBarChart(plotArea, { series: [{
                data: [ 100 ],
                labels: {
                    background: BACKGROUND,
                    visible: true
                }
            }] });
            equal(pointTextBox(0).visual.children[0].options.fill.color, BACKGROUND);
        });

        it("border", () => {
            setupBarChart(plotArea, { series: [{
                data: [ 100 ],
                labels: {
                    border: BORDER,
                    visible: true
                }
            }] });
            const background = pointTextBox(0).visual.children[0];
            const stroke = background.options.stroke;
            equal(stroke.color, BORDER.color);
            equal(stroke.width, BORDER.width);
            equal(stroke.dashType, BORDER.dashType);
        });

        it("padding and margin", () => {
            setupBarChart(plotArea, { series: [{
                data: [ 100 ],
                labels: {
                    margin: MARGIN,
                    border: { width: 0 },
                    visible: true
                }
            }] });

            const barLabel = series.points[0].children[0].children[0];
            const { paddingBox, box } = barLabel;

            equal(paddingBox.x1 - MARGIN, box.x1);
            equal(paddingBox.x2 + MARGIN, box.x2);
            equal(paddingBox.y1 - MARGIN, box.y1);
            equal(paddingBox.y2 + MARGIN, box.y2);
        });
    });

})();

(function() {
    const positiveData = [100, 150];
    const negativeData = [-100, -150];
    const VALUE_AXIS_MAX = 200;
    const CATEGORY_AXIS_X = 200;
    const TOLERANCE = 0.1;

    const plotArea = stubPlotArea(
        function(categoryIndex) {
            return new Box(CATEGORY_AXIS_X, categoryIndex,
                             CATEGORY_AXIS_X, categoryIndex + 1);
        },
        function(value) {
            const valueX = CATEGORY_AXIS_X + value,
                slotLeft = Math.min(CATEGORY_AXIS_X, valueX),
                slotRight = Math.max(CATEGORY_AXIS_X, valueX);

            return new Box(slotLeft, 0, slotRight, 0);
        },
        {
            categoryAxis: {}
        }
    );

    // ------------------------------------------------------------
    describe('Bar Chart / Labels / Positive Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, { series: [{
                data: positiveData,
                labels: {
                    visible: true
                }
            }], invertAxes: true });
        });

        it("insideEnd position", () => {
            setupBarChart(plotArea, { series: [{
                data: positiveData,
                labels: {
                    visible: true,
                    position: "insideEnd"
                }
            }], invertAxes: true });

            each(series.points, function() {
                const text = this.children[0].children[0];
                equal(text.box.x1, this.box.x2 - text.box.width());
                ok(this.box.y1 > text.box.y1 && this.box.y2 < text.box.y2);
            });
        });

        it("insideBase position", () => {
            setupBarChart(plotArea, { series: [{
                data: positiveData,
                labels: {
                    position: "insideBase",
                    visible: true
                }
            }], invertAxes: true });
            each(series.points, function() {
                const text = this.children[0].children[0];
                equal(text.box.x1, this.box.x1);
                ok(this.box.y1 > text.box.y1 && this.box.y2 < text.box.y2);
            });
        });

        it("outsideEnd position", () => {
            setupBarChart(plotArea, { series: [{
                data: positiveData,
                labels: {
                    position: "outsideEnd",
                    visible: true
                }
            }], invertAxes: true });
            each(series.points, function() {
                const text = this.children[0].children[0];
                equal(this.box.x2, text.box.x1);
                ok(this.box.y1 > text.box.y1 && this.box.y2 < text.box.y2);
            });
        });

        it("center position", () => {
            setupBarChart(plotArea, { series: [{
                data: positiveData,
                labels: {
                    position: "center",
                    visible: true
                }
            }], invertAxes: true });
            each(series.points, function() {
                const text = this.children[0].children[0],
                margin = (this.box.width() - text.box.width()) / 2;
                equal(this.box.x1 + margin, text.box.x1);
                ok(this.box.y1 > text.box.y1 && this.box.y2 < text.box.y2);
            });
        });

        it("height equals bar height", () => {
            each(series.points, function() {
                const label = this.children[0].children[0];
                close(label.paddingBox.height(), this.box.height(), 0.1);
            });
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Labels / Negative Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, { series: [{
                data: negativeData,
                labels: {
                    visible: true,
                    position: "insideEnd"
                }
            }], invertAxes: true });
        });

        it("insideEnd position", () => {
            each(series.points, function() {
                const text = this.children[0].children[0];
                equal(this.box.x1, text.box.x1);
                ok(this.box.y1 > text.box.y1 && this.box.y2 < text.box.y2);
            });
        });

        it("insideBase position", () => {
            setupBarChart(plotArea, { series: [{
                data: negativeData,
                labels: {
                    position: "insideBase",
                    visible: true
                }
            }], invertAxes: true });
            each(series.points, function() {
                const text = this.children[0].children[0];
                equal(this.box.x2 - text.box.width(), text.box.x1);
                ok(this.box.y1 > text.box.y1 && this.box.y2 < text.box.y2);
            });
        });

        it("outsideEnd position", () => {
            setupBarChart(plotArea, { series: [{
                data: negativeData,
                labels: {
                    position: "outsideEnd",
                    visible: true
                }
            }], invertAxes: true });
            each(series.points, function() {
                const text = this.children[0].children[0];
                equal(this.box.x1 - text.box.width(), text.box.x1);
                ok(this.box.y1 > text.box.y1 && this.box.y2 < text.box.y2);
            });
        });

        it("center position", () => {
            setupBarChart(plotArea, { series: [{
                data: negativeData,
                labels: {
                    position: "center",
                    visible: true
                }
            }], invertAxes: true });
            each(series.points, function() {
                const text = this.children[0].children[0],
                    margin = (this.box.height() - text.box.height()) / 2;
                equal(this.box.y1 + margin, text.box.y1);
                ok(this.box.y1 > text.box.y1 && this.box.y2 < text.box.y2);
            });
        });
    });
})();

(function() {
    const positiveSeries = { data: [1, 2], labels: {} };
    const negativeSeries = { data: [-1, -2], labels: {} };
    const CATEGORY_AXIS_X = 2;
    const TOLERANCE = 0.1;

    const plotArea = stubPlotArea(
        function(categoryIndex) {
            return new Box(CATEGORY_AXIS_X, categoryIndex,
                           CATEGORY_AXIS_X, categoryIndex + 1);
        },
        function(from, to) {
            const fromX = CATEGORY_AXIS_X + from,
                toX = CATEGORY_AXIS_X + to,
                slotLeft = Math.min(fromX, toX),
                slotRight = Math.max(fromX, toX);

            return new Box(slotLeft, 0, slotRight, 0);
        },
        {
            categoryAxis: {}
        }
    );

    // ------------------------------------------------------------
    describe('Bar Chart / Horizontal / Positive Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, { invertAxes: true, series: [ positiveSeries ] });
        });

        it("bars are distributed across category axis", () => {
            const barsY = map(series.points, function(bar) {
                return bar.box.y1;
            });

            arrayClose(barsY, [0.3, 1.3], TOLERANCE);
        });

        it("bar sides are aligned to category axis", () => {
            const barsX = map(series.points, function(bar) {
                return bar.box.x1;
            });

            equal(barsX, [CATEGORY_AXIS_X, CATEGORY_AXIS_X]);
        });

        it("bars have set height", () => {
            each(series.points, function() {
                close(this.box.height(), 0.4, TOLERANCE);
            });
        });

        it("bars have set width according to value", () => {
            const barWidths = map(series.points, function(bar) {
                return bar.box.width();
            });

            equal(barWidths, [1, 2]);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Horizontal / Negative Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, { invertAxes: true, series: [ negativeSeries ] });
        });

        it("Reports minimum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, negativeSeries.data[1]);
        });

        it("Reports maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, negativeSeries.data[0]);
        });

        it("bar sides are aligned to category axis", () => {
            const barsX = map(series.points, function(bar) {
                return bar.box.x2;
            });

            equal(barsX, [CATEGORY_AXIS_X, CATEGORY_AXIS_X]);
        });

        it("bars have set width according to value", () => {
            const barWidths = map(series.points, function(bar) {
                return bar.box.width();
            });

            equal(barWidths, [1, 2]);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Horizontal / Missing values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
                invertAxes: true,
                series: [ { data: [1, 2, 3] },
                          positiveSeries
                    ]
            });
        });

        it("Missing values are represented as bars with zero width", () => {
            const barWidths = map(series.points, function(bar) {
                return bar.box.width();
            });

            equal(barWidths, [1, 1, 2, 2, 3, 0]);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Horizontal / Cluster', () => {
        beforeEach(() => {
            setupBarChart(plotArea,
                { invertAxes: true,
                  series: [ positiveSeries, negativeSeries ]
                }
            );
        });

        it("bars in first category are clustered", () => {
            equal(series.points[0].box.y2, series.points[1].box.y1);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Horizontal / Stack / Positive Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
                invertAxes: true,
                series: [ positiveSeries, positiveSeries ],
                isStacked: true }
            );
        });

        it("reports stacked minumum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, 1);
        });

        it("reports stacked maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, 4);
        });

        it("bars in first category are stacked", () => {
            equal(series.points[1].box.x1, series.points[0].box.x2);
        });

        it("bars have set width according to value", () => {
            const barWidths = map(series.points, function(bar) {
                return bar.box.width();
            });

            equal(barWidths, [1, 1, 2, 2]);
        });

        it("series have 75% margin", () => {
            close(series.points[0].box.y1, 0.3, TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Horizontal / Stack / Negative Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
                invertAxes: true,
                series: [ negativeSeries, negativeSeries ],
                isStacked: true }
            );
        });

        it("reports stacked minumum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, -4);
        });

        it("reports stacked maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, -1);
        });

        it("bars in first category are stacked", () => {
            equal(series.points[1].box.x2, series.points[0].box.x1);
        });

        it("stack sides are aligned to category axis", () => {
            equal([series.points[0].box.x2, series.points[2].box.x2],
                 [CATEGORY_AXIS_X, CATEGORY_AXIS_X]);
        });

        it("bars have set width according to value", () => {
            const barWidths = map(series.points, function(bar) {
                return bar.box.width();
            });

            equal(barWidths, [1, 1, 2, 2]);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Horizontal / Stack / Mixed Values', () => {
        beforeEach(() => {
            setupBarChart(plotArea, {
                invertAxes: true,
                series: [ positiveSeries, negativeSeries ],
                isStacked: true }
            );
        });

        it("reports stacked minumum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].min, -2);
        });

        it("reports stacked maximum value for default axis", () => {
            equal(series.valueAxisRanges[undefined].max, 2);
        });

        it("bars have set width according to value", () => {
            const barWidths = map(series.points, function(bar) {
                return bar.box.width();
            });

            equal(barWidths, [1, 1, 2, 2]);
        });
    });

})();

(function() {
    let barChart;

    const plotArea = stubPlotArea(
        function(categoryIndex) {
            return new Box();
        },
        function(value) {
            return new Box();
        },
        {
            categoryAxis: {
                categories: ["A"]
            }
        }
    );

    // ------------------------------------------------------------
    describe('Bar Chart / Configuration', () => {
        beforeEach(() => {
            barChart = new BarChart(plotArea, {
                series: [{
                    data: [0, -1],
                    color: "#f00",
                    negativeColor: "#00f",
                    opacity: 0.5,
                    overlay: "none"
                }]
            });
        });

        function setupColorSpy(series, calls) {
            barChart = new BarChart(plotArea, {
                series: [createSpy(series, "color")]
            });
            expect(series.color).toHaveBeenCalledTimes(calls);
        }

        it("applies series fill color to bars", () => {
            equal(barChart.points[0].color, "#f00");
        });

        it("applies series negative fill color to negative bars", () => {
            equal(barChart.points[1].color, "#00f");
        });

        it("applies series opacity color to bars", () => {
            equal(barChart.points[0].options.opacity, 0.5);
        });

        it("applies series overlay to bars", () => {
            equal(barChart.points[0].options.overlay, "none");
        });

        it("applies color function", () => {
            barChart = new BarChart(plotArea, {
                series: [{
                    data: [0, 1],
                    color: function(bar) { return "#f00" }
                }]
            });

            equal(barChart.points[0].color, "#f00");
        });

        it("applies color function for each point", () => {
            setupColorSpy({
                data: [0, 1],
                color: function() { ok(true); }
            }, 2);
        });

        it("color fn argument contains value", () => {
            setupColorSpy({
                data: [1],
                color: function(bar) { equal(bar.value, 1); }
            }, 1);
        });

        it("color fn argument contains series", () => {
            setupColorSpy({
                    name: "series 1",
                    data: [1],
                    color: function(bar) { equal(bar.series.name, "series 1"); }
            }, 1);
        });

        it("color fn argument contains index", () => {
            setupColorSpy({
                    name: "series 1",
                    data: [1],
                    color: function(bar) { equal(bar.index, 0); }
            }, 1);
        });
    });
})();

(function() {
    const clusterBox = new Box(0, 0, 350, 350);
    const barBox = new Box(1, 1, 1, 1);
    const TOLERANCE = 0.1;
    let cluster, bars;

    function createCluster(options) {
        cluster = new ClusterLayout(options);
        bars = [ new BarStub(barBox), new BarStub(barBox) ];
        [].push.apply(cluster.children, bars);
        cluster.reflow(clusterBox);
    }

    // ------------------------------------------------------------
    describe('Cluster Layout / Horizontal', () => {
        beforeEach(() => {
            createCluster({ gap: 0 });
        });

        it("distributes width evenly", () => {
            each(bars, function() {
                equal(this.box.width(), clusterBox.width() / bars.length)
            });
        });

        it("positions children next to each other", () => {
            each(bars, function(index) {
                equal(this.box.x1, this.box.width() * index)
            });
        });

        it("leaves 75% gap on both sides", () => {
            createCluster({ gap: 1.5 });

            equal(bars[0].box.x1, 75);
            equal(bars[1].box.x2, 275);
        });

        it("positions children next to each other with spacing", () => {
            createCluster({ gap: 0, spacing: 1 });
            each(bars, function(index) {
                close(this.box.x1, (this.box.width() * 2) * index, TOLERANCE)
            });
        });
    });

    // ------------------------------------------------------------
    describe('Cluster Layout / Vertical', () => {
        beforeEach(() => {
            createCluster({ vertical: true, gap: 0 });
        });

        it("distributes height evenly", () => {
            each(bars, function() {
                equal(this.box.height(), clusterBox.height() / bars.length)
            });
        });

        it("positions children below each other", () => {
            each(bars, function(index) {
                equal(this.box.y1, this.box.height() * index)
            });
        });

        it("positions children next to each other with spacing", () => {
            createCluster({ vertical: true, gap: 0, spacing: 1 });
            each(bars, function(index) {
                close(this.box.y1, (this.box.height() * 2) * index, TOLERANCE)
            });
        });
    });
})();

(function() {
    const stackBox = new Box(50, 50, 100, 100);
    let stack;

    // ------------------------------------------------------------
    describe('Stack Wrap / Vertical', () => {
        beforeEach(() => {
            stack = new StackWrap();

            stack.children.push(
                new BarStub(new Box(0, 90, 100, 100)),
                new BarStub(new Box(0, 80, 100, 100)),
                new BarStub(new Box(0, 70, 100, 100))
            );

            stack.reflow(stackBox);
        });

        it("updates children width to fit box", () => {
            equal(stack.children[0].box.width(), stackBox.width());
            equal(stack.children[1].box.width(), stackBox.width());
        });

        it("updates children X position to match targetBox", () => {
            equal(stack.children[0].box.x1, stackBox.x1);
            equal(stack.children[1].box.x1, stackBox.x1);
        });
    });

    // ------------------------------------------------------------
    describe('Stack Wrap / Horizontal', () => {
        beforeEach(() => {
            stack = new StackWrap({ vertical: false });
            stack.children.push(
                new BarStub(new Box(0, 0, 20, 10)),
                new BarStub(new Box(0, 0, 30, 10)),
                new BarStub(new Box(0, 0, 40, 10))
            );

            stack.reflow(stackBox);
        });

        it("updates children height to fit box", () => {
            equal(stack.children[0].box.height(), stackBox.height());
            equal(stack.children[1].box.height(), stackBox.height());
        });

        it("updates children Y position to match targetBox", () => {
            equal(stack.children[0].box.y1, stackBox.y1);
            equal(stack.children[1].box.y1, stackBox.y1);
        });
    });

})();

(function() {
    const VALUE = 1;
    const STACK_VALUE = 2;
    const CATEGORY = "A";
    const SERIES_NAME = "series";
    const TOOLTIP_OFFSET = 5;
    let bar, label, box, rect, overlay, root;

    function createBar(options, clipBox) {
        box = new Box(0, 0, 100, 100);
        bar = new Bar(VALUE, deepExtend({}, Bar.prototype.defaults, options));

        bar.stackValue = STACK_VALUE;
        bar.category = CATEGORY;
        bar.dataItem = { value: VALUE };
        bar.percentage = 0.5;
        bar.series = { name: SERIES_NAME };
        bar.getRoot = function() {
            return {
                chart: "chart"
            };
        };
        bar.owner = {
            pane: {
                clipBox: function(){
                    return clipBox || new Box(0, 0, 100, 100);
                }
            },
            formatPointValue: function() { return "foo"; }
        };
        root = new RootElement();
        root.box = box;
        root.append(bar);
        bar.reflow(box);
        label = bar.children[0];

        root.renderVisual();

        rect = bar.visual.children[0];
        overlay = bar.visual.children[1];
    }

    // ------------------------------------------------------------
    describe('Bar', () => {
        beforeEach(() => {
            createBar();
        });

        it("sets value", () => {
            equal(bar.value, VALUE);
        });

        it("aboveAxis is true by default", () => {
            equal(bar.aboveAxis, true);
        });

        it("aboveAxis is set from options", () => {
            createBar({ aboveAxis: false });
            equal(bar.aboveAxis, false);
        });

        it("fills target box", () => {
            sameBox(bar.box, box);
        });

        it("renders rectangle", () => {
            sameLinePath(rect, alignPathToPixel(draw.Path.fromRect(box.toRect())));
        });

        it("width is rounded", () => {
            const g = new draw.Group();
            bar.options.border = 0;
            bar.box.x2 = 4.5;
            bar.createRect(g);

            equal(g.bbox().width(), 5);
        });

        it("sets stroke line join to round if the path is aligned and the width / height is less than one", () => {
            bar.box = new Box(0, 0, 100, 0.9);
            bar.renderVisual();

            equal(bar.rectVisual.options.stroke.lineJoin, "round");

            bar.options.vertical = false;
            bar.box = new Box(0, 0, 0.9, 100);
            bar.renderVisual();

            equal(bar.rectVisual.options.stroke.lineJoin, "round");
        });

        it("does not render rectangle when box height is zero", () => {
            bar.reflow(new Box(0, 0, 100, 0));

            bar.renderVisual();

            equal(bar.visual.children.length, 0);
        });

        it("does not render rectangle when box width is zero", () => {
            bar.reflow(new Box(0, 0, 0, 100));

            bar.renderVisual();

            equal(bar.visual.children.length, 0);
        });

        it("sets fill color", () => {
            equal(rect.options.fill.color, bar.color);
        });

        it("renders overlay", () => {
            ok(overlay);
        });

        it("overlay has same path as rect", () => {
            sameLinePath(rect, overlay);
        });

        it("sets overlay baseColor to color", () => {
            createBar({
                color: "red"
            });
            equal(overlay.options.baseColor, "red");
        });

        it("sets overlay gradient end point based on vertical option", () => {
            ok(overlay.options.fill.end().equals(new geom.Point(1, 0)));
            createBar({
                vertical: false
            });
            ok(overlay.options.fill.end().equals(new geom.Point(0, 1)));
        });

        it("does not render overlay options when no overlay is defined", () => {
            createBar({ overlay: null });
            ok(!overlay);
        });

        it("sets default border color based on color", () => {
            createBar({ color: "#cf0" });
            equal(rect.options.stroke.color, "#a3cc00");
        });

        it("does not change border color if set", () => {
            createBar({ border: { color: "" } });
            equal(rect.options.stroke.color, "");
        });

        it("sets stroke color", () => {
            createBar({ border: { color: "red", width: 1 } });
            equal(rect.options.stroke.color, bar.options.border.color);
        });

        it("sets stroke width", () => {
            createBar({ border: { color: "red", width: 1 } });
            equal(rect.options.stroke.width, bar.options.border.width);
        });

        it("sets stroke dash type", () => {
            createBar({ border: { color: "red", width: 1, dashType: "dot" } });
            equal(rect.options.stroke.dashType, bar.options.border.dashType);
        });

        it("sets stroke opacity", () => {
            createBar({ border: { color: "red", width: 1, opacity: 0.5 } });
            equal(rect.options.stroke.opacity, bar.options.border.opacity);
        });

        it("sets fill opacity", () => {
            createBar({ opacity: 0.5 });
            equal(rect.options.fill.opacity, bar.options.opacity);
        });

        it("sets stroke opacity", () => {
            createBar({ opacity: 0.5 });
            equal(rect.options.stroke.opacity, bar.options.opacity);
        });

        it("aligns bar to pixel", () => {
            createBar({ vertical: false });
            bar.reflow(new Box(0, 0, 100, 100));
            bar.renderVisual();

            equal(bar.visual.children[0].segments[0].anchor().toArray(), [0.5, 0.5]);
        });

        it("does not align bar to pixel if too small", () => {
            createBar({ vertical: false });
            bar.reflow(new Box(0, 0, 100, 4));
            bar.renderVisual();

            equal(bar.visual.children[0].segments[0].anchor().toArray(), [0, 0]);
        });

        it("aligns column to pixel", () => {
            bar.reflow(new Box(0, 0, 100, 100));
            bar.renderVisual();

            equal(bar.visual.children[0].segments[0].anchor().toArray(), [0.5, 0.5]);
        });

        it("does not align column to pixel if too small", () => {
            bar.reflow(new Box(0, 0, 4, 100));
            bar.renderVisual();

            equal(bar.visual.children[0].segments[0].anchor().toArray(), [0, 0]);
        });

        it("createHighlight returns same path with the passed options", () => {
            const highlight = bar.createHighlight({
                foo: "bar"
            });
            sameLinePath(rect, highlight);
            equal(highlight.options.foo, "bar");
        });

        it("highlightVisual returns rectVisual", () => {
            const visual = bar.highlightVisual();

            ok(visual === bar.rectVisual);
        });

        it("highlightVisualArgs returns an object with the options, the bar rect and the rectVisual", () => {
             const result = bar.highlightVisualArgs();
             equal(result.options, bar.options);
             ok(bar.box.toRect().equals(result.rect));
             ok(bar.rectVisual === result.visual);
        });

        it("tooltipAnchor is top right corner / vertical / above axis", () => {
            createBar({ vertical: true, aboveAxis: true, isStacked: false });
            const { point, align } = bar.tooltipAnchor();

            equal([point.x, point.y], [bar.box.x2 + TOOLTIP_OFFSET, bar.box.y1]);
            equal(align.vertical, "top");
            equal(align.horizontal, "left");
        });

        it("tooltipAnchor is top right corner / vertical / above axis / stacked", () => {
            createBar({ vertical: true, aboveAxis: true, isStacked: true });
            const { point, align } = bar.tooltipAnchor();
            equal([point.x, point.y], [bar.box.x2 + TOOLTIP_OFFSET, bar.box.y1]);
            equal(align.vertical, "top");
            equal(align.horizontal, "left");
        });

        it("tooltipAnchor is bottom right corner / vertical / below axis", () => {
            createBar({ vertical: true, aboveAxis: false, isStacked: false });
            const { point, align } = bar.tooltipAnchor();
            equal([point.x, point.y], [bar.box.x2 + TOOLTIP_OFFSET, bar.box.y2]);
            equal(align.vertical, "bottom");
            equal(align.horizontal, "left");
        });

        it("tooltipAnchor is bottom right corner / vertical / below axis / stacked", () => {
            createBar({ vertical: true, aboveAxis: false, isStacked: true });
            const { point, align } = bar.tooltipAnchor();
            equal([point.x, point.y], [bar.box.x2 + TOOLTIP_OFFSET, bar.box.y2]);
            equal(align.vertical, "bottom");
            equal(align.horizontal, "left");
        });

        it("tooltipAnchor is top right corner / horizontal / above axis", () => {
            createBar({ vertical: false, aboveAxis: true, isStacked: false });
            const { point, align } = bar.tooltipAnchor();
            equal([point.x, point.y], [bar.box.x2 + TOOLTIP_OFFSET, bar.box.y1]);
            equal(align.vertical, "top");
            equal(align.horizontal, "left");
        });

        it("tooltipAnchor is above top right corner / horizontal / above axis / stacked", () => {
            createBar({ vertical: false, aboveAxis: true, isStacked: true });
            const { point, align } = bar.tooltipAnchor();
            equal([point.x, point.y], [bar.box.x2, bar.box.y1 - TOOLTIP_OFFSET]);
            equal(align.vertical, "bottom");
            equal(align.horizontal, "right");
        });

        it("tooltipAnchor is top left corner / horizontal / below axis", () => {
            createBar({ vertical: false, aboveAxis: false, isStacked: false });
            const { point, align } = bar.tooltipAnchor();
            equal([point.x, point.y], [bar.box.x1 - TOOLTIP_OFFSET, bar.box.y1]);
            equal(align.vertical, "top");
            equal(align.horizontal, "right");
        });

        it("tooltipAnchor is above top left corner / horizontal / below axis / stacked", () => {
            createBar({ vertical: false, aboveAxis: false, isStacked: true });
            const { point, align } = bar.tooltipAnchor();
            equal([point.x, point.y], [bar.box.x1, bar.box.y1 - TOOLTIP_OFFSET]);
            equal(align.vertical, "bottom");
            equal(align.horizontal, "left");
        });

        it("tooltipAnchor is limited to the clipbox / horizontal / above axis", () => {
            createBar({ vertical: false, aboveAxis: true }, new Box(1, 20, 40, 100));
            const { point } = bar.tooltipAnchor();
            equal(point.x, 40 + TOOLTIP_OFFSET);
            equal(point.y, 20);
        });

        it("tooltipAnchor is limited to the clipbox / vertical / above axis", () => {
            createBar({ vertical: true, aboveAxis: true}, new Box(1, 40, 50, 100));
            const { point } = bar.tooltipAnchor();
            equal(point.x, 50 + TOOLTIP_OFFSET);
            equal(point.y, 40);
        });

        it("tooltipAnchor is limited to the clipbox / horizontal / below axis", () => {
            createBar({ vertical: false, aboveAxis: false}, new Box(40, 20, 100, 100));
            const { point } = bar.tooltipAnchor();
            equal(point.x, 40 - TOOLTIP_OFFSET);
            equal(point.y, 20);
        });

        it("tooltipAnchor is limited to the clipbox / vertical / below axis", () => {
            createBar({ vertical: true, aboveAxis: false}, new Box(1, 1, 50, 40));
            const { point } = bar.tooltipAnchor();
            equal(point.x, 50 + TOOLTIP_OFFSET);
            equal(point.y, 40);
        });
    });

    // ------------------------------------------------------------

    describe('Bar / custom visual', () => {
        let customVisual;

        beforeEach(() => {
            customVisual = new draw.Path();
        });

        it("creates custom visual if visual option is set", () => {
            createBar({
                visual: function() {
                    return customVisual;
                }
            });

            ok(bar.visual.children[0] === customVisual);
        });

        it("does not create default visual if custom visual function returns nothing", () => {
            createBar({
                visual: function() {
                }
            });
            equal(bar.visual.children.length, 0);
        });

        it("passes rect as parameter", () => {
            createBar({
                visual: function(e) {
                   ok(e.rect.equals(bar.box.toRect()));
                }
            });
        });

        it("passes chart as sender parameter", () => {
            createBar({
                visual: function(e) {
                   equal(e.sender, "chart");
                }
            });
        });

        it("passes context", () => {
            createBar({
                visual: function(e) {
                    equal(e.value, bar.value);
                    ok(e.dataItem === bar.dataItem);
                    ok(e.category === bar.category);
                    ok(e.series === bar.series);
                    equal(e.percentage, bar.percentage);
                    equal(e.stackValue, bar.stackValue);
                }
            });
        });

        it("passes options", () => {
            createBar({
                visual: function(e) {
                   const options = bar.options;
                   equal(e.options, options);
                }
            });
        });

        it("passes function that returns the default visual", () => {
            createBar({
                visual: function(e) {
                   const group = e.createVisual();
                   ok(group.children[0] instanceof draw.Path);
                   ok(group.children[1] instanceof draw.Path);
                   ok(group.children[1].options.fill instanceof draw.Gradient);
                }
            });
        });
    });

    // ------------------------------------------------------------
    describe('Bar / Labels / Template', () => {

        function assertTemplate(template, value, format) {
            createBar({ labels: { visible: true, template: template, format: format } });
            equal(label.children[0].content, value);
        }

        it("renders template", () => {
            assertTemplate("${value}%", VALUE + "%");
        });

        it("renders template even when format is set", () => {
            assertTemplate("${value}%", VALUE + "%", "{0:C}");
        });

        it("template has category", () => {
            assertTemplate("${category}", CATEGORY);
        });

        it("template has percentage", () => {
            assertTemplate("${percentage}", "0.5");
        });

        it("template has stackValue", () => {
            assertTemplate("${stackValue}", String(STACK_VALUE));
        });

        it("template has dataItem", () => {
            assertTemplate("${dataItem.value}", String(VALUE));
        });

        it("template has series", () => {
            assertTemplate("${series.name}", SERIES_NAME);
        });
    });

})();

(function() {
    const data = [{
        name: "Category A",
        text: "Alpha",
        value: 10,
        color: "red"
    },{
        name: "Category B",
        text: "Alpha",
        value: 10,
        color: null
    }];
    let points, chart, label;

    function setupChart(options) {
        chart = createChart({
            seriesDefaults: {
                labels: {
                    visible: true,
                    template: "${dataItem.text}"
                }
            },
            series: [{
                data: data,
                name: "Value",
                type: "bar",
                field: "value",
                colorField: "color"
            }],
            categoryAxis: {
                field: "name"
            }
        });

        points = chart._plotArea.charts[0].points;
        label = points[0].children[0];
    }

    // ------------------------------------------------------------
    describe('Bar Chart / Data Binding', () => {
        beforeEach(() => {
            setupChart();
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("point color bound to color field", () => {
            equal(points[0].color, "red");
        });

        it("point color not bound to null color field", () => {
            equal(points[1].color, "#ff6800");
        });

        it("dataItem sent to label template", () => {
            equal(label.children[0].content, "Alpha");
        });
    });

})();

(function() {
    let chart, bar, barElement, plotArea;

    function createBarChart(options) {
        chart = createChart(deepExtend({
            series: [{
                type: "bar",
                data: [1]
            }],
            categoryAxis: {
                categories: ["A"]
            }
        }, options));

        plotArea = chart._model.children[1];
        bar = plotArea.charts[0].points[0];
        barElement = getChartDomElement(bar);
    }

    function barClick(callback, calls = 1) {
        const options = createSpy({
            seriesClick: callback
        }, "seriesClick");
        createBarChart(options);

        clickChart(chart, barElement);
        expect(options.seriesClick).toHaveBeenCalledTimes(1);

        return options;
    }

    function barHover(callback) {
        createBarChart({
            seriesHover: callback
        });

        triggerEvent("mouseover", barElement);
    }

    // ------------------------------------------------------------
    describe('Bar Chart / Events / seriesClick', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when clicking bars", () => {
            barClick(function() { ok(true); });
        });

        it("fires on contextmenu", () => {
            createBarChart({
                seriesClick: function(e) {
                    equal(e.originalEvent.type, "contextmenu");
                }
            });
            triggerEvent("contextmenu", barElement);
        });

        it("fires on subsequent click", () => {
            const options = barClick(function() { ok(true); });
            clickChart(chart, barElement);
            expect(options.seriesClick).toHaveBeenCalledTimes(2);
        });

        it("fires when clicking bar labels", () => {
            createBarChart({
                seriesDefaults: {
                    bar: {
                        labels: {
                            visible: true
                        }
                    }
                },
                seriesClick: function() { ok(true); }
            });
            const label = plotArea.charts[0].points[0].label.children[0];

            clickChart(chart, getChartDomElement(label));
        });

        it("event arguments contain value", () => {
            barClick(function(e) { equal(e.value, 1); });
        });

        it("event arguments contain percentage and stackValue (100% stacked series)", () => {
            createBarChart({
                seriesDefaults: {
                    type: "bar",
                    stack: { type: "100%" }
                },
                series: [{ data: [1] }, { data: [2] }],
                seriesClick: function(e) {
                    equal(e.percentage, 1/3);
                    equal(e.stackValue, 1/3);
                }
            });
            clickChart(chart, barElement);
        });

        it("event arguments contain stackValue (stacked series)", () => {
            createBarChart({
                seriesDefaults: {
                    type: "bar",
                    stack: true
                },
                series: [{ data: [1] }, { data: [2] }],
                seriesClick: function(e) {
                    equal(e.stackValue, 3);
                }
            });

            bar = plotArea.charts[0].points[1];
            barElement = getChartDomElement(bar);

            clickChart(chart, barElement);
        });

        it("event arguments contain category", () => {
            barClick(function(e) { equal(e.category, "A"); });
        });

        it("event arguments contain series", () => {
            barClick(function(e) {
                equal(e.series, chart.options.series[0]);
            });
        });

        it("event arguments contain jQuery element", () => {
            barClick(function(e) {
                equal(e.element[0], barElement[0]);
            });
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart / Events / seriesHover', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when hovering bars", () => {
            barHover(function() { ok(true); });
        });

        it("fires on tap", () => {
            const options = createSpy({
                seriesHover: function() {
                    ok(true);
                }
            }, "seriesHover");
            createBarChart(options);

            clickChart(chart, barElement);
            expect(options.seriesHover).toHaveBeenCalledTimes(1);
        });

        it("does not fire on subsequent tap", () => {
            createBarChart({
                seriesHover: function() {
                    ok(true);
                }
            });

            clickChart(chart, barElement);
            clickChart(chart, barElement);
        });

        it("fires when hovering bar labels", () => {
            createBarChart({
                seriesDefaults: {
                    bar: {
                        labels: {
                            visible: true
                        }
                    }
                },
                seriesHover: function() { ok(true); }
            });
            const label = plotArea.charts[0].points[0].label.children[0];
            triggerEvent("mouseover", getChartDomElement(label));
        });

        it("event arguments contain value", () => {
            barHover(function(e) { equal(e.value, 1); });
        });

        it("event arguments contain percentage", () => {
            createBarChart({
                seriesDefaults: {
                    type: "bar",
                    stack: { type: "100%" }
                },
                series: [{ data: [1] }, { data: [2] }],
                seriesHover: function(e) { equal(e.percentage, 1/3); }
            });
            triggerEvent("mouseover", barElement);
        });

        it("event arguments contain category", () => {
            barHover(function(e) { equal(e.category, "A"); });
        });

        it("event arguments contain series", () => {
            barHover(function(e) {
                equal(e.series, chart.options.series[0]);
            });
        });

        it("event arguments contain jQuery element", () => {
            barHover(function(e) {
                equal(e.element[0], barElement[0]);
            });
        });

        it("cancelling seriesHover prevents tooltip from opening", () => {
            createBarChart({
                tooltip: { visible: true },
                seriesHover: function(e) {
                    e.preventDefault();
                }
            });

            createSpy(chart._tooltip, "show");
            triggerEvent("mouseover", barElement);
            expect(chart._tooltip.show).not.toHaveBeenCalled();
        });

        it("tooltip is opened if seriesHover is not cancelled", () => {
            createBarChart({
                tooltip: { visible: true }
            });

            chart._tooltip.show = function() { ok(true); };
            triggerEvent("mouseover", barElement);
        });
    });

    // ------------------------------------------------------------
    function sharedHover() {
        triggerEvent("mousemove", barElement, 100, 50);
    }

    describe('Bar Chart / Events / seriesHover / Shared Tooltip', () => {
        beforeEach(() => {
            createBarChart({
                series: [{
                    type: "bar",
                    data: [1]
                }, {
                    type: "bar",
                    data: [2]
                }],
                tooltip: {
                    visible: true,
                    shared: true
                }
            });
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("triggets seriesHover", () => {
            chart.bind("seriesHover", function(e) {
                ok(true);
            });

            sharedHover();
        });

        it("seriesHover contains all category points", () => {
            chart.bind("seriesHover", function(e) {
                equal(e.categoryPoints.length, 2);
            });

            sharedHover();
        });

        it("cancelling seriesHover prevents tooltip from opening", () => {
            chart.bind("seriesHover", function(e) {
                e.preventDefault();
            });

            createSpy(chart._tooltip, "showAt");

            sharedHover();

            expect(chart._tooltip.showAt).not.toHaveBeenCalled();
        });

        it("tooltip is opened if seriesHover is not cancelled", () => {
            chart._tooltip.showAt = function() { ok(true); };
            sharedHover();
        });
    });
})();

(function() {
    const box = new Box(0, 0, 800, 600);
    let plotArea, chart;

    function createChart(series, options) {
        plotArea = new CategoricalPlotArea([]);
        chart = new BarChart(plotArea, deepExtend({ series: series }, options));
    }

    // ------------------------------------------------------------
    describe('Bar Chart  / Plot range / Positive values', () => {
        beforeEach(() => {
            createChart([{ data: [1] }]);
        });

        it("from axis to value", () => {
            equal(chart.plotRange(chart.points[0]), [0, 1]);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart  / Plot range / Negative values', () => {
        beforeEach(() => {
            createChart([{ data: [-1] }]);
        });

        it("from axis to value", () => {
            equal(chart.plotRange(chart.points[0]), [0, -1]);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart  / Plot range / Stack / Configuration', () => {

        it("first series set to stack: true", () => {
            createChart([{ data: [1], stack: true }, { data: [2] }],
                         { isStacked: true });
            equal(chart.plotRange(chart.points[1]), [1, 3]);
        });

        it("all series set to stack: true", () => {
            createChart([{ data: [1], stack: true }, { data: [2], stack: true }],
                         { isStacked: true });
            equal(chart.plotRange(chart.points[1]), [1, 3]);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart  / Plot range / Stack / Positive values', () => {
        beforeEach(() => {
            createChart([{ data: [1] }, { data: [2] }, { data: [0] }],
                         { isStacked: true });
        });

        it("from axis to value", () => {
            equal(chart.plotRange(chart.points[0]), [0, 1]);
        });

        it("from prev point to value", () => {
            equal(chart.plotRange(chart.points[1]), [1, 3]);
        });

        it("zero value is included in positive stack", () => {
            equal(chart.plotRange(chart.points[2]), [3, 3]);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart  / Plot range / Stack / Negative values', () => {
        beforeEach(() => {
            createChart([{ data: [-1] }, { data: [-2] }, { data: [0] }],
                         { isStacked: true });
        });

        it("from axis to value", () => {
            equal(chart.plotRange(chart.points[0]), [0, -1]);
        });

        it("from prev point to value", () => {
            equal(chart.plotRange(chart.points[1]), [-1, -3]);
        });

        it("zero value is not included in negative stack", () => {
            equal(chart.plotRange(chart.points[2]), [0, 0]);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart  / Plot range / Stack / Mixed values', () => {
        beforeEach(() => {
            createChart([{ data: [1] }, { data: [-1] }, { data: [0] }],
                         { isStacked: true });
        });

        it("from axis to positive value", () => {
            equal(chart.plotRange(chart.points[0]), [0, 1]);
        });

        it("from axis to negative value", () => {
            equal(chart.plotRange(chart.points[1]), [0, -1]);
        });

        it("zero value is included in positive stack", () => {
            equal(chart.plotRange(chart.points[2]), [1, 1]);
        });
    });

    // ------------------------------------------------------------
    function assertMultipleStacksPositive() {
        it("first stack, from axis to value", () => {
            equal(chart.plotRange(chart.points[0]), [0, 1]);
        });

        it("first stack, from prev point to value", () => {
            equal(chart.plotRange(chart.points[1]), [1, 3]);
        });

        it("second stack, from axis to value", () => {
            equal(chart.plotRange(chart.points[2]), [0, 3]);
        });

        it("second stack, from prev point to value", () => {
            equal(chart.plotRange(chart.points[3]), [3, 7]);
        });

        it("zero value is included in the corresponding positive stack", () => {
            equal(chart.plotRange(chart.points[4]), [7, 7]);
        });
    }

    describe('Bar Chart  / Plot range / Multiple Stacks / Positive values', () => {
        beforeEach(() => {
            createChart([{ data: [1], stack: "a" }, { data: [2], stack: "a" },
                         { data: [3], stack: "b" }, { data: [4], stack: "b" },
                         { data: [0], stack: "b" }],
                         { isStacked: true });
        });
        assertMultipleStacksPositive();
    });

    describe('Bar Chart  / Plot range / Multiple Stacks (group syntax) / Positive values', () => {
        beforeEach(() => {
            createChart([{ data: [1], stack: { group: "a" } },
                         { data: [2], stack: { group: "a" } },
                         { data: [3], stack: { group: "b" } },
                         { data: [4], stack: { group: "b" } },
                         { data: [0], stack: { group: "b" } }],
                         { isStacked: true });
        });
        assertMultipleStacksPositive();
    });

    // ------------------------------------------------------------
    function assertMultipleStacksNegative() {
        it("first stack, from axis to value", () => {
            equal(chart.plotRange(chart.points[0]), [0, -1]);
        });

        it("first stack, from prev point to value", () => {
            equal(chart.plotRange(chart.points[1]), [-1, -3]);
        });

        it("second stack, from axis to value", () => {
            equal(chart.plotRange(chart.points[2]), [0, -3]);
        });

        it("second stack, from prev point to value", () => {
            equal(chart.plotRange(chart.points[3]), [-3, -7]);
        });

        it("zero value is not included in corresponding negative stack", () => {
            equal(chart.plotRange(chart.points[4]), [0, 0]);
        });
    }

    describe('Bar Chart  / Plot range / Multiple Stacks / Negative values', () => {
        beforeEach(() => {
            createChart([{ data: [-1], stack: "a" }, { data: [-2], stack: "a" },
                         { data: [-3], stack: "b" }, { data: [-4], stack: "b" },
                         { data: [0], stack: "b" }],
                         { isStacked: true });
        });
        assertMultipleStacksNegative();
    });

    describe('Bar Chart  / Plot range / Multiple Stacks (group syntax) / Negative values', () => {
        beforeEach(() => {
            createChart([{ data: [-1], stack: { group: "a" } },
                         { data: [-2], stack: { group: "a" } },
                         { data: [-3], stack: { group: "b" } },
                         { data: [-4], stack: { group: "b" } },
                         { data: [0], stack: { group: "b" } }],
                         { isStacked: true });
        });

        assertMultipleStacksNegative();
    });

    // ------------------------------------------------------------
    describe('Bar Chart  / Plot range / Stack 100% / Positive values', () => {
        beforeEach(() => {
            createChart([{ data: [1] }, { data: [3] }],
                         { isStacked: true, isStacked100: true });
        });

        it("from axis to value", () => {
            equal(chart.plotRange(chart.points[0]), [0, 0.25]);
        });

        it("from prev point to value", () => {
            equal(chart.plotRange(chart.points[1]), [0.25, 1]);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart  / Plot range / Stack 100% / Negative values', () => {
        beforeEach(() => {
            createChart([{ data: [-1] }, { data: [-3] }],
                         { isStacked: true, isStacked100: true });
        });

        it("from axis to value", () => {
            equal(chart.plotRange(chart.points[0]), [0, -0.25]);
        });

        it("from prev point to value", () => {
            equal(chart.plotRange(chart.points[1]), [-0.25, -1]);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart  / Plot range / Stack 100% / Mixed values', () => {
        beforeEach(() => {
            createChart([{ data: [1] }, { data: [-3] }],
                         { isStacked: true, isStacked100: true });
        });

        it("from axis to value", () => {
            equal(chart.plotRange(chart.points[0]), [0, 0.25]);
        });

        it("from prev point to value", () => {
            equal(chart.plotRange(chart.points[1]), [0, -0.75]);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart  / Plot range / Stack 100% / Missing values', () => {
        beforeEach(() => {
            createChart([{ data: [undefined] }, { data: [1] }],
                         { isStacked: true, isStacked100: true });
        });

        it("from prev point to value", () => {
            equal(chart.plotRange(chart.points[1]), [0, 1]);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart  / Plot range / Multiple 100% Stacks / Positive values', () => {
        beforeEach(() => {
            createChart([
                { data: [1], stack: { type: "100%", group: "a" } },
                { data: [3], stack: { type: "100%", group: "a" } },
                { data: [2], stack: { type: "100%", group: "b" } },
                { data: [6], stack: { type: "100%", group: "b" } }],
                { isStacked: true, isStacked100: true });
        });

        it("first stack, from axis to value", () => {
            equal(chart.plotRange(chart.points[0]), [0, 0.25]);
        });

        it("first stack, from prev point to value", () => {
            equal(chart.plotRange(chart.points[1]), [0.25, 1]);
        });

        it("second stack, from axis to value", () => {
            equal(chart.plotRange(chart.points[2]), [0, 0.25]);
        });

        it("second stack, from prev point to value", () => {
            equal(chart.plotRange(chart.points[3]), [0.25, 1]);
        });
    });

    // ------------------------------------------------------------
    describe('Bar Chart  / Plot range / Multiple 100% Stacks / Negative values', () => {
        beforeEach(() => {
            createChart([
                { data: [-1], stack: { type: "100%", group: "a" } },
                { data: [-3], stack: { type: "100%", group: "a" } },
                { data: [-2], stack: { type: "100%", group: "b" } },
                { data: [-6], stack: { type: "100%", group: "b" } }],
                { isStacked: true, isStacked100: true });
        });

        it("first stack, from axis to value", () => {
            equal(chart.plotRange(chart.points[0]), [0, -0.25]);
        });

        it("first stack, from prev point to value", () => {
            equal(chart.plotRange(chart.points[1]), [-0.25, -1]);
        });

        it("second stack, from axis to value", () => {
            equal(chart.plotRange(chart.points[2]), [0, -0.25]);
        });

        it("second stack, from prev point to value", () => {
            equal(chart.plotRange(chart.points[3]), [-0.25, -1]);
        });
    });
})();


(function() {
    const MARGIN = 10;
    let chart, model, title, legend, plotArea;


    function setupChart(series, options) {
        chart = createChart(deepExtend({
            title: {
                text: "Chart Title"
            },
            series: series,
            categoryAxis: {
                categories: ["Alpha", "Beta", "Charlie"]
            },
            chartArea: {
                margin: 0
            }
        }, options ));

        model = chart._model;
        title = model.children[0];
        legend = model.children[1];
        plotArea = model.children[2];
    }

    describe('Bar Chart Model', () => {
        beforeEach(() => {
            setupChart([{
                name: "Value",
                type: "bar",
                data: [100, 200, 300]
            }]);
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("model is a RootElement", () => {
            ok(model instanceof RootElement);
        });

        it("title is created", () => {
            ok(title instanceof Title);
        });

        it("title text is set", () => {
            equal(title.options.text, "Chart Title");
        });

        it("title box is positioned at top", () => {
            equal(title.box.y1, 0);
        });

        it("legend is created", () => {
            ok(legend instanceof Legend);
        });

        it("legend series are populated", () => {
            equal(legend.options.items[0].text, "Value");
        });

        it("default legend marker color is used when color is fn", () => {
            destroyChart(chart);
            setupChart([{ color: function() { return "#foo"; }, name: "aaa" }]);
            equal(legend.options.items[0].markerColor, "#ff6800");
        });

        it("series can be excluded from legend", () => {
            destroyChart(chart);
            setupChart([{
                name: "Value",
                type: "bar",
                data: [100, 200, 300],
                visibleInLegend: false
            }]);

            equal(legend.options.items.length, 0);
        });

        it("legend labels template", () => {
            destroyChart(chart);
            setupChart([{
                name: "Value",
                type: "bar",
                data: [100, 200, 300],
                test: "test"
            }], {
                legend: {
                    labels: {
                        template: "#= text #-#= series.test #"
                    }
                }
            });

            equal(legend.options.items[0].text, "Value-test");
        });

        it("legend is positioned at right", () => {
            equal(legend.box.x1,
                model.box.width() - legend.box.width());
        });

        it("legend is positioned at vertical center", () => {
            const titleHeight = title.box.height(),
                vCenter = titleHeight +
                          ((model.box.height() - titleHeight - legend.box.height()) / 2);
            equal(legend.box.y1, vCenter);
        });

        it("Categorical plotArea is created", () => {
            ok(plotArea instanceof CategoricalPlotArea);
        });
    });

    describe('Bar Chart Note', () => {
        let note;
        beforeEach(() => {
            setupChart([{
                name: "Value",
                type: "bar",
                data: [{ value: 10, noteText: "A" }]
            }]);
            note = chart._plotArea.charts[0].points[0].note;
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("should have text", () => {
            equal(note.text, "A");
        });
    });

    describe('Bar Chart Note / Template', () => {
        let note;
        afterEach(() => {
            destroyChart(chart);
        });

        function createNote(options) {
            setupChart([{
                name: "Value",
                type: "bar",
                data: [{ value: 10, category: "category", noteText: "A", test: "test" }],
                notes: deepExtend({}, options),
                name: "name"
            }]);
            note = chart._plotArea.charts[0].points[0].note;
        }

        it("dataItem", () => {
            createNote({
                label: {
                    template: "#= dataItem.test #"
                }
            });

            equal(note.label.content, "test");
        });

        it("category", () => {
            createNote({
                label: {
                    template: "#= category #"
                }
            });

            equal(note.label.content, "Alpha");
        });

        it("value", () => {
            createNote({
                label: {
                    template: "#= value #"
                }
            });

            equal(note.label.content, "10");
        });

        it("series", () => {
            createNote({
                label: {
                    template: "#= series.name #"
                }
            });

            equal(note.label.content, "name");
        });
    });
})();

// ------------------------------------------------------------
describe('Bar Chart / Configuration', () => {
    let chart;

    afterEach(() => {
        destroyChart(chart);
    });

    it("applies default color when color function returns undefined", () => {
        chart = createChart({
            seriesColors: ["red", "green"],
            series: [{
                data: [1, 2],
                color: function() { }
            }]
        });

        const barChart = chart._plotArea.charts[0];
        const colors = map(barChart.points, function(p) {
            return p.color || "UNDEFINED";
        });

        equal(colors, ["red", "red"]);
    });
});
