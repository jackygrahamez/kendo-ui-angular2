import 'core-js/es6';

import { DateCategoryAxis as Axis } from '../../src/core';
import { Box, Point } from '../../src/core';
import CategoricalPlotArea from '../../src/chart/plotarea/categorical-plotarea';

import { deepExtend, map, last, grep, setDefaultOptions } from '../../src/common';

import { ok, equal, close, sameRectPath, arrayClose, equalTexts, sameBox, tzTest } from '../../test/test-helpers';

import '../../test/text-measure';
import '../../test/intl';
import IntlService from '../../src/intl-service';

const chartBox = new Box(0, 0, 800, 600);
const TOLERANCE = 1;
const MONDAY = 1;
let dateAxis;

class DateCategoryAxis extends Axis {

}

setDefaultOptions(DateCategoryAxis.prototype, {
    labels: {
        font: "16px Verdana, sans-serif"
    }
});

function getAxisTextBoxes() {
    return grep(dateAxis.visual.children, function(item) {
        if (item !== dateAxis._lineGroup && item !== dateAxis._backgroundPath && item !== dateAxis._gridLines) {
            return true;
        }
    });
}

function getAxisTexts() {
    return map(getAxisTextBoxes(), function(item) {
        return last(item.children);
    });
}


let categories;

function createDateCategoryAxis(options = {}) {
    dateAxis = new DateCategoryAxis(deepExtend(options, {
        _deferLabels: true
    }));
    dateAxis.createLabels();
    categories = dateAxis.options.categories;

    dateAxis.reflow(chartBox);
    dateAxis.renderVisual();
}

// ------------------------------------------------------------
describe('Date Category Axis / Configuration', () => {
    beforeEach(() => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/10")
            ]
        });
    });

    it("User set base unit is applied", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/03/10")
            ],
            baseUnit: "days"
        });

        equal(dateAxis.options.baseUnit, "days");
    });

    it("Default base unit is days", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01")
            ]
        });

        equal(dateAxis.options.baseUnit, "days");
    });

    it("Default base unit is days when no categories are defined", () => {
        createDateCategoryAxis();

        equal(dateAxis.options.baseUnit, "days");
    });

    it("Setting base unit to 'default' selects one based on minimum difference", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 00:00:00"), new Date("2012/02/01 00:20:00")
            ],
            baseUnit: "default"
        });

        equal(dateAxis.options.baseUnit, "minutes");
    });

    it("Empty base unit interpreted as 'default'", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/03/10")
            ],
            baseUnit: ""
        });

        equal(dateAxis.options.baseUnit, "months");
    });

    it("Invalid base unit interpreted as 'default'", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 00:00:00"), new Date("2012/02/01 00:20:00")
            ],
            baseUnit: "fortnight"
        });

        equal(dateAxis.options.baseUnit, "minutes");
    });

    it("Min date can be parsed from string", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05"), new Date("2012/02/10")
            ],
            min: "2012/02/01"
        });

        equal(dateAxis.options.min, new Date("2012/02/01 00:00"));
    });

    it("Max date can be parsed from string", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/5")
            ],
            max: "2012/02/15"
        });

        equal(dateAxis.options.max, new Date("2012/02/15 00:00"));
    });

    it("No categories", 0, () => {
        createDateCategoryAxis();
    });

    it("Base unit step is applied for explicit baseUnit", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/07")
            ],
            baseUnit: "days",
            baseUnitStep: 3
        });

        equal(categories, [
            new Date("2012/02/01"), new Date("2012/02/04"),
            new Date("2012/02/07")
        ]);
    });

    it("Categories are rounded to next base unit", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/05")
            ],
            baseUnit: "days",
            baseUnitStep: 3
        });

        equal(categories, [
            new Date("2012/02/01"), new Date("2012/02/04")
        ]);
    });

    it("Empty categories are kept when max value is specified", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/05")
            ],
            max: new Date("2012/02/05"),
            baseUnit: "days",
            baseUnitStep: 3
        });

        equal(categories, [
            new Date("2012/02/01"), new Date("2012/02/04"),
            new Date("2012/02/07")
        ]);
    });

    it("User set base unit step is disregarded when using automatic base unit", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/07")
            ],
            baseUnit: "fit",
            maxDateGroups: 3
        });

        equal(categories, [
            new Date("2012/02/01"), new Date("2012/02/04"),
            new Date("2012/02/07")
        ]);
    });

    it("maxDateGroups constraint does not alter default base unit", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:50:00")
            ],
            autoBaseUnitSteps: { minutes: [1] },
            maxDateGroups: 5
        });

        equal(dateAxis.options.baseUnit, "minutes");
    });

    it("maxDateGroups defaults to 10", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 00:00:00"), new Date("2012/02/10 00:00:00")
            ],
            baseUnit: "fit"
        });

        equal(dateAxis.options.baseUnitStep, 1);

        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 00:00:00"), new Date("2012/02/11 00:00:00")
            ],
            baseUnit: "fit"
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });

    it("Dates are sorted before grouping", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/04/01"), new Date("2012/02/01"), new Date("2012/03/01")
            ],
            baseUnit: "months"
        });

        equal(dateAxis.options.categories,
                [ new Date("2012/02/01"), new Date("2012/03/01"), new Date("2012/04/01") ]);
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / categoryIndex', () => {

    it("category indicies for aggregated categories", () => {
        createDateCategoryAxis({
            baseUnit: "months",
            categories: [
                new Date("2012/02/01"), new Date("2012/02/03")
            ]
        });

        equal(dateAxis.categoryIndex(new Date("2012/02/01")), 0);
        equal(dateAxis.categoryIndex(new Date("2012/02/03")), 0);
    });

    it("category indicies for sparse categories", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/03")
            ]
        });

        equal(dateAxis.categoryIndex(new Date("2012/02/01")), 0);
        equal(dateAxis.categoryIndex(new Date("2012/02/03")), 2);
    });

    it("category indicies when rounding is disabled", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 21:00:00"), new Date("2012/02/03 03:00:00")
            ],
            roundToBaseUnit: false
        });

        equal(dateAxis.categoryIndex(new Date("2012/02/01 21:00:00")), 0);
        equal(dateAxis.categoryIndex(new Date("2012/02/02 00:00:00")), 1);
        equal(dateAxis.categoryIndex(new Date("2012/02/03 03:00:00")), 2);
    });

    it("category indicies when rounding is disabled and not applicable", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/03")
            ],
            roundToBaseUnit: false
        });

        equal(dateAxis.categoryIndex(new Date("2012/02/01")), 0);
        equal(dateAxis.categoryIndex(new Date("2012/02/03")), 2);
    });

    it("category indicies when rounding is disabled (justified)", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 21:00:00"), new Date("2012/02/03 03:00:00")
            ],
            roundToBaseUnit: false,
            justified: true
        });

        equal(dateAxis.categoryIndex(new Date("2012/02/01 21:00:00")), 0);
        equal(dateAxis.categoryIndex(new Date("2012/02/03 03:00:00")), 2);
    });

    it("category indicies when rounding is disabled and not applicable (justified)", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/03")
            ],
            roundToBaseUnit: false,
            justified: true
        });

        equal(dateAxis.categoryIndex(new Date("2012/02/01")), 0);
        equal(dateAxis.categoryIndex(new Date("2012/02/03")), 2);
    });

    it("categoryIndex accepts string", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/03")
            ],
            roundToBaseUnit: false,
            justified: true
        });

        equal(dateAxis.categoryIndex("2012/02/03"), 2);
    });

    it("categoryAxis returns exact index if value is smaller than min axis value", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/03")
            ]
        });

        equal(dateAxis.categoryIndex(new Date("2012/01/31")), -1);
        equal(dateAxis.categoryIndex(new Date("2012/01/01")), -31);
    });

    it("categoryAxis returns -1 if there are no categories", () => {
        createDateCategoryAxis({
            categories: []
        });

        equal(dateAxis.categoryIndex(new Date("2012/01/31")), -1);
    });

    it("categoryAxis returns exact index if value is larger then max axis value", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/03")
            ]
        });

        equal(dateAxis.categoryIndex(new Date("2012/02/04"), null, true), 3);
        equal(dateAxis.categoryIndex(new Date("2012/02/05"), null, true), 4);
    });

    tzTest("Sofia", "returns correct index for days baseUnit during DST", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2016/03/26"), new Date("2016/03/27"), new Date("2016/03/28")
            ],
            baseUnit: "days"
        });

        equal(dateAxis.categoryIndex(new Date("2016/03/28"), null), 2);
    });

    tzTest("Sofia", "returns correct index for weeks baseUnit during DST", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2016/03/27"), new Date("2016/03/28")
            ],
            baseUnit: "weeks",
            weekStartDay: MONDAY
        });

        equal(dateAxis.categoryIndex(new Date("2016/03/28"), null), 1);
    });

    tzTest("Sofia", "returns correct index for hours baseUnit during DST", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2016/03/27 2:00"), new Date("2016/03/28")
            ],
            baseUnit: "hours"
        });

        equal(dateAxis.categoryIndex(new Date("2016/03/27 4:00"), null), 1);

        createDateCategoryAxis({
            categories: [
                new Date("2011/10/30 03:00"), new Date("2011/10/31")
            ],
            baseUnit: "hours"
        });

        equal(dateAxis.categoryIndex(new Date("2011/10/30 04:00"), null), 2);
    });

    tzTest("Sofia", "returns correct index for minutes baseUnit during DST", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2016/03/27 2:00"), new Date("2016/03/28")
            ],
            baseUnit: "minutes",
            baseUnitStep: 60
        });

        equal(dateAxis.categoryIndex(new Date("2016/03/27 4:00"), null), 1);

        createDateCategoryAxis({
            categories: [
                new Date("2011/10/30 03:00"), new Date("2011/10/31")
            ],
            baseUnit: "minutes",
            baseUnitStep: 60
        });

        equal(dateAxis.categoryIndex(new Date("2011/10/30 04:00"), null), 2);
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / Min-Max values', () => {
    beforeEach(() => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/10")
            ]
        });
    });

    it("User set min value smaller than first category is applied", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05"), new Date("2012/02/06")
            ],
            min: new Date("2012/02/04")
        });

        equal(categories, [
            new Date("2012/02/04"), new Date("2012/02/05"),
            new Date("2012/02/06")
        ]);
    });

    it("User set min value larger than first category is applied", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05"), new Date("2012/02/06")
            ],
            min: new Date("2012/02/06")
        });

        equal(categories, [
            new Date("2012/02/06")
        ]);
    });

    it("User set max value smaller than last category", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05"), new Date("2012/02/06")
            ],
            max: new Date("2012/02/05")
        });

        equal(categories, [
            new Date("2012/02/05")
        ]);
    });

    it("User set max value smaller than last category (rounding off)", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05"), new Date("2012/02/06")
            ],
            max: new Date("2012/02/05"),
            roundToBaseUnit: false
        });

        equal(categories, [
            new Date("2012/02/05")
        ]);
    });

    it("User set max value larger than last category", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05"), new Date("2012/02/06")
            ],
            max: new Date("2012/02/07")
        });

        equal(categories, [
            new Date("2012/02/05"), new Date("2012/02/06"),
            new Date("2012/02/07")
        ]);
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / range', () => {

    it("auto max", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05"), new Date("2012/02/06")
            ],
            baseUnit: "days"
        });

        const range = dateAxis.range();

        equal(range.max.getTime(), new Date("2012/02/07").getTime());
    });

    it("auto max with not round max value", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05"), new Date("2012/02/06 10:00")
            ],
            baseUnit: "days"
        });

        const range = dateAxis.range();

        equal(range.max.getTime(), new Date("2012/02/07").getTime());
    });

    it("auto max with step bigger than one", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05"), new Date("2012/02/10")
            ],
            baseUnitStep: 3,
            baseUnit: "days"
        });

        const range = dateAxis.range();

        equal(range.max.getTime(), new Date("2012/02/11").getTime());
    });

    it("auto max with step bigger than one based on source range", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05"), new Date("2012/02/10")
            ],
            min: new Date("2012/02/07"),
            baseUnitStep: 3,
            baseUnit: "days"
        });

        const range = dateAxis.range();

        equal(range.max.getTime(), new Date("2012/02/11").getTime());
    });

    it("auto min", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05"), new Date("2012/02/06")
            ],
            baseUnit: "days"
        });

        const range = dateAxis.range();

        equal(range.min.getTime(), new Date("2012/02/05").getTime());
    });

    it("auto min with not round min value", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05 10:00"), new Date("2012/02/06 10:00")
            ],
            baseUnit: "days"
        });

        const range = dateAxis.range();

        equal(range.min.getTime(), new Date("2012/02/05").getTime());
    });

    it("auto min with step bigger than one based on source range", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05"), new Date("2012/02/10")
            ],
            min: new Date("2012/02/07"),
            baseUnitStep: 3,
            baseUnit: "days"
        });

        const range = dateAxis.range();

        equal(range.min.getTime(), new Date("2012/02/05").getTime());
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / valueRange', () => {
    beforeEach(() => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/10")
            ],
            baseUnit: "months"
        });
    });

    it("returns source categories min and max date", () => {
        const range = dateAxis.valueRange();

        equal(range.min.getTime(), new Date("2012/02/01").getTime());
        equal(range.max.getTime(), new Date("2012/02/10").getTime());
    });
});

(function() {

    // ------------------------------------------------------------
    describe('Date Category Axis / range indices / justified / no rounding', () => {

        it("auto range", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 00:00"), new Date("2012/02/06 00:00")
                ],
                baseUnit: "days",
                justified: true,
                roundToBaseUnit: false
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0);
            equal(range.max, 1);
        });

        it("auto range with not round dates", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 12:00"), new Date("2012/02/06 12:00")
                ],
                baseUnit: "days",
                justified: true,
                roundToBaseUnit: false
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0.5);
            equal(range.max, 1.5);
        });

        it("auto range with baseUnitStep bigger than one", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 00:00"), new Date("2012/02/08 00:00")
                ],
                baseUnitStep: 2,
                baseUnit: "days",
                justified: true,
                roundToBaseUnit: false
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0);
            equal(range.max, 1.5);
        });

        it("auto range with not round dates and baseUnitStep bigger than one", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 12:00"), new Date("2012/02/08 12:00")
                ],
                baseUnitStep: 2,
                baseUnit: "days",
                justified: true,
                roundToBaseUnit: false
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0.25);
            equal(range.max, 1.75);
        });

        it("range with baseUnitStep bigger than one based on source range", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 00:00"), new Date("2012/02/08 00:00")
                ],
                min: new Date("2012/02/06 00:00"),
                baseUnitStep: 2,
                baseUnit: "days",
                justified: true,
                roundToBaseUnit: false
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0.5);
            equal(range.max, 1.5);
        });
    });

    // ------------------------------------------------------------
    describe('Date Category Axis / range indices / justified / rounded', () => {

        it("auto range", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 00:00"), new Date("2012/02/06 00:00")
                ],
                baseUnit: "days",
                justified: true,
                roundToBaseUnit: true
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0);
            equal(range.max, 1);
        });

        it("auto range with not round dates", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 12:00"), new Date("2012/02/06 12:00")
                ],
                baseUnit: "days",
                justified: true,
                roundToBaseUnit: true
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0);
            equal(range.max, 1);
        });

        it("auto range with baseUnitStep bigger than one", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 00:00"), new Date("2012/02/08 00:00")
                ],
                baseUnitStep: 2,
                baseUnit: "days",
                justified: true,
                roundToBaseUnit: true
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0);
            equal(range.max, 1);
        });

        it("auto range with not round dates and baseUnitStep bigger than one", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 12:00"), new Date("2012/02/08 12:00")
                ],
                baseUnitStep: 2,
                baseUnit: "days",
                justified: true,
                roundToBaseUnit: true
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0);
            equal(range.max, 1);
        });

        it("range with baseUnitStep bigger than one based on source range", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 00:00"), new Date("2012/02/08 00:00")
                ],
                min: new Date("2012/02/06 00:00"),
                baseUnitStep: 2,
                baseUnit: "days",
                justified: true,
                roundToBaseUnit: true
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0);
            equal(range.max, 1);
        });
    });

    // ------------------------------------------------------------
    describe('Date Category Axis / range indices / not justified / no rounding', () => {

        it("auto range", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 00:00"), new Date("2012/02/06 00:00")
                ],
                baseUnit: "days",
                justified: false,
                roundToBaseUnit: false
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0);
            equal(range.max, 2);
        });

        it("auto range with not round dates", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 12:00"), new Date("2012/02/06 12:00")
                ],
                baseUnit: "days",
                justified: false,
                roundToBaseUnit: false
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0.5);
            equal(range.max, 1.5);
        });

        it("auto range with baseUnitStep bigger than one", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 00:00"), new Date("2012/02/08 00:00")
                ],
                baseUnitStep: 2,
                baseUnit: "days",
                justified: false,
                roundToBaseUnit: false
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0);
            equal(range.max, 1.5);
        });

        it("auto range with not round dates and baseUnitStep bigger than one", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 12:00"), new Date("2012/02/08 12:00")
                ],
                baseUnitStep: 2,
                baseUnit: "days",
                justified: false,
                roundToBaseUnit: false
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0.25);
            equal(range.max, 1.75);
        });

        it("range with baseUnitStep bigger than one based on source range", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 00:00"), new Date("2012/02/08 00:00")
                ],
                min: new Date("2012/02/06 00:00"),
                baseUnitStep: 2,
                baseUnit: "days",
                justified: false,
                roundToBaseUnit: false
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0.5);
            equal(range.max, 1.5);
        });
    });

    // ------------------------------------------------------------
    describe('Date Category Axis / range indices / not justified / rounded', () => {

        it("auto range", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 00:00"), new Date("2012/02/06 00:00")
                ],
                baseUnit: "days",
                justified: false,
                roundToBaseUnit: true
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0);
            equal(range.max, 2);
        });

        it("auto range with not round dates", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 12:00"), new Date("2012/02/06 12:00")
                ],
                baseUnit: "days",
                justified: false,
                roundToBaseUnit: true
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0);
            equal(range.max, 2);
        });

        it("auto range with baseUnitStep bigger than one", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 00:00"), new Date("2012/02/08 00:00")
                ],
                baseUnitStep: 2,
                baseUnit: "days",
                justified: false,
                roundToBaseUnit: true
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0);
            equal(range.max, 2);
        });

        it("auto range with not round dates and baseUnitStep bigger than one", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 12:00"), new Date("2012/02/08 12:00")
                ],
                baseUnitStep: 2,
                baseUnit: "days",
                justified: false,
                roundToBaseUnit: true
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0);
            equal(range.max, 2);
        });

        it("range with baseUnitStep bigger than one based on source range", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 00:00"), new Date("2012/02/08 00:00")
                ],
                min: new Date("2012/02/06 00:00"),
                baseUnitStep: 2,
                baseUnit: "days",
                justified: false,
                roundToBaseUnit: true
            });

            const range = dateAxis.rangeIndices();

            equal(range.min, 0);
            equal(range.max, 2);
        });
    });

})();

(function() {

    const TOLERANCE = 60000;

    function compareRange(actual, expected) {
        close(actual.min.getTime(), expected.min.getTime(), TOLERANCE);
        close(actual.max.getTime(), expected.max.getTime(), TOLERANCE);
    }

    // ------------------------------------------------------------
    describe('Date Category Axis / pan', () => {

        it("returns translated range", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/08")
                ],
                min: new Date("2012/02/06"),
                max: new Date("2012/02/07")
            });

            let range = dateAxis.pan(10);

            compareRange(range, {
                min: new Date("2012/02/06 00:18"),
                max: new Date("2012/02/07 00:18")
            });

            range = dateAxis.pan(-10);
            compareRange(range, {
                min: new Date("2012/02/05 23:42"),
                max: new Date("2012/02/06 23:42")
            });
        });

        it("returns nothing if new range is out of limits", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/08")
                ]
            });

            let range = dateAxis.pan(10);

            ok(!range);

            range = dateAxis.pan(-10);

            ok(!range);
        });

        it("returns translated range if user set minimum is after the automatic maximum", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/08")
                ],
                min: new Date("2012/02/10"),
                max: new Date("2012/02/11")
            });

            const range = dateAxis.pan(-10);

            compareRange(range, {
                min: new Date("2012/02/09 23:42"),
                max: new Date("2012/02/10 23:42")
            });
        });

        it("returns translated range if user set maximum is before the automatic minimum", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/08")
                ],
                min: new Date("2012/02/02"),
                max: new Date("2012/02/03")
            });

            const range = dateAxis.pan(10);

            compareRange(range, {
                min: new Date("2012/02/02 00:18"),
                max: new Date("2012/02/03 00:18")
            });
        });

        it("returns calculated baseUnit and baseUnitStep if baseUnit is set to fit", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/08")
                ],
                min: new Date("2012/02/06"),
                max: new Date("2012/02/07"),
                baseUnit: "fit"
            });

            const range = dateAxis.pan(10);

            equal(range.baseUnit, "hours");
            equal(range.baseUnitStep, 3);
        });

        it("returns user set baseUnit and baseUnitStep", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/08")
                ],
                min: new Date("2012/02/06"),
                max: new Date("2012/02/07"),
                baseUnit: "fit",
                baseUnitStep: 1
            });

            const range = dateAxis.pan(10);

            equal(range.userSetBaseUnit, "fit");
            equal(range.userSetBaseUnitStep, 1);
        });
    });

    // ------------------------------------------------------------
    describe('Date Category Axis / pan / not justified', () => {

        it("translates from automatic maximum", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/08")
                ],
                min: new Date("2012/02/06")
            });

            const range = dateAxis.pan(-10);

            compareRange(range, {
                min: new Date("2012/02/05 23:06"),
                max: new Date("2012/02/08 23:06")
            });
        });

        it("translates from automatic maximum (no rounding)", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/08 12:00")
                ],
                min: new Date("2012/02/06"),
                roundToBaseUnit: false
            });

            const range = dateAxis.pan(-10);

            compareRange(range, {
                min: new Date("2012/02/05 23:15"),
                max: new Date("2012/02/08 11:15")
            });
        });

        it("translates in positive direction from automatic maximum if the maximum is not round category (no rounding)", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/08 12:00")
                ],
                min: new Date("2012/02/06"),
                roundToBaseUnit: false
            });

            const range = dateAxis.pan(10);

            compareRange(range, {
                min: new Date("2012/02/06 00:45"),
                max: new Date("2012/02/08 12:45")
            });
        });

        it("translates from automatic minimum", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/08")
                ],
                max: new Date("2012/02/06")
            });

            const range = dateAxis.pan(10);

            compareRange(range, {
                min: new Date("2012/02/05 00:18"),
                max: new Date("2012/02/06 00:18")
            });
        });

        it("translates from automatic minimum (no rounding)", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 12:00"), new Date("2012/02/08 12:00")
                ],
                max: new Date("2012/02/06 12:00"),
                roundToBaseUnit: false
            });

            const range = dateAxis.pan(10);

            compareRange(range, {
                min: new Date("2012/02/05 12:18"),
                max: new Date("2012/02/06 12:18")
            });
        });

        it("translates in negative direction from automatic minimum if the minimum is not round category (no rounding)", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 12:00"), new Date("2012/02/08 12:00")
                ],
                max: new Date("2012/02/06 12:00"),
                roundToBaseUnit: false
            });

            const range = dateAxis.pan(-10);

            compareRange(range, {
                min: new Date("2012/02/05 11:42"),
                max: new Date("2012/02/06 11:42")
            });
        });
    });

    // ------------------------------------------------------------
    describe('Date Category Axis / pan / justified', () => {

        it("translates from automatic maximum", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/08")
                ],
                min: new Date("2012/02/06"),
                justified: true
            });

            const range = dateAxis.pan(-10);

            compareRange(range, {
                min: new Date("2012/02/05 23:24"),
                max: new Date("2012/02/07 23:24")
            });
        });

        it("translates from automatic maximum (no rounding)", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/08 12:00")
                ],
                min: new Date("2012/02/06"),
                roundToBaseUnit: false,
                justified: true
            });

            const range = dateAxis.pan(-10);

            compareRange(range, {
                min: new Date("2012/02/05 23:15"),
                max: new Date("2012/02/08 11:15")
            });
        });

        it("returns nothing if panning in positive direction from automatic maximum if the maximum is not round category (no rounding)", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/08 12:00")
                ],
                min: new Date("2012/02/06"),
                justified: true,
                roundToBaseUnit: false
            });

            const range = dateAxis.pan(10);

            ok(!range);
        });

        it("translates from automatic minimum", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/08")
                ],
                max: new Date("2012/02/06"),
                justified: true
            });

            const range = dateAxis.pan(10);

            compareRange(range, {
                min: new Date("2012/02/05 00:18"),
                max: new Date("2012/02/06 00:18")
            });
        });

        it("translates from automatic minimum (no rounding)", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 12:00"), new Date("2012/02/08 12:00")
                ],
                max: new Date("2012/02/06 12:00"),
                roundToBaseUnit: false,
                justified: true
            });

            const range = dateAxis.pan(10);

            compareRange(range, {
                min: new Date("2012/02/05 12:18"),
                max: new Date("2012/02/06 12:18")
            });
        });

        it("translates in negative direction from automatic minimum if the minimum is not round category (no rounding)", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05 12:00"), new Date("2012/02/08 12:00")
                ],
                max: new Date("2012/02/06 12:00"),
                justified: true,
                roundToBaseUnit: false
            });

            const range = dateAxis.pan(-10);

            compareRange(range, {
                min: new Date("2012/02/05 11:42"),
                max: new Date("2012/02/06 11:42")
            });
        });
    });

})();

(function() {

    const TOLERANCE = 60000;

    function compareRange(actual, expected, tolerance) {
        close(actual.min.getTime(), expected.min.getTime(), tolerance || TOLERANCE);
        close(actual.max.getTime(), expected.max.getTime(), tolerance || TOLERANCE);
    }

    // ------------------------------------------------------------
    describe('Date Category Axis / zoomRange', () => {

        it("returns scaled range", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/10")
                ],
                min: new Date("2012/02/06"),
                max: new Date("2012/02/09"),
                baseUnit: "days"
            });

            let range = dateAxis.zoomRange(1);

            compareRange(range, {
                min: new Date("2012/02/07"),
                max: new Date("2012/02/08")
            });

            range = dateAxis.zoomRange(-1);
            compareRange(range, {
                min: new Date("2012/02/05"),
                max: new Date("2012/02/10")
            });
        });

        it("scales range based on baseUnitStep", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/14")
                ],
                min: new Date("2012/02/07"),
                max: new Date("2012/02/12"),
                baseUnitStep: 2,
                baseUnit: "days"
            });

            let range = dateAxis.zoomRange(1);

            compareRange(range, {
                min: new Date("2012/02/09"),
                max: new Date("2012/02/10")
            });

            range = dateAxis.zoomRange(-1);
            compareRange(range, {
                min: new Date("2012/02/05"),
                max: new Date("2012/02/14")
            });
        });

        it("returns nothing if new range is smaller than the baseUnit", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/08")
                ],
                min: new Date("2012/02/06"),
                max: new Date("2012/02/08"),
            });

            const range = dateAxis.zoomRange(1);

            ok(!range);
        });

        it("limits minimum to axis minimum", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/12")
                ],
                min: new Date("2012/02/06"),
                max: new Date("2012/02/08"),
                baseUnitStep: 2,
                baseUnit: "days"
            });

            const range = dateAxis.zoomRange(-1);

            compareRange(range, {
                min: new Date("2012/02/05"),
                max: new Date("2012/02/10")
            });
        });

        it("limits maximum to axis maximum", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/12")
                ],
                min: new Date("2012/02/09"),
                max: new Date("2012/02/12"),
                baseUnitStep: 2,
                baseUnit: "days"
            });

            const range = dateAxis.zoomRange(-1);

            compareRange(range, {
                min: new Date("2012/02/07"),
                max: new Date("2012/02/13")
            });
        });

        it("returns baseUnit and baseUnitStep equal to the user set options", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/05"), new Date("2012/02/12")
                ],
                min: new Date("2012/02/09"),
                max: new Date("2012/02/12"),
                baseUnitStep: 15,
                baseUnit: "fit"
            });

            const range = dateAxis.zoomRange(-1);

            equal(range.baseUnit, "fit");
            equal(range.baseUnitStep, 15);
        });
    });

    // ------------------------------------------------------------
    describe('Date Category Axis / zoomRange / fit / zoom in', () => {

        it("jumps from years to months", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2013/01/01"), new Date("2014/01/01")
                ],
                min: new Date("2013/01/01"),
                max: new Date("2014/01/01"),
                autoBaseUnitSteps: {
                    months: [1]
                },
                baseUnit: "fit"
            });

            const range = dateAxis.zoomRange(1);

            compareRange(range, {
                min: new Date("2013/02/13 00:00"),
                max: new Date("2013/11/19 00:00")
            });
        });

        it("jumps from months to weeks", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2013/01/01"), new Date("2014/01/01")
                ],
                min: new Date("2013/04/01"),
                max: new Date("2013/06/01"),
                maxDateGroups: 3,
                autoBaseUnitSteps: {
                    weeks: [1]
                },
                baseUnit: "fit"
            });

            const range = dateAxis.zoomRange(1);

            compareRange(range, {
                min: new Date("2013/04/24 12:00"),
                max: new Date("2013/05/08 12:00")
            });
        });

        it("jumps from weeks to days", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2013/01/01"), new Date("2014/01/01")
                ],
                min: new Date("2013/04/01"),
                max: new Date("2013/04/14"),
                maxDateGroups: 3,
                autoBaseUnitSteps: {
                    days: [1]
                },
                baseUnit: "fit"
            });

            const range = dateAxis.zoomRange(1);

            compareRange(range, {
                min: new Date("2013/04/06 12:00"),
                max: new Date("2013/04/08 12:00")
            });
        });

        it("jumps from days to hours", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2013/01/01"), new Date("2014/01/01")
                ],
                min: new Date("2013/04/01"),
                max: new Date("2013/04/03"),
                baseUnit: "fit"
            });

            const range = dateAxis.zoomRange(1);

            compareRange(range, {
                min: new Date("2013/04/01 10:30"),
                max: new Date("2013/04/02 13:30")
            });
        });

        it("jumps from hours to minutes", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2013/01/01"), new Date("2014/01/01")
                ],
                autoBaseUnitSteps: {
                    minutes: [10]
                },
                min: new Date("2013/04/01 00:00"),
                max: new Date("2013/04/01 02:00"),
                baseUnit: "fit"
            });

            const range = dateAxis.zoomRange(1);

            compareRange(range, {
                min: new Date("2013/04/01 00:15"),
                max: new Date("2013/04/01 01:45")
            });
        });

        it("jumps from minutes to seconds", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2013/01/01"), new Date("2014/01/01")
                ],
                autoBaseUnitSteps: {
                    seconds: [10]
                },
                min: new Date("2013/04/01 00:01"),
                max: new Date("2013/04/01 00:03"),
                baseUnit: "fit"
            });

            const range = dateAxis.zoomRange(1);

            compareRange(range, {
                min: new Date("2013/04/01 00:01:15"),
                max: new Date("2013/04/01 00:02:45")
            });
        });

        it("jumps from seconds to milliseconds", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2013/01/01"), new Date("2014/01/01")
                ],
                autoBaseUnitSteps: {
                    milliseconds: [500]
                },
                min: new Date("2013/04/01 00:01:00"),
                max: new Date("2013/04/01 00:01:03"),
                baseUnit: "fit"
            });

            const range = dateAxis.zoomRange(1);
            
            compareRange(range, {
                min: new Date("2013/04/01 00:01:00.500"),
                max: new Date("2013/04/01 00:01:02.500")
            }, 1);
        });

        it("returns valid range if the range becomes less than a second", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2013/01/01"), new Date("2014/01/01")
                ],
                autoBaseUnitSteps: {
                    milliseconds: [],
                    seconds: [10]
                },
                min: new Date("2013/04/01 00:00:10"),
                max: new Date("2013/04/01 00:00:30"),
                baseUnit: "fit"
            });

            const range = dateAxis.zoomRange(1);

            ok(!range);
        });

        it("returns undefined if the range becomes less than a millisecond", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2013/01/01"), new Date("2014/01/01")
                ],
                autoBaseUnitSteps: {
                    milliseconds: [500]
                },
                min: new Date("2013/04/01 00:00:10.000"),
                max: new Date("2013/04/01 00:00:10.000"),
                baseUnit: "fit"
            });

            const range = dateAxis.zoomRange(1);

            ok(!range);
        });
    });

    // ------------------------------------------------------------
    describe('Date Category Axis / pointsRange', () => {

        it("returns dates range based on points", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2013/01/01"), new Date("2014/01/01")
                ],
                min: new Date("2013/01/01 10:00"),
                max: new Date("2013/01/05 10:00"),
                vertical: false
            });

            const range = dateAxis.pointsRange(new Point(0, 0), new Point(799, 0));

            compareRange(range, {
                min: new Date("2013/01/01 10:00"),
                max: new Date("2013/01/05 10:00")
            });
        });

        it("returns the user set baseUnit and baseUnitStep as baseUnit and baseUnitStep", () => {
            createDateCategoryAxis({
                categories: [
                    new Date("2013/01/01"), new Date("2014/01/01")
                ],
                min: new Date("2013/01/01 10:00"),
                max: new Date("2013/01/05 10:00"),
                vertical: false,
                baseUnit: "fit",
                baseUnitStep: 100
            });

            const range = dateAxis.pointsRange(new Point(0, 0), new Point(799, 0));

            equal(range.baseUnit, "fit");
            equal(range.baseUnitStep, 100);
        });
    });

})();

// ------------------------------------------------------------
describe('Date Category Axis / Base unit / Minutes', () => {

    it("Base unit is determined by series delta", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05 11:00:00"), new Date("2012/02/05 11:05:00")
            ]
        });

        equal(dateAxis.options.baseUnit, "minutes");
    });

    it("creates labels with default format", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:02:00")
            ]
        });
        equalTexts(getAxisTexts(), ["10:00", "10:01", "10:02"]);
    });

    it("automatic base unit step is chosen according to maxDateGroups", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:10:00")
            ],
            baseUnitStep: "auto",
            maxDateGroups: 6
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });

    it("automatic base unit step is increased to satisfy maxDateGroups", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:10:00")
            ],
            baseUnitStep: "auto",
            autoBaseUnitSteps: { minutes: [1] },
            maxDateGroups: 6
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });

    it("base unit step is limited to specified value", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:05:00")
            ],
            baseUnitStep: "auto",
            autoBaseUnitSteps: { minutes: [10] }
        });

        equal(dateAxis.options.baseUnitStep, 10);
    });

    it("base unit is not chosen if it has no valid automatic steps", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:05:00")
            ],
            baseUnit: "fit",
            baseUnitStep: "auto",
            autoBaseUnitSteps: { minutes: [] }
        });

        equal(dateAxis.options.baseUnit, "hours");
    });

    it("automatic base unit (hours) is chosen according to maxDateGroups", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:50:00")
            ],
            baseUnit: "fit",
            autoBaseUnitSteps: { minutes: [1] },
            maxDateGroups: 5
        });

        equal(dateAxis.options.baseUnit, "hours");
    });

    it("maxDateGroups keeps user set base unit", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:50:00")
            ],
            autoBaseUnitSteps: { minutes: [1] },
            baseUnit: "minutes",
            maxDateGroups: 5
        });

        equal(dateAxis.options.baseUnit, "minutes");
    });

    it("maxDateGroups constraint has lower priority than base unit step", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:10:00")
            ],
            maxDateGroups: 6,
            baseUnitStep: 1
        });

        equal(dateAxis.options.baseUnitStep, 1);
    });

    tzTest("Sofia", "includes fall DST hour", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2011/10/30 03:00"), new Date("2011/10/30 04:00")
            ],
            baseUnit: "minutes",
            baseUnitStep: 60
        });
        const dstHour = dateAxis.options.categories[1];
        equal(dateAxis.options.categories.length, 3);
        equal(dstHour, new Date( new Date(2011, 9, 30, 3, 59, 59, 999).getTime() + 1));
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / Base unit / Seconds', () => {

    it("Base unit is determined by series delta", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05 11:00:00"), new Date("2012/02/05 11:00:05")
            ]
        });

        equal(dateAxis.options.baseUnit, "seconds");
    });

    it("creates labels with default format", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:00:02")
            ]
        });
        equalTexts(getAxisTexts(), ["10:00:00", "10:00:01", "10:00:02"]);
    });

    it("automatic base unit step is chosen according to maxDateGroups", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:00:10")
            ],
            baseUnitStep: "auto",
            maxDateGroups: 6
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });

    it("automatic base unit step is increased to satisfy maxDateGroups", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:00:10")
            ],
            baseUnitStep: "auto",
            autoBaseUnitSteps: { seconds: [1] },
            maxDateGroups: 6
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });

    it("base unit step is limited to specified value", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:00:05")
            ],
            baseUnitStep: "auto",
            autoBaseUnitSteps: { seconds: [10] }
        });

        equal(dateAxis.options.baseUnitStep, 10);
    });

    it("base unit is not chosen if it has no valid automatic steps", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:00:05")
            ],
            baseUnit: "fit",
            baseUnitStep: "auto",
            autoBaseUnitSteps: { seconds: [] }
        });

        equal(dateAxis.options.baseUnit, "minutes");
    });

    it("automatic base unit (minutes) is chosen according to maxDateGroups", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:00:50")
            ],
            baseUnit: "fit",
            autoBaseUnitSteps: { seconds: [1] },
            maxDateGroups: 5
        });

        equal(dateAxis.options.baseUnit, "minutes");
    });

    it("maxDateGroups keeps user set base unit", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:00:50")
            ],
            autoBaseUnitSteps: { seconds: [1] },
            baseUnit: "seconds",
            maxDateGroups: 5
        });

        equal(dateAxis.options.baseUnit, "seconds");
    });

    it("maxDateGroups constraint has lower priority than base unit step", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 10:00:10")
            ],
            maxDateGroups: 6,
            baseUnitStep: 1
        });

        equal(dateAxis.options.baseUnitStep, 1);
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / No Rounding', () => {

    it("Major ticks are positioned at exact time", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 15:00:00"), new Date("2012/02/05 01:00:00")
            ],
            roundToBaseUnit: false
        });

        arrayClose(dateAxis.getMajorTickPositions(),
            [88, 321, 555, 789], 1);
    });

    it("Major ticks are not affected when start/end time match base unit", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 00:00:00"), new Date("2012/02/05 00:00:00")
            ],
            roundToBaseUnit: false
        });

        arrayClose(dateAxis.getMajorTickPositions(),
            [0, 160, 320, 480, 640, 799], 1);
    });

    it("Does not fail with no categories", 0, () => {
        createDateCategoryAxis({
            categories: [],
            roundToBaseUnit: false
        });
    });

    it("Preserves all categories when they match base units exactly", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/01/01"), new Date("2012/02/01"), new Date("2012/03/01")
            ],
            roundToBaseUnit: false
        });

        equal(last(dateAxis.options.categories), new Date("2012/03/01"));
    });

    it("Does not add categories beyond last day", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/01/01"), new Date("2012/01/01 12:00:00"),
                new Date("2012/01/02"), new Date("2012/01/02 12:00:00")
            ],
            baseUnit: "days",
            roundToBaseUnit: false
        });

        equal(last(dateAxis.options.categories), new Date("2012/01/02"));
    });

    it("Does not add categories beyond last week", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2013/02/24"), new Date("2013/03/02"),
                new Date("2013/03/03"), new Date("2013/03/09")
            ],
            baseUnit: "weeks",
            roundToBaseUnit: false
        });

        equal(last(dateAxis.options.categories), new Date("2013/03/03"));
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / No Rounding / Justified', () => {

    it("Major ticks are positioned at exact time", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 15:00:00"), new Date("2012/02/05 15:00:00")
            ],
            roundToBaseUnit: false,
            justified: true
        });

        arrayClose(dateAxis.getMajorTickPositions(),
            [75, 275, 474, 674] , 1);
    });

    it("Major ticks are not affected when start/end time match base unit", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 00:00:00"), new Date("2012/02/05 00:00:00")
            ],
            roundToBaseUnit: false,
            justified: true
        });

        arrayClose(dateAxis.getMajorTickPositions(),
            [0, 199.75, 400, 599.25, 799], 1);
    });

    it("First label is hidden if it does not match base unit", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 15:00:00"), new Date("2012/02/05 01:00:00")
            ],
            roundToBaseUnit: false,
            justified: true
        });

        equal(dateAxis.labels[0].text, "2/1");
        equal(dateAxis.labels[0].options.visible, false);
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / No Rounding / Reversed', () => {

    it("Major ticks are positioned at exact time", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 15:00:00"), new Date("2012/02/05 01:00:00")
            ],
            roundToBaseUnit: false,
            reverse: true
        });

        arrayClose(dateAxis.getMajorTickPositions(),
            [711, 477, 243, 10], 1);
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / Base unit / Minutes', () => {

    it("Base unit is determined by series delta", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05 23:55:00"), new Date("2012/02/06 00:00:00")
            ]
        });

        equal(dateAxis.options.baseUnit, "minutes");
    });

    it("Base unit is determined by series delta (DST boundary)", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2013/10/27 02:45:00"), new Date("2013/10/27 03:00:00")
            ]
        });

        equal(dateAxis.options.baseUnit, "minutes");
    });

    it("automatic base unit step is chosen according to maxDateGroups", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05 10:00:00"), new Date("2012/02/05 10:11:00")
            ],
            baseUnitStep: "auto",
            maxDateGroups: 10
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });

    it("maxDateGroups takes priority over preferred base unit step", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05 10:00:00"), new Date("2012/02/05 10:11:00")
            ],
            baseUnitStep: "auto",
            autoBaseUnitSteps: { minutes: [1] },
            maxDateGroups: 10
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / Base unit / Hours', () => {

    it("Base unit is determined by series delta (day boundary)", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05 23:00:00"), new Date("2012/02/06 00:00:00")
            ]
        });

        equal(dateAxis.options.baseUnit, "hours");
    });

    it("automatic base unit step is chosen according to maxDateGroups", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05 10:00:00"), new Date("2012/02/05 21:00:00")
            ],
            baseUnitStep: "auto",
            maxDateGroups: 10
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });

    it("maxDateGroups takes priority over preferred base unit step", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05 10:00:00"), new Date("2012/02/05 21:00:00")
            ],
            baseUnitStep: "auto",
            autoBaseUnitSteps: { hours: [1] },
            maxDateGroups: 10
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });

    it("maxDateGroups takes priority over preferred base unit step (fit)", () => {
        createDateCategoryAxis({
            categories: [
                new Date("1980/01/01 00:00:00"), new Date("2012/01/01 00:00:00")
            ],
            baseUnit: "fit",
            baseUnitStep: "auto",
            autoBaseUnitSteps: { years: [1] },
            maxDateGroups: 10
        });

        equal(dateAxis.options.baseUnitStep, 4);
    });

    it("automatic base unit (days) is chosen according to maxDateGroups", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 10:00:00"), new Date("2012/02/01 20:00:00")
            ],
            baseUnit: "fit",
            autoBaseUnitSteps: { hours: [1] },
            maxDateGroups: 5
        });

        equal(dateAxis.options.baseUnit, "days");
    });

    tzTest("Sofia", "includes fall DST hour", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2011/10/30 03:00"), new Date("2011/10/30 04:00")
            ],
            baseUnit: "houts"
        });
        const dstHour = dateAxis.options.categories[1];
        equal(dateAxis.options.categories.length, 3);
        equal(dstHour, new Date( new Date(2011, 9, 30, 3, 59, 59, 999).getTime() + 1));
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / Base unit / Days', () => {

    it("Base unit is determined by series delta", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/04"), new Date("2012/02/05")
            ]
        });

        equal(dateAxis.options.baseUnit, "days");
    });

    it("Base unit is determined by series delta (DST boundary)", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/03/24"), new Date("2012/03/25"), new Date("2012/03/26")
            ]
        });

        equal(dateAxis.options.baseUnit, "days");
    });

    it("Base unit is determined by series delta (month boundary)", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/29"), new Date("2012/03/01")
            ]
        });

        equal(dateAxis.options.baseUnit, "days");
    });

    it("Base unit is determined by series delta (year boundary)", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2011/12/31"), new Date("2012/01/01")
            ]
        });

        equal(dateAxis.options.baseUnit, "days");
    });

    it("Base unit is determined by minimum series delta", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2011/01/01"), new Date("2012/02/04"), new Date("2012/02/05")
            ]
        });

        equal(dateAxis.options.baseUnit, "days");
    });

    tzTest("Brazil", "Base unit is determined by series delta (Brazil DST boundary)", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2013/10/18"), new Date("2013/10/19"), new Date("2013/10/20")
            ]
        });

        //equal(dateAxis.options.baseUnit, "days");
        console.warn("SKIPPED: " + QUnit.config.current.testName+ ": Good luck finding out that the interval is a whole day");
        ok(true);
    });

    it("Base unit calculation ignores repeating categories", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/01"), new Date("2012/02/02")
            ]
        });

        equal(dateAxis.options.baseUnit, "days");
    });

    it("creates labels with default format", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/03")
            ]
        });
        equalTexts(getAxisTexts(), ["2/1", "2/2", "2/3"]);
    });

    it("labels have associated data items", () => {
        createDateCategoryAxis({
            dataItems: ["a", "b", "c"],
            categories: [
                new Date("2012/02/01"), new Date("2012/02/03")
            ]
        });

        equal(dateAxis.labels[0].dataItem, "a");
    });

    it("creates labels with custom date format", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/03")
            ],
            labels: {
                dateFormats: {
                    days: "M/d/yy"
                }
            }
        });
        equalTexts(getAxisTexts(), ["2/1/12", "2/2/12", "2/3/12"]);
    });

    it("creates labels with custom format", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/03")
            ],
            labels: {
                format: "M/d/yy"
            }
        });

        equalTexts(getAxisTexts(), ["2/1/12", "2/2/12", "2/3/12"]);
    });

    it("creates labels with custom culture", () => {
        const current = IntlService.implementation;
        const toString = current.toString;
        try {        
            current.toString = function(value, format, locale) {
               equal(locale, "es-ES");
            };
            createDateCategoryAxis({
                categories: [
                    new Date("2012/02/01"), new Date("2012/02/03")
                ],
                labels: {
                    format: "d.MMM",
                    culture: "es-ES"
                }
            });
        } finally {
            current.toString = toString;
        }
    });

    it("creates labels with custom template", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/03")
            ],
            labels: {
                template: function(data) {
                    return IntlService.implementation.toString(data.value, 'yyyy');
                }
            }
        });

        equalTexts(getAxisTexts(), ["2012", "2012", "2012"]);
    });

    it("automatic base unit step is chosen according to maxDateGroups", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 00:00:00"), new Date("2012/02/05 00:00:00")
            ],
            baseUnitStep: "auto",
            maxDateGroups: 3
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });

    it("automatic base unit step is calculated when outside of preset values", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 00:00:00"), new Date("2012/02/05 00:00:00")
            ],
            baseUnitStep: "auto",
            autoBaseUnitSteps: { days: [1] },
            maxDateGroups: 3
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });

    it("automatic base unit (weeks) is chosen according to maxDateGroups", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 00:00:00"), new Date("2012/02/20 00:00:00")
            ],
            baseUnit: "fit",
            autoBaseUnitSteps: { days: [1] },
            maxDateGroups: 5
        });

        equal(dateAxis.options.baseUnit, "weeks");
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / Base unit / Weeks', () => {

    it("Base unit is determined by series delta", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/8")
            ]
        });

        equal(dateAxis.options.baseUnit, "weeks");
    });

    it("creates labels with default format", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/01/01"), new Date("2012/01/15")
            ]
        });

        equalTexts(getAxisTexts(), ["1/1", "1/8", "1/15"]);
    });

    it("creates labels with custom date format", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/01/01"), new Date("2012/01/15")
            ],
            labels: {
                dateFormats: {
                    weeks: "M/d/yy"
                }
            }
        });

        equalTexts(getAxisTexts(), ["1/1/12", "1/8/12", "1/15/12"]);
    });

    it("week start day can be customized", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/01/01"), new Date("2012/01/15")
            ],
            weekStartDay: MONDAY
        });

        equalTexts(getAxisTexts(), ["12/26", "1/2", "1/9"]);
    });

    tzTest("Sofia", "automatic base unit step is chosen according to maxDateGroups", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05 00:00:00"), new Date("2012/03/03 00:00:00")
            ],
            baseUnitStep: "auto",
            maxDateGroups: 2
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });

    tzTest("Sofia", "automatic base unit step is calculated when outside of preset values", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05 00:00:00"), new Date("2012/03/03 00:00:00")
            ],
            baseUnitStep: "auto",
            autoBaseUnitSteps: { weeks: [1] },
            maxDateGroups: 2
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });

    it("automatic base unit (months) is chosen according to maxDateGroups", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/05 00:00:00"), new Date("2012/03/03 00:00:00")
            ],
            baseUnit: "fit",
            autoBaseUnitSteps: { weeks: [1] },
            maxDateGroups: 2
        });

        equal(dateAxis.options.baseUnit, "months");
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / Base unit / Months', () => {

    it("Base unit is determined by series delta", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/03/10")
            ]
        });

        equal(dateAxis.options.baseUnit, "months");
    });

    it("Base unit is set to months when range extends to next month end", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2011/01/31"), new Date("2011/02/28")
            ]
        });

        equal(dateAxis.options.baseUnit, "months");
    });

    it("Base unit is set to months when series delta is 1 month - 3 days", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2011/03/31"), new Date("2011/04/29")
            ]
        });

        equal(dateAxis.options.baseUnit, "months");
    });

    it("creates labels with default format", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/01/01"), new Date("2012/02/01")
            ]
        });

        equalTexts(getAxisTexts(), ["Jan '12", "Feb '12"]);
    });

    it("creates labels with custom date format", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/01/01"), new Date("2012/02/01")
            ],
            labels: {
                dateFormats: {
                    months: "M/d/yy"
                }
            }
        });

        equalTexts(getAxisTexts(), ["1/1/12", "2/1/12"]);
    });

    it("automatic base unit step is chosen according to maxDateGroups", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 00:00:00"), new Date("2012/06/01 00:00:00")
            ],
            baseUnitStep: "auto",
            maxDateGroups: 3
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });

    it("automatic base unit step is calculated when outside of preset values", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 00:00:00"), new Date("2012/06/01 00:00:00")
            ],
            baseUnitStep: "auto",
            autoBaseUnitSteps: { months: [1] },
            maxDateGroups: 3
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });

    it("automatic base unit (years) is chosen according to maxDateGroups", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 00:00:00"), new Date("2012/12/01 00:00:00")
            ],
            baseUnit: "fit",
            autoBaseUnitSteps: { months: [1] },
            maxDateGroups: 5
        });

        equal(dateAxis.options.baseUnit, "years");
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / Base unit / Years', () => {

    it("Base unit is determined by series delta", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2013/03/10")
            ]
        });

        equal(dateAxis.options.baseUnit, "years");
    });

    it("creates labels with default format", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/01/01"), new Date("2013/02/01")
            ]
        });

        equalTexts(getAxisTexts(), ["2012", "2013"]);
    });

    it("creates labels with custom date format", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/01/01"), new Date("2013/02/01")
            ],
            labels: {
                dateFormats: {
                    years: "M/d/yy"
                }
            }
        });

        equalTexts(getAxisTexts(), ["1/1/12", "1/1/13"]);
    });

    it("automatic base unit step is chosen according to maxDateGroups", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/01/01 00:00:00"), new Date("2016/01/01 00:00:00")
            ],
            baseUnitStep: "auto",
            maxDateGroups: 3
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });

    it("automatic base unit step is calculated when outside of preset values", () => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/01/01 00:00:00"), new Date("2016/01/01 00:00:00")
            ],
            baseUnitStep: "auto",
            autoBaseUnitSteps: { years: [1] },
            maxDateGroups: 3
        });

        equal(dateAxis.options.baseUnitStep, 2);
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / getSlot / No Rounding', () => {
    beforeEach(() => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 15:00:00"), new Date("2012/02/05 01:00:00")
            ],
            roundToBaseUnit: false
        });
    });

    it("Returns correct first partial slot", () => {
        sameBox(dateAxis.getSlot(0),
                new Box(-146, 0, 88, 0),
                TOLERANCE);
    });

    it("Returns correct first full slot", () => {
        sameBox(dateAxis.getSlot(1),
                new Box(88, 0, 322, 0),
                TOLERANCE);
    });

    it("Returns correct last full slot", () => {
        sameBox(dateAxis.getSlot(3),
                new Box(555, 0, 789, 0),
                TOLERANCE);
    });

    it("Returns correct last partial slot", () => {
        sameBox(dateAxis.getSlot(4),
                new Box(789, 0, 1023, 0),
                TOLERANCE);
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / getSlot / No Rounding / Justified', () => {
    beforeEach(() => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 15:00:00"), new Date("2012/02/05 01:00:00")
            ],
            roundToBaseUnit: false,
            justified: true
        });
    });

    it("Returns correct first partial slot", () => {
        sameBox(dateAxis.getSlot(0),
                new Box(-146, 0, -146, 0),
                TOLERANCE);
    });

    it("Returns correct first full slot", () => {
        sameBox(dateAxis.getSlot(1),
                new Box(88, 0, 88, 0),
                TOLERANCE);
    });

    it("Returns correct last full slot", () => {
        sameBox(dateAxis.getSlot(3),
                new Box(555, 0, 555, 0),
                TOLERANCE);
    });

    it("Returns correct last partial slot", () => {
        const lineBox = dateAxis.lineBox();
        sameBox(dateAxis.getSlot(4),
                new Box(789, 0, 789, 0),
                TOLERANCE);
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / slot', () => {
    beforeEach(() => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 15:00:00"), new Date("2012/02/05 01:00:00")
            ]
        });
    });

    it("slot method returns slot as rect", () => {
        const box = dateAxis.getSlot(0);
        const slot = dateAxis.slot(0);
        ok(slot.equals(box.toRect()));
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / getCategory', () => {
    beforeEach(() => {
        createDateCategoryAxis({
            categories: [new Date("2012/01/01")],
            labels: { visible: false }
        });
    });

    it("returns date", () => {
        equal(dateAxis.getCategory(new Point(0, 0)), new Date("2012/01/01"));
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / getCategory / No Rounding', () => {
    beforeEach(() => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 15:00:00"), new Date("2012/02/05 01:00:00")
            ],
            roundToBaseUnit: false
        });
    });

    it("Returns correct first partial category (left edge)", () => {
        equal(dateAxis.getCategory(new Point(0, 0)),
               new Date("2012/02/01 00:00:00"));
    });

    it("Returns correct first partial category (right edge)", () => {
        equal(dateAxis.getCategory(new Point(87, 0)),
               new Date("2012/02/01 00:00:00"));
    });

    it("Returns correct first full slot (left edge)", () => {
        equal(dateAxis.getCategory(new Point(89, 0)).toString(),
             new Date("2012/02/02 00:00:00").toString());
    });

    it("Returns correct first full slot (right edge)", () => {
        equal(dateAxis.getCategory(new Point(321, 0)).toString(),
             new Date("2012/02/02 00:00:00").toString());
    });

    it("Returns correct last full slot (left edge)", () => {
        equal(dateAxis.getCategory(new Point(556, 0)).toString(),
             new Date("2012/02/04 00:00:00").toString());
    });

    it("Returns correct last full slot (right edge)", () => {
        equal(dateAxis.getCategory(new Point(788, 0)).toString(),
             new Date("2012/02/04 00:00:00").toString());
    });

    it("Returns correct last partial slot (left edge)", () => {
        equal(dateAxis.getCategory(new Point(790, 0)).toString(),
             new Date("2012/02/05 00:00:00").toString());
    });

    it("Returns correct last partial slot (right edge)", () => {
        equal(dateAxis.getCategory(new Point(799, 0)).toString(),
             new Date("2012/02/05 00:00:00").toString());
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / getCategory / No Rounding / Justified', () => {
    beforeEach(() => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01 15:00:00"), new Date("2012/02/05 01:00:00")
            ],
            roundToBaseUnit: false,
            justified: true
        });
    });

    it("Returns correct first partial category (left edge)", () => {
        equal(dateAxis.getCategory(new Point(14, 0)),
               new Date("2012/02/02 00:00:00"));
    });

    it("Returns correct first partial category (right edge)", () => {
        equal(dateAxis.getCategory(new Point(14, 0)),
               new Date("2012/02/02 00:00:00"));
    });

    it("Returns correct first full slot (left edge)", () => {
        equal(dateAxis.getCategory(new Point(99, 0)).toString(),
             new Date("2012/02/02 00:00:00").toString());
    });

    it("Returns correct first full slot (right edge)", () => {
        equal(dateAxis.getCategory(new Point(324, 0)).toString(),
             new Date("2012/02/03 00:00:00").toString());
    });

    it("Returns correct last full slot (left edge)", () => {
        equal(dateAxis.getCategory(new Point(551, 0)).toString(),
             new Date("2012/02/04 00:00:00").toString());
    });

    it("Returns correct last full slot (right edge)", () => {
        equal(dateAxis.getCategory(new Point(776, 0)).toString(),
             new Date("2012/02/05 00:00:00").toString());
    });

    it("Returns correct last partial slot (left edge)", () => {
        equal(dateAxis.getCategory(new Point(778, 0)).toString(),
             new Date("2012/02/05 00:00:00").toString());
    });

    it("Returns correct last partial slot (right edge)", () => {
        equal(dateAxis.getCategory(new Point(dateAxis.lineBox().x2, 0)).toString(),
             new Date("2012/02/05 00:00:00").toString());
    });
});

// ------------------------------------------------------------
describe('Date Category Axis / Range manipulation', () => {
    beforeEach(() => {
        createDateCategoryAxis({
            categories: [
                new Date("2012/02/01"), new Date("2012/02/10")
            ]
        });
    });

    it("translateRange with negative delta", () => {
        const range = dateAxis.translateRange(-400);
        equal(range.min, new Date("2012/01/15"));
        equal(range.max, new Date("2012/01/29"));
    });

    it("translateRange with positive delta", () => {
        const range = dateAxis.translateRange(400);
        equal(range.min, new Date("2012/02/05"));
        equal(range.max, new Date("2012/02/19"));
    });

    it("translateRange uses min/max when no categories are defined", () => {
        createDateCategoryAxis({
            min: new Date("2012/02/01"),
            max: new Date("2012/02/10")
        });

        const range = dateAxis.translateRange(-400);
        equal(range.min, new Date("2012/01/26"));
        equal(range.max, new Date("2012/02/04"));
    });

    it("translateRange with no categories and min/max", () => {
        createDateCategoryAxis();

        const range = dateAxis.translateRange(-400);
        equal(range, dateAxis.range());
    });

    it("scaleRange with negative delta expands range", () => {
        const range = dateAxis.scaleRange(-2);
        equal(range.min, new Date("2012/01/25 22:04:48"));
        equal(range.max, new Date("2012/02/15 01:55:12"));
    });

    it("scaleRange with positive delta shrinks range", () => {
        const range = dateAxis.scaleRange(2);
        equal(range.min, new Date("2012/01/31 12:28:48"));
        equal(range.max, new Date("2012/02/09 11:31:12"));
    });

    it("scaleRange uses min/max when no categories are defined", () => {
        createDateCategoryAxis({
            min: new Date("2012/02/01"),
            max: new Date("2012/02/10")
        });

        const range = dateAxis.scaleRange(2);
        equal(range.min, new Date("2012/02/02 19:12:00"));
        equal(range.max, new Date("2012/02/09 04:48:00"));
    });

    it("scaleRange with no categories and min/max", () => {
        createDateCategoryAxis();

        const range = dateAxis.scaleRange(-400);
        equal(range, dateAxis.range());
    });
});

(function() {
    let dateAxis, notes;

    function createDateCategoryAxis(options) {
        dateAxis = new DateCategoryAxis(
            deepExtend({
                categories: [new Date("2012/02/01"), new Date("2012/02/10")]
            }, options)
        );

        dateAxis.reflow(chartBox);
        dateAxis.renderVisual();
        notes = dateAxis.notes;
    }

    // ------------------------------------------------------------
    describe('Date Category Axis / Notes', () => {
        it("render note if is in the range of the axis", () => {
            createDateCategoryAxis({
                notes: {
                    data: [{
                        value: "2012/02/01"
                    },{
                        value: "2012/02/11"
                    }]
                }
            });

            ok(notes[0].options.visible);
            ok(notes[1].options.visible);
        });
    });
})();

(function() {    
    const lineSeriesData = [{
        name: "Value A",
        type: "line",
        data: [100, 200, 300]
    }];
    const barSeriesData =  [{
        name: "Value A",
        type: "bar",
        data: [100, 20, 30]
    }];
    let plotArea, plotBands;

    function getPlotBands() {
        return plotArea.axes[0]._plotbandGroup;
    }

    function createPlotArea(series, chartOptions) {
        plotArea = new CategoricalPlotArea(series, deepExtend({
            categoryAxis: {
                categories: [new Date("2012/01/01"), new Date("2012/01/02")],
                plotBands: [{
                    from: new Date("2012/01/01"),
                    to: new Date("2012/01/03"),
                    color: "red"
                }]
            }
        }, chartOptions));

        plotArea.reflow(chartBox);
        plotArea.renderVisual();
        plotBands = getPlotBands().children[0];
    }

    // ------------------------------------------------------------
    describe('Date Axis / Plot Bands / Horizontal', () => {
        beforeEach(() => {
            createPlotArea(lineSeriesData);
        });

        it("renders box", () => {
            sameRectPath(plotBands, [33, 7.5, 799, 577], TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / Plot Bands / Horizontal / Justified', () => {
        beforeEach(() => {
            createPlotArea(lineSeriesData, { categoryAxis: { justified: true } });
        });

        it("renders box", () => {
            sameRectPath(plotBands, [33, 7.5, 788, 577], TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / Plot Bands / Vertical', () => {
        beforeEach(() => {
            createPlotArea(barSeriesData);
        });

        it("renders box", () => {
            sameRectPath(plotBands, [33, 0, 788, 576], TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / Plot Bands / Vertical / Justified', () => {
        beforeEach(() => {
            createPlotArea([{
                name: "Value A",
                type: "verticalLine",
                data: [100, 200, 300]
            }], { categoryAxis: { justified: true } });
        });

        it("renders box", () => {
            sameRectPath(plotBands, [33, 7, 788, 576], TOLERANCE);
        });
    });
})();

(function() {
    const ACTUAL_TICK_SIZE = 5;
    const MARGIN = 5;
    let axisBox, axis;

    function LabelMock(box) {
        this.box = box;
        this.options = {};
        this.reflow = function(box) {
            this.box = box;
        };
    }

    // ------------------------------------------------------------
    describe('Date Axis / Horizontal / reflow', () => {
        beforeEach(() => {
            axis = new DateCategoryAxis({
                categories: [
                    new Date("2012/02/01"), new Date("2012/02/10")
                ],
                vertical: false,
                margin: MARGIN
            });
            axis.labels = [new LabelMock(new Box(0, 0, 20, 20)), new LabelMock(new Box(0, 0, 20, 30))];
            axis.parent = {
                box: new Box(0, 0, 100, 100),
                getRoot: function() {
                    return this;
                }
            };
            axisBox = new Box(0, 0, 50, 50);
            axis.getActualTickSize = function() {
                return ACTUAL_TICK_SIZE;
            };
        });

        it("box height is equal to the maximum label height plus the tick size plus the margin ", () => {
            axis.reflow(axisBox);
            equal(axis.box.height(), 30 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("box height includes title height if title is set", () => {
            axis.title = new LabelMock(new Box(0, 0, 20, 40));
            axis.reflow(axisBox);
            equal(axis.box.height(), 70 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("only labels with height that can be fitted in the container box are taken into account", () => {
            axis.labels.push(new LabelMock(new Box(0, 0, 20, 101 - ACTUAL_TICK_SIZE - MARGIN)));
            axis.reflow(axisBox);
            equal(axis.box.height(), 30 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("only labels with height that can be fitted in the container box including the title are taken into account", () => {
            axis.title = new LabelMock(new Box(0, 0, 20, 40));
            axis.labels.push(new LabelMock(new Box(0, 0, 20, 61 - ACTUAL_TICK_SIZE - MARGIN)));
            axis.reflow(axisBox);
            equal(axis.box.height(), 70 + ACTUAL_TICK_SIZE + MARGIN);
        });
    });

    // ------------------------------------------------------------
    describe('Date Axis / Vertical / reflow', () => {
        beforeEach(() => {
            axis = new DateCategoryAxis({
                categories: [
                    new Date("2012/02/01"), new Date("2012/02/10")
                ],
                vertical: true,
                margin: MARGIN
            });
            axis.labels = [new LabelMock(new Box(0, 0, 20, 20)), new LabelMock(new Box(0, 0, 30, 20))];
            axis.parent = {
                box: new Box(0, 0, 100, 100),
                getRoot: function() {
                    return this;
                }
            };
            axisBox = new Box(0, 0, 50, 50);
            axis.getActualTickSize = function() {
                return ACTUAL_TICK_SIZE;
            };
        });

        it("box width is equal to the maximum label width plus the tick size plus the margin", () => {
            axis.reflow(axisBox);
            equal(axis.box.width(), 30 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("box width includes title width if title is set", () => {
            axis.title = new LabelMock(new Box(0, 0, 40, 20));
            axis.reflow(axisBox);
            equal(axis.box.width(), 70 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("only labels with width that can be fitted in the container box are taken into account", () => {
            axis.labels.push(new LabelMock(new Box(0, 0, 101 - ACTUAL_TICK_SIZE - MARGIN, 20)));
            axis.reflow(axisBox);
            equal(axis.box.width(), 30 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("only labels with width that can be fitted in the container box including the title are taken into account", () => {
            axis.title = new LabelMock(new Box(0, 0, 40, 20));
            axis.labels.push(new LabelMock(new Box(0, 0, 61 - ACTUAL_TICK_SIZE - MARGIN, 20)));
            axis.reflow(axisBox);
            equal(axis.box.width(), 70 + ACTUAL_TICK_SIZE + MARGIN);
        });
    });
})();

