import 'core-js/es6';
import { $ } from 'e2e-utils';
import { drawing as draw } from '@progress/kendo-drawing';

import CategoricalPlotArea from '../../src/chart/plotarea/categorical-plotarea';
import { CategoryAxis as Axis } from '../../src/core';
import { deepExtend, map, last, alignPathToPixel } from '../../src/common';
import { Box, Point } from '../../src/core';

import { ok, equal, close, closeTextPosition, sameRectPath, arrayClose, createSpy, each, sameLinePath, equalTexts } from '../../test/test-helpers';
import { clickChart, createChart, destroyChart, getChartDomElement }  from '../test-helpers';
import '../../test/text-measure';
import '../../test/intl';

const chartBox = new Box(0, 0, 800, 600);
const TOLERANCE = 2;

class CategoryAxis extends Axis {
}

deepExtend(CategoryAxis.prototype.options, {
    options: {
        labels: {
            // Tests expect particular font size
            font: "16px Verdana, sans-serif"
        }
    }
});


const MAX_LABEL_HEIGHT = 17;
const MAJOR_TICK_HEIGHT = 4;
const LINE_Y = chartBox.y1;
const LINE_X = 29;
const MARGIN = 5;
const PADDING = 5;

let categoryAxis, lineBox;

function createCategoryAxis(options) {
    categoryAxis = new CategoryAxis(
        deepExtend({
            categories: ["Foo", "Bar"]
        }, options)
    );
    categoryAxis.reflow(chartBox);
    lineBox = categoryAxis.lineBox();
    categoryAxis.renderVisual();
}

function getBackground() {
     return categoryAxis._backgroundPath;
}

function getLine() {
    return categoryAxis._lineGroup.children[0];
}

function getTicks() {
    return categoryAxis._lineGroup.children.slice(1);
}

function getAxisTextBoxes() {
    return map(categoryAxis.labels, function(item) {
        return item.visual;
    });
}

function getAxisTexts() {
    return map(getAxisTextBoxes(), function(item) {
        return last(item.children);
    });
}

(function() {
    let categories, range;

    function setupAxis(options) {
        createCategoryAxis(deepExtend({
            categories: ["A", "B", "C", "D"]
        }, options));
        categories = categoryAxis.options.categories;
        range = categoryAxis.rangeIndices();
    }

    // ------------------------------------------------------------
    describe('Category Axis / range', () => {

        it("filters categories based on min value", () => {
            setupAxis({
                min: 1
            });

            equal(categories.length, 3);
            equal(categories[0], "B");
            equal(categories[2], "D");
        });

        it("filters categories based on not round min value", () => {
            setupAxis({
                min: 1.5
            });

            equal(categories.length, 3);
            equal(categories[0], "B");
            equal(categories[2], "D");
        });

        it("filters categories based on max value", () => {
            setupAxis({
                max: 2
            });

            equal(categories.length, 2);
            equal(categories[0], "A");
            equal(categories[1], "B");
        });

        it("filters categories based on max value (justified)", () => {
            setupAxis({
                max: 2,
                justified: true
            });

            equal(categories.length, 3);
            equal(categories[0], "A");
            equal(categories[2], "C");
        });

        it("filters categories based on not round max value", () => {
            setupAxis({
                max: 2.5
            });

            equal(categories.length, 3);
            equal(categories[0], "A");
            equal(categories[2], "C");
        });

        it("filters categories based on not round max value (justified)", () => {
            setupAxis({
                max: 2.5,
                justified: true
            });

            equal(categories.length, 3);
            equal(categories[0], "A");
            equal(categories[2], "C");
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / range / indices', () => {

        it("returns user set min value remainder", () => {
            setupAxis({
                min: 2
            });

            equal(range.min, 0);

            setupAxis({
                min: 2.5
            });

            equal(range.min, 0.5);
        });

        it("returns zero for the minimum if no min value is set", () => {
            setupAxis({});

            equal(range.min, 0);
        });

        it("returns the categories length for the max value if no max value is set", () => {
            setupAxis({});

            equal(range.max, 4);
        });

        it("returns the categories length minus one for justified axis if no max value is set", () => {
            setupAxis({
                justified: true
            });

            equal(range.max, 3);
        });

        it("returns user set max value", () => {
            setupAxis({
                max: 3
            });

            equal(range.max, 3);

            setupAxis({
                max: 3.5
            });

            equal(range.max, 3.5);
        });

        it("returns user set max value relative to the min value", () => {
            setupAxis({
                min: 1,
                max: 3
            });

            equal(range.max, 2);

            setupAxis({
                min: 1,
                max: 2.5
            });

            equal(range.max, 1.5);
        });

        it("returns user set max value (justified)", () => {
            setupAxis({
                max: 3,
                justified: true
            });

            equal(range.max, 3);

            setupAxis({
                max: 2.5,
                justified: true
            });

            equal(range.max, 2.5);
        });

        it("returns user set max value relative to the min value (justified)", () => {
            setupAxis({
                min: 1,
                max: 3,
                justified: true
            });

            equal(range.max, 2);

            setupAxis({
                min: 1,
                max: 2.5,
                justified: true
            });

            equal(range.max, 1.5);
        });

        it("returns automatic maximum if user set maximum exceeds the total range", () => {
            setupAxis({
                max: 10
            });

            equal(range.max, 4);
        });

        it("returns automatic maximum if user set maximum exceeds the categories length (justified)", () => {
            setupAxis({
                max: 10,
                justified: true
            });

            equal(range.max, 3);
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / range / total', () => {

        it("returns zero for the minimum", () => {
            setupAxis({});

            const totalRange = categoryAxis.totalRange();

            equal(totalRange.min, 0);
        });

        it("returns the categories length for the maximum", () => {
            setupAxis({});

            const totalRange = categoryAxis.totalRange();

            equal(totalRange.max, 4);
        });

        it("returns the categories length minus one for the maximum (justified)", () => {
            setupAxis({
                justified: true
            });

            const totalRange = categoryAxis.totalRange();

            equal(totalRange.max, 3);
        });

        it("returns zero for the minimum if the axis has been filtered", () => {
            setupAxis({
                min: 2
            });

            const totalRange = categoryAxis.totalRange();

            equal(totalRange.min, 0);
        });

        it("returns the source categories length if the axis has been filtered", () => {
            setupAxis({
                min: 2,
                max: 3
            });

            const totalRange = categoryAxis.totalRange();

            equal(totalRange.max, 4);
        });

        it("returns the source categories length minus one if the axis has been filtered (justified)", () => {
            setupAxis({
                min: 1,
                max: 2,
                justified: true
            });

            const totalRange = categoryAxis.totalRange();

            equal(totalRange.max, 3);
        });

        it("returns the series maximum if bigger than the categories length", () => {
            setupAxis({
                min: 2,
                max: 3
            });

            categoryAxis._seriesMax = 5;

            const totalRange = categoryAxis.totalRange();

            equal(totalRange.max, 5);
        });

        it("returns the categories length if bigger than the series maximum", () => {
            setupAxis({
                min: 2,
                max: 3
            });

            categoryAxis._seriesMax = 3;

            const totalRange = categoryAxis.totalRange();

            equal(totalRange.max, 4);
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / range / total indices', () => {

        it("returns zero for the minimum", () => {
            setupAxis({});

            const totalRange = categoryAxis.totalRangeIndices();

            equal(totalRange.min, 0);
        });

        it("returns user set min value", () => {
            setupAxis({
                min: 2
            });

            const totalRange = categoryAxis.totalRangeIndices();

            equal(totalRange.min, 2);
        });

        it("returns the categories length for the maximum", () => {
            setupAxis({});

            const totalRange = categoryAxis.totalRangeIndices();

            equal(totalRange.max, 4);
        });

        it("returns the categories length minus one for the maximum (justified)", () => {
            setupAxis({
                justified: true
            });

            const totalRange = categoryAxis.totalRangeIndices();

            equal(totalRange.max, 3);
        });

        it("returns user set maximum", () => {
            setupAxis({
                max: 3
            });

            const totalRange = categoryAxis.totalRangeIndices();

            equal(totalRange.max, 3);
        });

        it("does not limit user set maximum", () => {
            setupAxis({
                max: 20
            });

            const totalRange = categoryAxis.totalRangeIndices();

            equal(totalRange.max, 20);
        });

        it("limits user set maximum if true is passed as parameter", () => {
            setupAxis({
                max: 20
            });

            const totalRange = categoryAxis.totalRangeIndices(true);

            equal(totalRange.max, 4);
        });

        it("returns user set minimum plus the categories length if only the minimum value is set", () => {
            setupAxis({
                min: 3
            });

            const totalRange = categoryAxis.totalRangeIndices();

            equal(totalRange.max, 3 + categories.length);
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / valueRange', () => {

        it("returns range", () => {
            setupAxis({});

            const totalRange = categoryAxis.totalRangeIndices();

            equal(categoryAxis.valueRange(), categoryAxis.range());
        });
    });

})();

(function() {
    const TOLERANCE = 0.01;
    let categories, range;

    function setupAxis(options) {
        createCategoryAxis(deepExtend({
            categories: ["A", "B", "C", "D"]
        }, options));
        categories = categoryAxis.options.categories;
    }

    // ------------------------------------------------------------
    describe('Category Axis / pan', () => {

        it("returns translated range",  function() {
            setupAxis({
                min: 1,
                max: 2
            });

            range = categoryAxis.pan(100);
            close(range.min, 1.125, TOLERANCE);
            close(range.max, 2.125, TOLERANCE);

            range = categoryAxis.pan(-100);
            close(range.min, 0.875, TOLERANCE);
            close(range.max, 1.875, TOLERANCE);
        });

        it("returns undefined if range exceeds maximum",  function() {
            setupAxis({
                min: 1
            });

            range = categoryAxis.pan(100);
            ok(!range);
        });

        it("returns undefined if range exceeds minimum",  function() {
            setupAxis({
                max: 1
            });

            range = categoryAxis.pan(-100);
            ok(!range);
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / zoom', () => {

        it("returns scaled range",  function() {
            setupAxis({
                min: 1,
                max: 4
            });

            range = categoryAxis.zoomRange(1);
            equal(range.min, 2);
            equal(range.max, 3);

            setupAxis({
                min: 1,
                max: 2
            });

            range = categoryAxis.zoomRange(-1);
            equal(range.min, 0);
            equal(range.max, 3);
        });

        it("limits range to zero",  function() {
            setupAxis({
                min: 0.5
            });

            range = categoryAxis.zoomRange(-1);
            equal(range.min, 0);
        });

        it("limits range to maximum",  function() {
            setupAxis({
                min: 3.5
            });

            range = categoryAxis.zoomRange(-1);
            equal(range.max, 4);
        });

        it("returns undefined if new range is not bigger than zero",  function() {
            setupAxis({
                min: 1,
                max: 3
            });

            range = categoryAxis.zoomRange(1);
            ok(!range);
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / pointsRange', () => {

        it("returns range based on passed points",  function() {
            setupAxis({});

            range = categoryAxis.pointsRange(new Point(200, 0), new Point(400, 0));
            close(range.min, 1, TOLERANCE);
            close(range.max, 2, TOLERANCE);
        });

        it("returns range based on passed points (reverse)",  function() {
            setupAxis({
                reverse: true
            });

            range = categoryAxis.pointsRange(new Point(200, 0), new Point(400, 0));
            close(range.min, 2, TOLERANCE);
            close(range.max, 3, TOLERANCE);
        });
    });

})();

// ------------------------------------------------------------
describe('Category Axis / Configuration / Labels', () => {

    it("normalizes labels rotation options if object is passed", () => {
        createCategoryAxis({
            labels: {
                rotation: {
                    angle: 30,
                    align: "center"
                }
            }
        });

        equal(categoryAxis.labels[0].options.rotation, 30);
        equal(categoryAxis.labels[0].options.alignRotation, "center");
    });

    it("sets labels rotation to zero if auto is set as value", () => {
        createCategoryAxis({
            labels: {
                rotation: {
                    angle: "auto"
                }
            }
        });

        equal(categoryAxis.labels[0].options.rotation, 0);

        createCategoryAxis({
            labels: {
                rotation: "auto"
            }
        });

        equal(categoryAxis.labels[0].options.rotation, 0);
    });

    it("sets autoRotateLabels option to true if auto is set as rotation value", () => {
        createCategoryAxis({
            labels: {
                rotation: {
                    angle: "auto"
                }
            }
        });

        equal(categoryAxis.options.autoRotateLabels, true);

        createCategoryAxis({
            labels: {
                rotation: "auto"
            }
        });

        equal(categoryAxis.options.autoRotateLabels, true);
    });

    it("labels are not created if _deferLabels option is true", () => {
        categoryAxis = new CategoryAxis({
            labels: {
                visible: true
            },
            categories: ["foo"],
            _deferLabels: true
        });
        ok(!categoryAxis.labels);
    });
});

// ------------------------------------------------------------
describe('Category Axis / Horizontal / Rendering', () => {
    beforeEach(() => {
        createCategoryAxis();
    });

    it("creates axis line", () => {
        const expectedLine = draw.Path.fromPoints([[chartBox.x1, LINE_Y], [chartBox.x2, LINE_Y]]);
        alignPathToPixel(expectedLine);
        sameLinePath(getLine(), expectedLine, TOLERANCE);
    });

    it("creates background box", () => {
        createCategoryAxis({ background: "red" });

        const rect = getBackground();
        const box = draw.Path.fromRect(categoryAxis.box.toRect());

        sameLinePath(rect, box, TOLERANCE);
    });

    it("should not create axis line if visible is false", () => {
        createCategoryAxis({ line: { visible: false } });

        ok(!categoryAxis._lineGroup);
    });

    it("should not render axis if visible is false", () => {
        createCategoryAxis({ visible: false });
        ok(!categoryAxis.visual);
    });

    it("creates labels", 1, () => {
        equalTexts(getAxisTexts(), ["Foo", "Bar"]);
    });

    it("creates labels with full format", 1, () => {
        createCategoryAxis({ categories: [1, 2], labels: { format: "{0:C}"} });
        equalTexts(getAxisTexts(), ["$1.00", "$2.00"]);
    });

    it("creates labels with simple format", 1, () => {
        createCategoryAxis({ categories: [1, 2], labels: { format: "C"} });
        equalTexts(getAxisTexts(), ["$1.00", "$2.00"]);
    });

    it("labels can be hidden", () => {
        createCategoryAxis({
            labels: {
                visible: false
            }
        });

        equal(categoryAxis.labels.length, 0);
    });

    it("labels have set template", 1, () => {
        createCategoryAxis({
            labels: {
                template: "|${ data.value }|"
            }
        });

        equal(getAxisTexts()[0].content(), "|Foo|");
    });

    it("labels have set color", 1, () => {
        createCategoryAxis({
            labels: {
                color: "#f00"
            }
        });

        equal(getAxisTexts()[0].options.fill.color, "#f00");
    });

    it("labels have rotation angle", 1, () => {
        createCategoryAxis({
            labels: {
                rotation: 42.5
            }
        });

        equal(categoryAxis.labels[0].options.rotation, 42.5);
    });

    it("labels have set background", 1, () => {
        createCategoryAxis({
            labels: {
                background: "#f0f"
            }
        });

        equal(getAxisTextBoxes()[0].children[0].options.fill.color, "#f0f");
    });

    it("labels have set zIndex", 1, () => {
        createCategoryAxis({
            zIndex: 2
        });

        equal(getAxisTextBoxes()[0].options.zIndex, 2);
    });

    it("labels are positioned below axis line with margin and padding", 2, () => {
        createCategoryAxis({
            labels: {
                margin: MARGIN,
                padding: PADDING
            }
        });
        closeTextPosition("y", getAxisTexts(), LINE_Y + MAJOR_TICK_HEIGHT + 2 * MARGIN + PADDING, TOLERANCE);
    });

    it("labels are distributed horizontally", () => {
        closeTextPosition("x", getAxisTexts(), [187.5, 586.5], TOLERANCE);
    });

    it("labels are distributed horizontally (justified)", () => {
        createCategoryAxis({ justified: true });
        closeTextPosition("x", getAxisTexts(), [-12, 787], TOLERANCE);
    });

    it("labels are distributed horizontally in reverse", () => {
        createCategoryAxis({ reverse: true });

        closeTextPosition("x", getAxisTexts(), [586.5, 187.5], TOLERANCE);
    });

    it("labels are distributed horizontally in reverse (justified)", () => {
        createCategoryAxis({ justified: true, reverse: true });
        closeTextPosition("x", getAxisTexts(), [787, -12], TOLERANCE);
    });

    it("labels are positioned below axis line", 2, () => {
        closeTextPosition("y", getAxisTexts(), LINE_Y + MAJOR_TICK_HEIGHT + MARGIN, TOLERANCE);
    });

    it("major ticks are distributed horizontally", () => {
        arrayClose(map(getTicks(), function(line) {return line.segments[0].anchor().x;}),
             [0.5, 400.5, 800.5], TOLERANCE);
    });

    it("major ticks are distributed horizontally (justified)", () => {
        createCategoryAxis({ justified: true });
        arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().x; }),
             [0.5, 799.5], TOLERANCE);
    });

    it("major ticks are distributed horizontally in reverse", () => {
        createCategoryAxis({ reverse: true });
        arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().x; }),
             [800, 400, 0], TOLERANCE);
    });

    it("major ticks are distributed horizontally in reverse (justified)", () => {
        createCategoryAxis({ justified: true, reverse: true });
        arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().x; }),
             [799.5, 0.5], TOLERANCE);
    });

    it("major ticks can be disabled", () => {
        createCategoryAxis({ majorTicks: { visible: false }});
        equal(getTicks().length, 0);
    });

    it("minor ticks are distributed horizontally", () => {
        createCategoryAxis({
            majorTicks: { visible: false },
            minorTicks: { visible: true }
        });
        arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().x; }),
             [0, 200, 400, 600, 800], TOLERANCE);
    });

    it("minor ticks are distributed horizontally (justified)", () => {
        createCategoryAxis({
            justified: true,
            majorTicks: { visible: false },
            minorTicks: { visible: true }
        });
        arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().x; }),
             [0.5, 400.5, 799.5], TOLERANCE);
    });

    it("minor ticks are distributed horizontally in reverse", () => {
        createCategoryAxis({
            reverse: true,
            majorTicks: { visible: false },
            minorTicks: { visible: true }
         });
        arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().x; }),
             [800, 600, 400, 200, 0], TOLERANCE);
    });

    it("minor ticks are distributed horizontally in reverse (justified)", () => {
        createCategoryAxis({
            justified: true,
            reverse: true,
            majorTicks: { visible: false },
            minorTicks: { visible: true }
        });

        arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().x; }),
             [799.5, 400.5, 0.5], TOLERANCE);
    });

    it("minor ticks can be disabled", () => {
        createCategoryAxis({
            majorTicks: { visible: false },
        });
        equal(getTicks().length, 0);
    });

    it("line width 0 remove all ticks", () => {
        createCategoryAxis({
            line: {
                width: 0
            }
        });
        ok(!categoryAxis._lineGroup);
    });

    it("major ticks are aligned to axis", 3, () => {
        each(getTicks(), function() {
            equal(this.segments[0].anchor().y, 0.5);
        });
    });

    it("minor ticks are aligned to axis", 5, () => {
        createCategoryAxis({
            majorTicks: { visible: false },
            minorTicks: { visible: true }
        });

        each(getTicks(), function() {
            equal(this.segments[0].anchor().y, 0.5);
        });
    });
});

// ------------------------------------------------------------
describe('Category Axis / Horizontal / Label Step / Rendering', () => {
    beforeEach(() => {
        createCategoryAxis({
            categories: ["Foo", "Bar", "Baz"],
            labels: { step: 2 }
        });
    });

    it("renders every second label", () => {
        equal(map(getAxisTexts(), function(text) { return text.content() }),
             ["Foo", "Baz"]);
    });

    it("labels are distributed horizontally", () => {
        arrayClose(map(getAxisTexts(), function(text) { return text.rect().origin.x }),
             [121.5, 652], TOLERANCE);
    });

    it("zero step doesn't hang", () => {
        createCategoryAxis({
            categories: ["Foo", "Bar", "Baz"],
            labels: { step: 0 }
        });

        ok(true);
    });
});

// ------------------------------------------------------------
describe('Category Axis / Horizontal / Label Step and skip / Rendering', () => {
    beforeEach(() => {
        createCategoryAxis({
            categories: ["Foo", "Bar", "Baz"],
            labels: { step: 2, skip: 2 }
        });
    });

    it("renders every second label, starting from the third", () => {
        equal(map(getAxisTexts(), function(text) { return text.content() }),
             ["Baz"]);
    });

    it("labels are distributed horizontally, starting from the third", () => {
        arrayClose(map(getAxisTexts(), function(text) { return text.rect().origin.x }),
             [652], TOLERANCE);
    });
});

// ------------------------------------------------------------
describe('Category Axis / Horizontal / Mirrored / Rendering', () => {
    beforeEach(() => {
        createCategoryAxis({ labels: { mirror: true } });
    });

    it("labels are aligned bottom", 2, () => {
        each(getAxisTexts(), function() {
            equal(this.rect().origin.y, 0);
        })
    });

    it("major ticks are aligned to axis", 3, () => {
        each(getTicks(), function() {
            equal(this.segments[0].anchor().y, 20.5);
        });
    });

    it("minor ticks are aligned to axis", 5, () => {
        createCategoryAxis({
            labels: { mirror: true },
            majorTicks: { visible: false },
            minorTicks: { visible: true }
        });
        each(getTicks(), function() {
            equal(this.segments[0].anchor().y, 20.5);
        });
    });
});

// ------------------------------------------------------------
describe('Category Axis / Vertical / Rendering', () => {
    beforeEach(() => {
        createCategoryAxis({ vertical: true });
    });

    it("creates axis line", () => {
        const expectedLine = draw.Path.fromPoints([[LINE_X + MARGIN, chartBox.y1], [LINE_X + MARGIN, chartBox.y2]]);
        alignPathToPixel(expectedLine);
        sameLinePath(getLine(), expectedLine, TOLERANCE);
    });

    it("should not create axis line if visible is false", () => {
        createCategoryAxis({ line: { visible: false }, vertical: true });

        ok(!categoryAxis._lineGroup);
    });

    it("should not render axis if visible is false", () => {
        createCategoryAxis({ visible: false, vertical: true });

        ok(!categoryAxis.visual);
    });

    it("creates axis with dash type", () => {
        createCategoryAxis({
            line: {
                dashType: "dot"
            }
        });

        equal(getLine().options.stroke.dashType, "dot");
    });

    it("creates labels", 1, () => {
        equal(map(getAxisTexts(), function(text) { return text.content() }),
             ["Foo", "Bar"]);
    });

    it("labels have rotation angle", 1, () => {
        createCategoryAxis({
            labels: {
                rotation: 42.5
            }
        });

        equal(categoryAxis.labels[0].options.rotation, 42.5);
    });

    it("labels are distributed vertically", () => {
        arrayClose(map(getAxisTexts(), function(text) { return text.rect().origin.y }),
             [141, 441], TOLERANCE);
    });

    it("labels are distributed vertically (justified)", () => {
        createCategoryAxis({ vertical: true, justified: true });

        arrayClose(map(getAxisTexts(), function(text) { return text.rect().origin.y }),
             [-7.5, 591.5], TOLERANCE);
    });

    it("labels are positioned to the left of the axis line", () => {
        equal(map(getAxisTexts(), function(text) { return text.rect().origin.x }),
             [0, 0]);
    });

    it("major ticks are distributed vertically", () => {
        arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().y; }),
             [0, 300, 600], TOLERANCE);
    });

    it("major ticks are distributed vertically (justified)", () => {
        createCategoryAxis({ vertical: true, justified: true });

        arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().y; }),
             [0.5, 599.5], TOLERANCE);
    });

    it("minor ticks are distributed vertically", () => {
        createCategoryAxis({
            majorTicks: { visible: false },
            minorTicks: { visible: true },
            vertical: true
        });

        arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().y; }),
            [0, 150, 300, 450, 600], TOLERANCE);
    });

    it("minor ticks are distributed vertically (justified)", () => {
        createCategoryAxis({
            majorTicks: { visible: false },
            minorTicks: { visible: true },
            vertical: true,
            justified: true
        });

        arrayClose(map(getTicks(), function(line) { return line.segments[0].anchor().y; }),
            [0.5, 300.5, 599.5], TOLERANCE);
    });

    it("line width 0 remove all ticks", () => {
        createCategoryAxis({
            line: {
                width: 0
            }
        });
        ok(!categoryAxis._lineGroup);
    });

    it("labels have set background", 1, () => {
        createCategoryAxis({
            vertical: true,
            labels: {
                background: "#f0f"
            }
        });

        equal(getAxisTextBoxes()[0].children[0].options.fill.color, "#f0f");
    });

    it("labels are positioned to the left of the axis line with margin and padding", () => {
        createCategoryAxis({
            vertical: true,
            labels: {
                margin: MARGIN,
                padding: PADDING
            }
        });

        equal(map(getAxisTexts(), function(text) { return text.rect().origin.x }),
             [0 + MARGIN + PADDING, 0 + MARGIN + PADDING]);
    });

    it("major ticks are aligned to axis", 3, () => {
        each(getTicks(), function() {
            equal(this.segments[0].anchor().x, 29.5);
        });
    });

    it("minor ticks are aligned to axis", 5, () => {
        createCategoryAxis({
            majorTicks: { visible: false },
            minorTicks: { visible: true },
            vertical: true
        });
        each(getTicks(), function() {
            equal(this.segments[0].anchor().x, 29.5);
        });
    });
});

// ------------------------------------------------------------
describe('Category Axis / Vertical / Label Step / Rendering', () => {
    beforeEach(() => {
        createCategoryAxis({
            categories: ["Foo", "Bar", "Baz"],
            labels: { step: 2 },
            vertical: true
        });
    });

    it("renders every second label", () => {
        equal(map(getAxisTexts(), function(text) { return text.content() }),
             ["Foo", "Baz"]);
    });

    it("labels are distributed vertically", () => {
        arrayClose(map(getAxisTexts(), function(text) { return text.rect().origin.y }),
             [91, 491], TOLERANCE);
    });
});

// ------------------------------------------------------------
describe('Category Axis / Vertical / Label Step and skip / Rendering', () => {
    beforeEach(() => {
        createCategoryAxis({
            categories: ["Foo", "Bar", "Baz"],
            labels: { step: 2, skip: 2 },
            vertical: true
        });
    });

    it("renders every second label, starting from the third", () => {
        equal(map(getAxisTexts(), function(text) { return text.content() }),
             ["Baz"]);
    });

    it("labels are distributed vertically, starting from the third", () => {
        arrayClose(map(getAxisTexts(), function(text) { return text.rect().origin.y }),
             [491], TOLERANCE);
    });
});

// ------------------------------------------------------------
describe('Category Axis / Vertical / Mirrored / Rendering', () => {
    beforeEach(() => {
        createCategoryAxis({ labels: { mirror: true }, vertical: true });
    });

    it("labels are aligned left", () => {
        each(getAxisTexts(), function() { equal(this.rect().origin.x, 9); });
    });

    it("major ticks are aligned to axis", 3, () => {
        each(getTicks(), function() {
                equal(this.segments[0].anchor().x, 0.5);
        });
    });

    it("minor ticks are aligned to axis", 5, () => {
        createCategoryAxis({
            majorTicks: { visible: false },
            minorTicks: { visible: true },
            labels: { mirror: true },
            vertical: true
        });

        each(getTicks(), function() {
            equal(this.segments[0].anchor().x, 0.5);
        });
    });
});

(function() {

    let categoryAxis,
        lineBox;

    function createCategoryAxis(options) {
        categoryAxis = new CategoryAxis(
            deepExtend({
                categories: ["Foo", "Bar", "Baz"]
            }, options)
        );
        categoryAxis.reflow(chartBox);
        lineBox = categoryAxis.lineBox();
    }

    // ------------------------------------------------------------
    describe('Category Axis / Horizontal / Slots', () => {
        beforeEach(() => {
            createCategoryAxis();
        });

        it("positions slot for first category", () => {
            const slot = categoryAxis.getSlot(0);
            arrayClose([slot.x1, slot.x2], [lineBox.x1, 266], TOLERANCE);
        });

        it("positions slot for first category (justified)", () => {
            createCategoryAxis({ justified: true });
            const slot = categoryAxis.getSlot(0);
            equal([slot.x1, slot.x2], [lineBox.x1, lineBox.x1]);
        });

        it("positions slot for first category in reverse", () => {
            createCategoryAxis({ reverse: true });
            const slot = categoryAxis.getSlot(0);
            arrayClose([slot.x1, slot.x2], [533, lineBox.x2], TOLERANCE);
        });

        it("positions slot for first category in reverse (justified)", () => {
            createCategoryAxis({ reverse: true, justified: true });
            const slot = categoryAxis.getSlot(0);
            equal([slot.x1, slot.x2], [lineBox.x2, lineBox.x2]);
        });

        it("positions slot for first w/o labels", () => {
            createCategoryAxis({ labels: { visible: false } });
            const slot = categoryAxis.getSlot(0);
            arrayClose([slot.x1, slot.x2], [lineBox.x1, 266], TOLERANCE);
        });

        it("positions slot for second category", () => {
            const slot = categoryAxis.getSlot(1);
            arrayClose([slot.x1, slot.x2], [266, 533], TOLERANCE);
        });

        it("positions slot for second category (justified)", () => {
            createCategoryAxis({ justified: true });
            const slot = categoryAxis.getSlot(1);
            arrayClose([slot.x1, slot.x2], [399, 399], TOLERANCE);
        });

        it("positions slot for second category in reverse", () => {
            createCategoryAxis({ reverse: true });
            const slot = categoryAxis.getSlot(1);
            arrayClose([slot.x1, slot.x2], [266, 533], TOLERANCE);
        });

        it("positions slot for second category in reverse (justified)", () => {
            createCategoryAxis({ reverse: true, justified: true });
            const slot = categoryAxis.getSlot(1);
            arrayClose([slot.x1, slot.x2], [399, 399], TOLERANCE);
        });

        it("positions slot for second category w/o labels", () => {
            createCategoryAxis({ labels: { visible: false } });
            const slot = categoryAxis.getSlot(1);
            arrayClose([slot.x1, slot.x2], [266, 533], TOLERANCE);
        });

        it("positions slot for third category", () => {
            const slot = categoryAxis.getSlot(2);
            arrayClose([slot.x1, slot.x2], [533, lineBox.x2], TOLERANCE);
        });

        it("positions slot for third category (justified)", () => {
            createCategoryAxis({ justified: true });
            const slot = categoryAxis.getSlot(2);
            arrayClose([slot.x1, slot.x2], [lineBox.x2, lineBox.x2], TOLERANCE);
        });

        it("positions slot for third category in reverse", () => {
            createCategoryAxis({ reverse: true });
            const slot = categoryAxis.getSlot(2);
            arrayClose([slot.x1, slot.x2], [lineBox.x1, 266], TOLERANCE);
        });

        it("positions slot for third category in reverse (justified)", () => {
            createCategoryAxis({ reverse: true, justified: true });
            const slot = categoryAxis.getSlot(2);
            arrayClose([slot.x1, slot.x2], [lineBox.x1, lineBox.x1], TOLERANCE);
        });

        it("positions slot for third category w/o labels", () => {
            createCategoryAxis({ labels: { visible: false } });
            const slot = categoryAxis.getSlot(2);
            arrayClose([slot.x1, slot.x2], [533, lineBox.x2], TOLERANCE);
        });

        it("slot height is 0", () => {
            const slot = categoryAxis.getSlot(0);
            equal(slot.height(), 0);
        });

        it("assumes 1 category when no categories are defined", () => {
            categoryAxis = new CategoryAxis();
            categoryAxis.reflow(chartBox);

            const slot = categoryAxis.getSlot(0);
            equal([slot.x1, slot.x2], [lineBox.x1, lineBox.x2]);
        });

        it("reports range minimum of 0", () => {
            equal(categoryAxis.range().min, 0);
        });

        it("reports range maximum equal to category count", () => {
            equal(categoryAxis.range().max, 3);
        });

        it("from value can't be lower than 0 if limited", () => {
            const slot = categoryAxis.getSlot(-1, -1, true);
            equal(slot.x1, 0);
        });

        it("caps from value to categories count if limited", () => {
            const slot = categoryAxis.getSlot(1000, 1000, true);
            equal(slot.x1, lineBox.x2);
        });

        it("to value equals from value when not set (justified)", () => {
            createCategoryAxis({ justified: true });
            const slot = categoryAxis.getSlot(2);
            equal(slot.x2, slot.x1);
        });

        it("to value equals from value when not set (justified)", () => {
            createCategoryAxis({ justified: true });
            const slot = categoryAxis.getSlot(2);
            equal(slot.x2, lineBox.x2);
        });

        it("value equals from value when smaller", () => {
            const slot = categoryAxis.getSlot(2, 1);
            equal(slot.x2, lineBox.x2);
        });

        it("positions last slot at line end (no categories)", () => {
            createCategoryAxis({ categories: []});
            const slot = categoryAxis.getSlot(Number.MAX_VALUE, Number.MAX_VALUE, true);
            arrayClose([slot.x1, slot.x2], [lineBox.x2, lineBox.x2], TOLERANCE);
        });

        it("slot method returns slot as rect", () => {
            const box = categoryAxis.getSlot(0);
            const slot = categoryAxis.slot(0);
            ok(slot.equals(box.toRect()));
        });

        it("slot method returns slot based on category value", () => {
            const box = categoryAxis.getSlot(1);
            const slot = categoryAxis.slot("Bar");
            ok(slot.equals(box.toRect()));
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / Vertical / Slots', () => {
        beforeEach(() => {
            createCategoryAxis({ vertical: true });
        });

        it("positions slot for first category", () => {
            const slot = categoryAxis.getSlot(0);
            arrayClose([slot.y1, slot.y2], [lineBox.y1, 200], TOLERANCE);
        });

        it("positions slot for first category (justified)", () => {
            createCategoryAxis({ vertical: true, justified: true });
            const slot = categoryAxis.getSlot(0);
            equal([slot.y1, slot.y2], [lineBox.y1, lineBox.y1]);
        });

        it("positions slot for first category in reverse", () => {
            createCategoryAxis({ vertical: true, reverse: true });
            const slot = categoryAxis.getSlot(0);
            arrayClose([slot.y1, slot.y2], [399, lineBox.y2], TOLERANCE);
        });

        it("positions slot for first category in reverse (justified)", () => {
            createCategoryAxis({ vertical: true, reverse: true, justified: true });
            const slot = categoryAxis.getSlot(0);
            equal([slot.y1, slot.y2], [lineBox.y2, lineBox.y2]);
        });

        it("positions slot for first w/o labels", () => {
            createCategoryAxis({ vertical: true, labels: { visible: false } });
            const slot = categoryAxis.getSlot(0);
            arrayClose([slot.y1, slot.y2], [lineBox.y1, 200], TOLERANCE);
        });

        it("positions slot for second category", () => {
            const slot = categoryAxis.getSlot(1);
            arrayClose([slot.y1, slot.y2], [200, 399], TOLERANCE);
        });

        it("positions slot for second category (justified)", () => {
            createCategoryAxis({ vertical: true, justified: true });
            const slot = categoryAxis.getSlot(1);
            arrayClose([slot.y1, slot.y2], [300, 300], TOLERANCE);
        });

        it("positions slot for second category in reverse", () => {
            createCategoryAxis({ vertical: true, reverse: true });
            const slot = categoryAxis.getSlot(1);
            arrayClose([slot.y1, slot.y2], [200, 399], TOLERANCE);
        });

        it("positions slot for second category in reverse (justified)", () => {
            createCategoryAxis({ vertical: true, reverse: true, justified: true });
            const slot = categoryAxis.getSlot(1);
            arrayClose([slot.y1, slot.y2], [300, 300], TOLERANCE);
        });

        it("positions slot for second category w/o labels", () => {
            createCategoryAxis({ vertical: true, labels: { visible: false } });
            const slot = categoryAxis.getSlot(1);
            arrayClose([slot.y1, slot.y2], [200, 399], TOLERANCE);
        });

        it("positions slot for third category", () => {
            const slot = categoryAxis.getSlot(2);
            arrayClose([slot.y1, slot.y2], [399, lineBox.y2], TOLERANCE);
        });

        it("positions slot for third category (justified)", () => {
            createCategoryAxis({ vertical: true, justified: true });
            const slot = categoryAxis.getSlot(2);
            arrayClose([slot.y1, slot.y2], [lineBox.y2, lineBox.y2], TOLERANCE);
        });

        it("positions slot for third category in reverse", () => {
            createCategoryAxis({ vertical: true, reverse: true });
            const slot = categoryAxis.getSlot(2);
            arrayClose([slot.y1, slot.y2], [lineBox.y1, 200], TOLERANCE);
        });

        it("positions slot for third category in reverse (justified)", () => {
            createCategoryAxis({ vertical: true, reverse: true, justified: true });
            const slot = categoryAxis.getSlot(2);
            arrayClose([slot.y1, slot.y2], [lineBox.y1, lineBox.y1], TOLERANCE);
        });

        it("positions slot for third category w/o labels", () => {
            createCategoryAxis({ vertical: true, labels: { visible: false } });
            const slot = categoryAxis.getSlot(2);
            arrayClose([slot.y1, slot.y2], [399, lineBox.y2], TOLERANCE);
        });

        it("slot width is 0", () => {
            const slot = categoryAxis.getSlot(0);
            equal(slot.width(), 0);
        });

        it("positions last slot at line end (no categories)", () => {
            createCategoryAxis({ vertical: true, categories: []});
            const slot = categoryAxis.getSlot(Number.MAX_VALUE, Number.MAX_VALUE, true);
            arrayClose([slot.y1, slot.y2], [lineBox.y2, lineBox.y2], TOLERANCE);
        });

        it("slot method returns slot as rect", () => {
            const box = categoryAxis.getSlot(0);
            const slot = categoryAxis.slot(0);
            ok(slot.equals(box.toRect()));
        });
    });

})();

(function() {
    let categoryAxis;

    // ------------------------------------------------------------
    describe('CategoryAxis / getCategory / Horizontal ', () => {
        beforeEach(() => {
            categoryAxis = new CategoryAxis({
                categories: ["Foo", "Bar", "Baz"],
                vertical: false,
                labels: { visible: false }
            });

            categoryAxis.reflow(chartBox);
        });

        it("returns null for coordinates left of axis", () => {
            equal(categoryAxis.getCategory(new Point(-1, 0)), null);
        });

        it("returns null for coordinates right of axis", () => {
            equal(categoryAxis.getCategory(new Point(1000, 0)), null);
        });

        it("returns first category for leftmost point", () => {
            equal(categoryAxis.getCategory(new Point(1, 0)), "Foo");
        });

        it("returns last category for righttmost point", () => {
            equal(categoryAxis.getCategory(new Point(799, 0)), "Baz");
        });

        it("returns category for middle point", () => {
            equal(categoryAxis.getCategory(new Point(334, 0)), "Bar");
        });

        it("returns single category for leftmost point", () => {
            categoryAxis = new CategoryAxis({
                categories: ["Foo"],
                vertical: false,
                labels: { visible: false }
            });

            categoryAxis.reflow(chartBox);
            equal(categoryAxis.getCategory(new Point(1, 0)), "Foo");
        });

        it("returns single category for righttmost point", () => {
            categoryAxis = new CategoryAxis({
                categories: ["Foo"],
                vertical: false,
                labels: { visible: false }
            });

            categoryAxis.reflow(chartBox);
            equal(categoryAxis.getCategory(new Point(799, 0)), "Foo");
        });
    });

    // ------------------------------------------------------------
    describe('CategoryAxis / getCategory / Horizontal / Reverse', () => {
        beforeEach(() => {
            categoryAxis = new CategoryAxis({
                categories: ["Foo", "Bar", "Baz"],
                vertical: false,
                reverse: true,
                labels: { visible: false }
            });

            categoryAxis.reflow(chartBox);
        });

        it("returns first category for righttmost point", () => {
            equal(categoryAxis.getCategory(new Point(799, 0)), "Foo");
        });

        it("returns last category for leftmost point", () => {
            equal(categoryAxis.getCategory(new Point(0, 0)), "Baz");
        });

        it("returns category for middle point", () => {
            equal(categoryAxis.getCategory(new Point(464, 0)), "Bar");
        });
    });

    // ------------------------------------------------------------
    describe('CategoryAxis / getCategory / Vertical ', () => {
        beforeEach(() => {
            categoryAxis = new CategoryAxis({
                categories: ["Foo", "Bar", "Baz"],
                vertical: true,
                labels: { visible: false }
            });

            categoryAxis.reflow(chartBox);
        });

        it("returns null for coordinates above the axis", () => {
            equal(categoryAxis.getCategory(new Point(0, -1)), null);
        });

        it("returns null for coordinates below the axis", () => {
            equal(categoryAxis.getCategory(new Point(0, 1000)), null);
        });

        it("returns first category for bottommost point", () => {
            equal(categoryAxis.getCategory(new Point(0, 599)), "Baz");
        });

        it("returns last category for topmost point", () => {
            equal(categoryAxis.getCategory(new Point(0, 0)), "Foo");
        });

        it("returns category for middle point", () => {
            equal(categoryAxis.getCategory(new Point(0, 350)), "Bar");
        });

        it("returns single category for topmost point", () => {
            categoryAxis = new CategoryAxis({
                categories: ["Foo"],
                vertical: true,
                labels: { visible: false }
            });

            categoryAxis.reflow(chartBox);
            equal(categoryAxis.getCategory(new Point(0, 0)), "Foo");
        });

        it("returns single category for bottommost point", () => {
            categoryAxis = new CategoryAxis({
                categories: ["Foo"],
                vertical: true,
                labels: { visible: false }
            });

            categoryAxis.reflow(chartBox);
            equal(categoryAxis.getCategory(new Point(0, 350)), "Foo");
        });
    });

    // ------------------------------------------------------------
    describe('CategoryAxis / getCategory / Vertical / Reverse', () => {
        beforeEach(() => {
            categoryAxis = new CategoryAxis({
                categories: ["Foo", "Bar", "Baz"],
                vertical: true,
                reverse: true,
                labels: { visible: false }
            });

            categoryAxis.reflow(chartBox);
        });

        it("returns first category for topmost point", () => {
            equal(categoryAxis.getCategory(new Point(0, 0)), "Baz");
        });

        it("returns last category for bottommost point", () => {
            equal(categoryAxis.getCategory(new Point(0, 599)), "Foo");
        });

        it("returns category for middle point", () => {
            equal(categoryAxis.getCategory(new Point(0, 250)), "Bar");
        });
    });

})();

(function() {
    const lineSeriesData = [{
        name: "Value A",
        type: "line",
        data: [100, 200, 300]
    }];
    const barSeriesData =  [{
        name: "Value A",
        type: "bar",
        data: [100, 20, 30]
    }];
    let plotArea, plotBands;

    function getPlotBands() {
        return plotArea.axes[0]._plotbandGroup;
    }

    function createPlotArea(series, chartOptions) {
        plotArea = new CategoricalPlotArea(series, deepExtend({
            categoryAxis: {
                categories: ["A"],
                plotBands: [{
                    from: 0,
                    to: 1,
                    color: "red",
                    opacity: 0.5
                }],
                labels: {
                    // Tests expect particular font size
                    font: "16px Verdana, sans-serif"
                }
            },
            valueAxis: {
                labels: {
                    // Tests expect particular font size
                    font: "16px Verdana, sans-serif"
                }
            }
        }, chartOptions));

        plotArea.reflow(chartBox);
        plotArea.renderVisual();
        plotBands = getPlotBands().children[0];
    }

    // ------------------------------------------------------------
    describe('Category Axis / Plot Bands / Horizontal', () => {
        beforeEach(() => {
            createPlotArea(lineSeriesData);
        });

        it("renders box", () => {
            sameRectPath(plotBands, [33, 9, 288.333, 576], TOLERANCE);
        });

        it("renders color", () => {
            equal(plotBands.options.fill.color, "red");
        });

        it("renders opacity", () => {
            equal(plotBands.options.fill.opacity, 0.5);
        });

        it("renders z index", () => {
            equal(getPlotBands().options.zIndex, -1);
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / Plot Bands / Horizontal / Justified', () => {
        beforeEach(() => {
            createPlotArea(lineSeriesData, { categoryAxis: { justified: true } });
        });

        it("renders box", () => {
            sameRectPath(plotBands, [33, 9, 416, 576], TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / Plot Bands / Vertical', () => {
        beforeEach(() => {
            createPlotArea(barSeriesData);
        });

        it("renders box", () => {
            sameRectPath(plotBands, [17, 0, 788, 191], TOLERANCE);
        });

        it("renders color", () => {
            equal(plotBands.options.fill.color, "red");
        });

        it("renders opacity", () => {
            equal(plotBands.options.fill.opacity, 0.5);
        });

        it("renders z index", () => {
            equal(getPlotBands().options.zIndex, -1);
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / Plot Bands / Vertical / Justified', () => {
        beforeEach(() => {
            createPlotArea([{
                name: "Value A",
                type: "verticalLine",
                data: [100, 200, 300]
            }], { categoryAxis: { justified: true } });
        });

        it("renders box", () => {
            sameRectPath(plotBands, [17, 7.5, 788, 291.75], TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / Plot Bands / Multiple Panes', () => {
        beforeEach(() => {
            createPlotArea(lineSeriesData, {
                categoryAxis: [{
                    pane: "top",
                    categories: ["A", "B", "C"],
                    plotBands: [{
                        from: 0,
                        to: 1
                    }]
                }, {
                    pane: "bottom",
                    categories: ["A", "B", "C"],
                    plotBands: [{
                        from: 0,
                        to: 1
                    }]
                }],
                valueAxis: [{
                    pane: "top"
                }, {
                    pane: "bottom"
                }],
                panes: [{
                    name: "top"
                }, {
                    name: "bottom"
                }]
            });
        });

        it("renders plot band in top pane", () => {
            const topBand = plotArea.axes[0]._plotbandGroup.children[0];
            sameRectPath(topBand, [33, 9, 288, 276], TOLERANCE);
        });

        it("renders plot band in bottom pane", () => {
            const bottomBand = plotArea.axes[1]._plotbandGroup.children[0];
            sameRectPath(bottomBand, [33, 307, 288, 576], TOLERANCE);
        });
    });

})();


(function() {
    const lineSeriesData = [{
        name: "Value A",
        type: "line",
        data: [100]
    }];

    const barSeriesData =  [{
        name: "Value A",
        type: "bar",
        data: [100]
    }];

    let plotArea, textVisual, textboxVisual, textBackgroundVisual, titleBox;

    function createPlotArea(series, plotOptions) {
        plotArea = new CategoricalPlotArea(series, deepExtend({
            categoryAxis: {
                categories: ["A"],
                title: {
                    text: "text",
                    color: "red",
                    opacity: 0.33,
                    font: "16px Verdana, sans-serif",
                    position: "center",
                    background: "green"
                },
                labels: {
                    // Tests expect particular font size
                    font: "16px Verdana, sans-serif"
                }
            },
            valueAxis: {
                labels: {
                    // Tests expect particular font size
                    font: "16px Verdana, sans-serif"
                }
            }
        }, plotOptions));

        plotArea.reflow(chartBox);
        plotArea.renderVisual();

        if (plotArea.axes[0].title) {
            textboxVisual = plotArea.axes[0].title.visual;
            textBackgroundVisual = textboxVisual.children[0];
            textVisual = textboxVisual.children[1];
        }
    }

    // ------------------------------------------------------------
    describe('Category Axis / Title / Horizontal', () => {
        beforeEach(() => {
            createPlotArea(lineSeriesData);
            titleBox = plotArea.axisX.title.box;
        });

        it("positioned at center", () => {
            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 400.5, 585, 432.5, 600 ], TOLERANCE);
        });

        it("positioned left", () => {
            createPlotArea(lineSeriesData, { categoryAxis: { title: { position: "left" }}});
            titleBox = plotArea.axisX.title.box;

            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 34, 585, 65, 600 ], TOLERANCE);
        });

        it("positioned right", () => {
            createPlotArea(lineSeriesData, { categoryAxis: { title: { position: "right" }}});
            titleBox = plotArea.axisX.title.box;

            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 767, 585, 800, 600 ], TOLERANCE);
        });

        it("renders color", () => {
            equal(textVisual.options.fill.color, "red");
        });

        it("renders opacity", () => {
            equal(textBackgroundVisual.options.fill.opacity, 0.33);
        });

        it("renders zIndex", () => {
            equal(textboxVisual.options.zIndex, 1);
        });

        it("hidden when visible is false", () => {
            createPlotArea(lineSeriesData, { categoryAxis: { title: { visible: false }}});
            equal(plotArea.axisX.title, undefined);
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / Horizontal / Mirrored / Title', () => {
        beforeEach(() => {
            createPlotArea(lineSeriesData, { categoryAxis: { labels: { mirror: true } }});
            titleBox = plotArea.axisX.title.box;
        });

        it("positioned at center", () => {
            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 400.5, 553.5, 432.5, 568.5 ], TOLERANCE);
        });

        it("positioned left", () => {
            createPlotArea(lineSeriesData, {
                categoryAxis: { labels: { mirror: true }, title: { position: "left" }}
            });

            titleBox = plotArea.axisX.title.box;

            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 33, 553.5, 65, 568.5 ], TOLERANCE);
        });

        it("positioned right", () => {
            createPlotArea(lineSeriesData, {
                categoryAxis: { labels: { mirror: true }, title: { position: "right" }}
            });

            titleBox = plotArea.axisX.title.box;

            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 767, 553.5, 800, 568.5 ], TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / Title / Vertical', () => {
        beforeEach(() => {
            createPlotArea(barSeriesData);
            titleBox = plotArea.axisY.title.box;
        });

        it("applied position center", () => {
            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 0, 272.5, 15, 303 ], TOLERANCE);
        });

        it("applied position bottom", () => {
            createPlotArea(barSeriesData, { categoryAxis: { title: { position: "bottom" }}});
            titleBox = plotArea.axisY.title.box;

            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 0, 545, 15, 577 ], TOLERANCE);
        });

        it("applied position top", () => {
            createPlotArea(barSeriesData, { categoryAxis: { title: { position: "top" }}});
            titleBox = plotArea.axisY.title.box;

            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 0, 0, 15, 33 ], TOLERANCE);
        });

        it("renders color", () => {
            equal(textVisual.options.fill.color, "red");
        });

        it("renders opacity", () => {
            equal(textBackgroundVisual.options.fill.opacity, 0.33);
        });

        it("renders zIndex", () => {
            equal(textboxVisual.options.zIndex, 1);
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / Vertical / Mirrored / Title', () => {
        beforeEach(() => {
            createPlotArea(barSeriesData, { categoryAxis: { labels: { mirror: true } }});
            titleBox = plotArea.axisY.title.box;
        });

        it("applied position center", () => {
            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 21, 272.5, 36, 303 ], TOLERANCE);
        });

        it("applied position bottom", () => {
            createPlotArea(barSeriesData, {
                categoryAxis: { labels: { mirror: true }, title: { position: "bottom" }}
            });

            titleBox = plotArea.axisY.title.box;

            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 21, 545, 36, 577 ], TOLERANCE);
        });

        it("applied position top", () => {
            createPlotArea(barSeriesData, {
                categoryAxis: { labels: { mirror: true }, title: { position: "top" }}
            });

            titleBox = plotArea.axisY.title.box;

            arrayClose([titleBox.x1, titleBox.y1, titleBox.x2, titleBox.y2],
                 [ 21, 0, 36, 33 ], TOLERANCE);
        });
    });

})();

(function() {
    let chart, label, plotArea;

    function axisLabelClick(clickHandler, options) {
        chart = createChart(deepExtend({            
            series: [{
                type: "line",
                field: "value",
                data: [{
                    value: 1,
                    category: "A"
                }, {
                    value: 2,
                    category: "B"
                }, {
                    value: 3,
                    category: "C"
                }],
                categoryField:"category"
            }],
            categoryAxis: {
                name: "Axis A"                
            },
            axisLabelClick: clickHandler
        }, options));

        plotArea = chart._model.children[1];
        label = plotArea.categoryAxis.labels[1];

        clickChart(chart, getChartDomElement(label));
    }

    // ------------------------------------------------------------
    describe('Category Axis / Events / axisLabelClick', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when clicking axis labels", 1, () => {
            axisLabelClick(function() { ok(true); });
        });

        it("fires when clicking axis labels with children", 2, () => {
            axisLabelClick(function(e) {
                ok(true);
            }, {
                categoryAxis: {
                    labels: {
                        template: "<tspan>Foo</tspan>"
                    }
                }
            });

            clickChart(chart, $(getChartDomElement(label)).children().first()[0]);
        });

        it("event arguments contain axis options", 1, () => {
            axisLabelClick(function(e) {
                equal(e.axis.type, "category");
            });
        });

        it("event arguments contain DOM element", 1, () => {
            axisLabelClick(function(e) {
                ok(e.element);
            });
        });

        it("event arguments contain category index", 1, () => {
            axisLabelClick(function(e) {
                equal(e.index, 1);
            });
        });

        it("category index is correct when step is defined", 1, () => {
            axisLabelClick(function(e) {
                equal(e.index, 2);
            }, {
                categoryAxis: {
                    labels: {
                        step: 2
                    }
                }
            });
        });

        it("event arguments contain category name as text", 1, () => {
            axisLabelClick(function(e) {
                equal(e.text, "B");
            });
        });

        it("event arguments contain category name as value", 1, () => {
            axisLabelClick(function(e) {
                equal(e.value, "B");
            });
        });

        it("event arguments contain category data item", 1, () => {
            axisLabelClick(function(e) {
                equal(e.dataItem.value, 2);
            });
        });
    });

})();

(function() {
    const series = {
        data: [{
            value: 1,
            category: "A"
        }, {
            value: 2,
            category: "B"
        }, {
            value: 3,
            category: "C"
        }],
        categoryField:  "category",
        type: "line",
        field: "value"
    };
    let chart, label, plotArea;

    function createBoundChart(options) {
        chart = createChart(deepExtend({            
            series: [series],
            categoryAxis: {
                name: "Axis A"
            }
        }, options));

        plotArea = chart._model.children[1];
        label = plotArea.categoryAxis.labels[1];
    }

    // ------------------------------------------------------------
    describe('Category Axis / Data Binding', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("categories are data bound", () => {
            createBoundChart();
            equal(plotArea.categoryAxis.labels.length, 3);
        });

        it("template has access to value", () => {
            createBoundChart({
                categoryAxis: {
                    labels: {
                        template: function(data) {
                            ok(typeof data.value == 'string');                      
                        }
                    }
                }
            });
        });

        it("template has access to data item", () => {
            createBoundChart({
                categoryAxis: {
                    labels: {
                        template: function(data) {                            
                            ok(typeof data.dataItem.value == 'number');                      
                        }
                    }
                }
            });
        });

        it("template has access to default format", () => {
            createBoundChart({
                categoryAxis: {
                    labels: {
                        format: 'foo',
                        template: function(data) {                            
                            equal(data.format, "foo");                            
                        }
                    }
                }
            });
        });

        it("template has access to default culture", () => {
            createBoundChart({
                categoryAxis: {
                    labels: {
                        culture: 'foo',
                        template: function(data) {                            
                            equal(data.culture, "foo");                            
                        }
                    }
                }
            });
        });

        it("categories are bound for secondary axis", () => {
            createBoundChart({
                series: [series, deepExtend({}, series, {
                    categoryAxis: "Axis B"
                })],
                categoryAxis: [{
                    name: "Axis A"
                }, {
                    name: "Axis B"
                }]
            });

            equal(plotArea.namedCategoryAxes["Axis B"].labels.length, 3);
        });

        it("categories are bound when using categoryAxes alias", () => {
            createBoundChart({
                series: [series, deepExtend({}, series, {
                    categoryAxis: "Axis B"
                })],
                categoryAxes: [{
                    name: "Axis A"
                }, {
                    name: "Axis B"
                }]
            });

            equal(plotArea.namedCategoryAxes["Axis A"].labels.length, 3);
            equal(plotArea.namedCategoryAxes["Axis B"].labels.length, 3);
        });

        it("visual has access to value", () => {
            createBoundChart({
                categoryAxis: {
                    labels: {
                        visual: function(e) {
                            ok(typeof e.value == 'string');
                        }
                    }
                }
            });
        });

        it("visual has access to data item", () => {
            createBoundChart({
                categoryAxis: {
                    labels: {
                        visual: function(e) {
                            ok(typeof e.dataItem.value == 'number');
                        }
                    }
                }
            });
        });

        it("template has access to default format", () => {
            createBoundChart({
                categoryAxis: {
                    labels: {
                        format: 'foo',
                        visual: function(e) {
                            equal(e.format, 'foo');
                        }
                    }
                }
            });
        });

        it("template has access to default culture", () => {
            createBoundChart({
                categoryAxis: {
                    labels: {
                        culture: 'foo',
                        visual: function(e) {
                            equal(e.culture, 'foo');
                        }
                    }
                }
            });
        });

    });

})();

(function() {

    let categoryAxis, plot;

    function createCategoryAxis(options) {
        categoryAxis = new CategoryAxis(
            deepExtend({
                categories: ["Foo", "Bar", "Baz"]
            }, options)
        );
        categoryAxis.reflow(chartBox);
    }

    // ------------------------------------------------------------
    describe('Category Axis / Notes', () => {

        it("render if is in the range of the axis", () => {
            createCategoryAxis({
                notes: {
                    data: [{
                        value: 1
                    },{
                        value: 4
                    }]
                }
            });

            ok(categoryAxis.notes[0].options.visible);
            ok(!categoryAxis.notes[1].options.visible);
        });

        it("have text", () => {
            createCategoryAxis({
                notes: {
                    data: [{
                        value: 1,
                        label: {
                            text: "Foo"
                        }
                    }]
                }
            });

            equal(categoryAxis.notes[0].text, "Foo");
        });

        it("positions line on pixel", () => {
            createCategoryAxis({
                notes: {
                    data: [{
                        value: 1,
                        icon: {
                            visible: false
                        }
                    }]
                }
            });

            const note = categoryAxis.notes[0];
            note.createVisual();
            equal(note.visual.bbox().origin.x % 1, 0.5);
        });
    });
})();

(function() {
    const ACTUAL_TICK_SIZE = 5;
    const MARGIN = 5;
    let axisBox, axis;

    function LabelMock(box) {
        this.box = box;
        this.options = {};
        this.reflow = function(box) {
            this.box = box;
        };
    }

    // ------------------------------------------------------------
    describe('Category Axis / Horizontal / reflow', () => {
        beforeEach(() => {
            axis = new CategoryAxis({
                categories: ["foo", "bar"],
                vertical: false,
                margin: MARGIN
            });
            axis.parent = {
                box: new Box(0, 0, 100, 100),
                getRoot: function() {
                    return this;
                }
            };
            axisBox = new Box(0, 0, 50, 50);
            axis.labels = [new LabelMock(new Box(0, 0, 20, 20)), new LabelMock(new Box(0, 0, 20, 30))];
            axis.getActualTickSize = function() {
                return ACTUAL_TICK_SIZE;
            };
        });

        it("box height is equal to the maximum label height plus the tick size plus the margin ", () => {
            axis.reflow(axisBox);
            equal(axis.box.height(), 30 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("box height includes title height if title is set", () => {
            axis.title = new LabelMock(new Box(0, 0, 20, 40));
            axis.reflow(axisBox);
            equal(axis.box.height(), 70 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("only labels with height that can be fitted in the container box are taken into account", () => {
            axis.labels.push(new LabelMock(new Box(0, 0, 20, 101 - ACTUAL_TICK_SIZE - MARGIN)));
            axis.reflow(axisBox);
            equal(axis.box.height(), 30 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("only labels with height that can be fitted in the container box including the title are taken into account", () => {
            axis.title = new LabelMock(new Box(0, 0, 20, 40));
            axis.labels.push(new LabelMock(new Box(0, 0, 20, 61 - ACTUAL_TICK_SIZE - MARGIN)));
            axis.reflow(axisBox);
            equal(axis.box.height(), 70 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("sets label rotation origin to top", () => {
            axis.reflow(axisBox);
            equal(axis.labels[0].options.rotationOrigin, "top");
        });

        it("sets label rotation origin to bottom if labels are mirrored", () => {
            axis.options.labels.mirror = true;
            axis.reflow(axisBox);
            equal(axis.labels[0].options.rotationOrigin, "bottom");
        });
    });

    // ------------------------------------------------------------
    describe('Category Axis / Vertical / reflow', () => {
        beforeEach(() => {
            axis = new CategoryAxis({
                categories: ["foo", "bar"],
                vertical: true,
                margin: MARGIN
            });
            axis.parent = {
                box: new Box(0, 0, 100, 100),
                getRoot: function() {
                    return this;
                }
            };
            axisBox = new Box(0, 0, 50, 50);
            axis.labels = [new LabelMock(new Box(0, 0, 20, 20)), new LabelMock(new Box(0, 0, 30, 20))];
            axis.getActualTickSize = function() {
                return ACTUAL_TICK_SIZE;
            };
        });

        it("box width is equal to the maximum label width plus the tick size plus the margin", () => {
            axis.reflow(axisBox);
            equal(axis.box.width(), 30 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("box width includes title width if title is set", () => {
            axis.title = new LabelMock(new Box(0, 0, 40, 20));
            axis.reflow(axisBox);
            equal(axis.box.width(), 70 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("only labels with width that can be fitted in the container box are taken into account", () => {
            axis.labels.push(new LabelMock(new Box(0, 0, 101 - ACTUAL_TICK_SIZE - MARGIN, 20)));
            axis.reflow(axisBox);
            equal(axis.box.width(), 30 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("only labels with width that can be fitted in the container box including the title are taken into account", () => {
            axis.title = new LabelMock(new Box(0, 0, 40, 20));
            axis.labels.push(new LabelMock(new Box(0, 0, 61 - ACTUAL_TICK_SIZE - MARGIN, 20)));
            axis.reflow(axisBox);
            equal(axis.box.width(), 70 + ACTUAL_TICK_SIZE + MARGIN);
        });

        it("sets label rotation origin to right", () => {
            axis.reflow(axisBox);
            equal(axis.labels[0].options.rotationOrigin, "right");
        });

        it("sets label rotation origin to bottom if labels are mirrored", () => {
            axis.options.labels.mirror = true;
            axis.reflow(axisBox);
            equal(axis.labels[0].options.rotationOrigin, "left");
        });
    });

})();

(function() {
    let axisBox, axis;

    function LabelMock(box) {
        this.box = box;
        this.options = {};
        this.reflow = function() {};
    }

    function setupAxis(options) {
        axis = new CategoryAxis(deepExtend({
            categories: ["foo", "bar"],
            vertical: false,
            labels: {
                rotation: "auto"
            }
        }, options));
        axisBox = new Box(0, 0, 50, 50);
        axis.labels = [new LabelMock(new Box(0, 0, 20, 20)), new LabelMock(new Box(0, 0, 30, 20))];
    }

    // ------------------------------------------------------------
    describe('Category Axis / autoRotateLabels', () => {
        beforeEach(() => {
            setupAxis();
        });

        it("rotates labels with -45 degrees if there is a label with width bigger than the slot width", () => {
            axis.reflow(axisBox);
            axis.autoRotateLabels();

            equal(axis.labels[0].options.rotation, -45);
            equal(axis.labels[1].options.rotation, -45);
        });

        it("rotates labels with -90 degrees if there is a label with height bigger than the slot width", () => {
            axis.labels[1].box.y2 = 30;
            axis.reflow(axisBox);
            axis.autoRotateLabels();

            equal(axis.labels[0].options.rotation, -90);
            equal(axis.labels[1].options.rotation, -90);
        });

        it("does not rotate labels with -90 degrees if there is a label with height bigger than the slot width but its width is smaller", () => {
            axis.labels[1].box.x2 = 20;
            axis.labels[1].box.y2 = 30;
            axis.reflow(axisBox);
            axis.autoRotateLabels();

            ok(!axis.labels[0].options.rotation);
            ok(!axis.labels[1].options.rotation);
        });

        it("reflows rotated labels", 2, () => {
            axis.reflow(axisBox);
            axis.labels[0].reflow = axis.labels[1].reflow = function() {
                ok(true);
            };
            axis.autoRotateLabels();
        });

        it("does not rotate labels if there isn't a label with width bigger than the slot width", () => {
            axis.labels[1].box.x1 = 20;
            axis.reflow(axisBox);
            axis.autoRotateLabels();

            ok(!axis.labels[0].options.rotation);
            ok(!axis.labels[1].options.rotation);
        });

        it("does not rotate labels if the axis is vertical", () => {
            axis.options.vertical = true;
            axis.reflow(axisBox);
            axis.autoRotateLabels();

            ok(!axis.labels[0].options.rotation);
            ok(!axis.labels[1].options.rotation);
        });

        it("does not rotate labels if auto rotation is not enabled", () => {
            setupAxis({
                labels: {
                    rotation: 0
                }
            });
            axis.reflow(axisBox);
            axis.autoRotateLabels();

            ok(!axis.labels[0].options.rotation);
            ok(!axis.labels[1].options.rotation);
        });
    });
})();