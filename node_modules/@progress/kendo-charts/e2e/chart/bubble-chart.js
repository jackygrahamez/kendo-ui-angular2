import 'core-js/es6';

import { drawing as draw } from '@progress/kendo-drawing';

import BubbleChart from '../../src/chart/bubble-chart/bubble-chart';

import { RootElement, Box } from '../../src/core';

import { deepExtend, map } from '../../src/common';

import { ok, equal, close } from '../../test/test-helpers';
import { createChart, destroyChart }  from '../test-helpers';
import '../../test/intl';

const chartBox = new Box(0, 0, 800, 600);
const TOLERANCE = 1;
let chart, plotArea, bubbleChart, firstPoint, root;

function setupBubbleChart(plotArea, options) {
    bubbleChart = new BubbleChart(plotArea, options);

    root = new RootElement();
    root.append(bubbleChart);
    root.box = chartBox.clone();
    bubbleChart.reflow(chartBox);
    root.renderVisual();
    firstPoint = bubbleChart.points[0];
}

(function() {
    const TOLERANCE = 1;
    const series = {
        data: [{
            x: 1, y: 10, size: 100, category: "a",
            color: "red"
        }, {
            x: 2, y: 2, size: 1, category: "b"
        }, {
            x: 3, y: 3, size: 20, category: "b"
        }],
        type: "bubble",
        minSize: 10,
        maxSize: 110
    };

    function PlotAreaStub() { }

    deepExtend(PlotAreaStub.prototype, {
        axisX: {
            getSlot: function(categoryIndex) {
                return new Box(0, 0, categoryIndex + 1, 0);
            }
        },
        axisY: {
            getSlot: function(value) {
                return new Box(0, 1, 0, value);
            },
            options: {}
        },
        options: {}
    });

    // ------------------------------------------------------------
    describe('Bubble Chart / Points', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupBubbleChart(plotArea, { series: [ series ] });
        });

        it("Points are not created for bubbles with negative size ", () => {
            setupBubbleChart(plotArea, { series: [{
                    data: [{x: 1, y: 1, size: -100}],
                    negativeValues: { visible: false },
                    type: "bubble"
                }]
            });

            equal(bubbleChart.points.length, 1);
            equal(bubbleChart.points[0], null);
        });

        it("Points are not created for bubbles with zero size", () => {
            setupBubbleChart(plotArea, { series: [{
                    data: [{x: 1, y: 1, size: 0}],
                    type: "bubble"
                }]
            });

            equal(bubbleChart.points.length, 1);
            equal(bubbleChart.points[0], null);
        });

        it("Maximum bubble diameter is set to maxSize", () => {
            close(firstPoint.options.markers.size, 110, TOLERANCE);
        });

        it("Bubble diameter of bubbles with size close to zero are close to the minSize", () => {
            setupBubbleChart(plotArea, { series: [{
                    data: [{x: 1, y: 1, size: 0.1}, {x: 1, y: 1, size: 100}],
                    type: "bubble",
                    minSize: 10
                }]
            });
            close(bubbleChart.points[0].options.markers.size, 10, TOLERANCE);
        });

        it("Bubble diameter is equal to the max size if there is a single bubble", () => {
            setupBubbleChart(plotArea, { series: [{
                    data: [{x: 1, y: 1, size: 10}],
                    type: "bubble",
                    maxSize: 100
                }]
            });

            close(bubbleChart.points[0].options.markers.size, 100, TOLERANCE);
        });

        it("Bubble diameters are equal to the max size if all bubbles have the same size", () => {
            setupBubbleChart(plotArea, { series: [{
                    data: [{x: 1, y: 1, size: 10}, {x: 1, y: 1, size: 10}],
                    type: "bubble",
                    maxSize: 100
                }]
            });

            close(bubbleChart.points[1].options.markers.size, 100, TOLERANCE);
        });

        it("Default maximum bubble diameter is proportional to box size", () => {
            setupBubbleChart(plotArea, { series: [{
                    data: [{x: 1, y: 1, size: 10}, {x: 1, y: 1, size: 100}],
                    type: "bubble"
                }]
            });

            close(bubbleChart.points[1].options.markers.size, 120, TOLERANCE);
        });

        it("Default minimum bubble diameter is proportional to box size", () => {
            setupBubbleChart(plotArea, { series: [{
                    data: [{x: 1, y: 1, size: 10}, {x: 1, y: 1, size: 100}],
                    type: "bubble"
                }]
            });

            close(firstPoint.options.markers.size, 40, TOLERANCE);
        });

        it("Default minimum bubble diameter is floored to 10", () => {
            setupBubbleChart(plotArea, { series: [{
                    data: [{x: 1, y: 1, size: 10}, {x: 1, y: 1, size: 100}],
                    type: "bubble"
                }]
            });

            bubbleChart.reflow(new Box());
            close(firstPoint.options.markers.size, 10, TOLERANCE);
        });

        it("Bubble diameter is proportional to size value", () => {
            close(bubbleChart.points[2].options.markers.size, 50, TOLERANCE);
        });

        it("zIndex is higher for smaller bubbles", () => {
            ok(bubbleChart.points[1].options.markers.zIndex >
               firstPoint.options.markers.zIndex);
        });

        it("Color is set for bubbles with negative size", () => {
            setupBubbleChart(plotArea, { series: [{
                    data: [{x: 1, y: 1, size: -100}],
                    negativeValues: { visible: true, color: "red" },
                    type: "bubble"
                }]
            });

            equal(firstPoint.color, "red");
        });

        it("Color field is set", () => {
            equal(firstPoint.color, "red");
        });

        it("Color is copied to marker background", () => {
            equal(firstPoint.options.markers.background, "red");
        });

        it("format variable {0} returns x", () => {
            equal(firstPoint.formatValue("{0}"), "1");
        });

        it("format variable {1} returns y", () => {
            equal(firstPoint.formatValue("{1}"), "10");
        });

        it("format variable {2} returns size", () => {
            equal(firstPoint.formatValue("{2}"), "100");
        });

        it("format variable {3} returns category", () => {
            equal(firstPoint.formatValue("{3}"), "a");
        });
    });

    // ------------------------------------------------------------
    describe('Bubble Chart / Points / Rendering', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupBubbleChart(plotArea, { series: [ series ] });
        });

        it("createHighlight creates a circle", () => {
            equal(firstPoint.createHighlight().nodeType, "Circle");
        });
    });

    // ------------------------------------------------------------
    describe('Bubble Chart / Points / Highlight', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupBubbleChart(plotArea, { series: [ series ] });
        });

        it("createHighlight renders fill based on marker background", () => {
            const highlight = firstPoint.createHighlight();
            equal(highlight.options.fill.color, firstPoint.options.markers.background);
        });

        it("createHighlight creates a circle with 1 border smaller diameter", () => {
            firstPoint.options.highlight.border.width = 2;
            const outline = firstPoint.createHighlight();

            equal(outline.geometry().getRadius(), firstPoint.options.markers.size / 2 - 1);
        });

        it("createHighlight renders default border width", () => {
            const outline = firstPoint.createHighlight();

            equal(outline.options.stroke.width, 1);
        });

        it("createHighlight renders custom border width", () => {
            firstPoint.options.highlight.border.width = 2;
            const outline = firstPoint.createHighlight();

            equal(outline.options.stroke.width, 2);
        });

        it("createHighlight renders default border color (computed)", () => {
            firstPoint.options.markers.background = "#ffffff";
            const outline = firstPoint.createHighlight();

            equal(outline.options.stroke.color, "#cccccc");
        });

        it("createHighlight renders custom border color", () => {
            firstPoint.options.highlight.border.color = "red";
            const outline = firstPoint.createHighlight();

            equal(outline.options.stroke.color, "red");
        });

        it("createHighlight renders default border opacity", () => {
            const outline = firstPoint.createHighlight();

            equal(outline.options.stroke.opacity, 1);
        });

        it("createHighlight renders custom border opacity", () => {
            firstPoint.options.highlight.border.opacity = 0.5;
            const outline = firstPoint.createHighlight();

            equal(outline.options.stroke.opacity, 0.5);
        });

        it("highlightVisual returns marker visual", () => {
            const visual = firstPoint.highlightVisual();
            ok(visual instanceof draw.Circle);
            ok(visual === firstPoint.marker.visual);
        });
    });

})();

(function() {
    const data = [{
        xValue: 1,
        yValue: 10,
        sizeValue: 100,
        pointColor: "red"
    }, {
        xValue: 2,
        yValue: 20,
        sizeValue: 200,
        pointColor: "blue"
    }];
    let points;

    function createBubbleChart(bubbleSeries) {
        chart = createChart({
            series: [deepExtend({
                type: "bubble",
                data: data
            }, bubbleSeries)]
        });

        points = chart._plotArea.charts[0].points;
    }

    // ------------------------------------------------------------
    describe('Bubble Chart / Data Binding', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("binds to 3-element array", () => {
            createBubbleChart({
                data: [[1, 10, 100], [2, 20, 200]]
            });

            equal(points[1].value, { x: 2, y: 20, size: 200 });
        });

        it("binds x, y and size field", () => {
            createBubbleChart({
                xField: "xValue",
                yField: "yValue",
                sizeField: "sizeValue"
            });

            equal(points[1].value, { x: 2, y: 20, size: 200 });
        });

        it("binds color field", () => {
            createBubbleChart({
                xField: "xValue",
                yField: "yValue",
                sizeField: "sizeValue",
                colorField: "pointColor"
            });

            equal(points[1].color, "blue");
        });

        it("binds category field", () => {
            createBubbleChart({
                xField: "xValue",
                yField: "yValue",
                sizeField: "sizeValue",
                categoryField: "pointColor"
            });

            equal(points[1].category, "blue");
        });

        it("binds to object with x, y and size fields", () => {
            createBubbleChart({
                data: [{x: 1, y: 10, size: 100}, {x: 2, y: 20, size: 200}]
            });

            equal(points[1].value, { x: 2, y: 20, size: 200 });
        });

        it("binds color to object field", () => {
            createBubbleChart({
                data: [{ x: 1, y: 10, size: 100, color: "red" }]
            });

            equal(points[0].color, "red");
        });

        it("binds category to object field", () => {
            createBubbleChart({
                data: [{ x: 1, y: 10, size: 100, category: "UK" }]
            });

            equal(points[0].category, "UK");
        });
    });

})();

(function() {
    const data = [{
        xValue: 1,
        yValue: 10,
        sizeValue: 100
    }, {
        xValue: 2,
        yValue: 20,
        sizeValue: 200
    }];
    let points, bubbleChart, legend;

    function createBubbleChart(options) {
        chart = createChart(
            deepExtend({}, {                
                series: [{
                    data: data,
                    type: "bubble",
                    xField: "xValue",
                    yField: "yValue",
                    sizeField: "sizeValue",
                    name: "A",
                    test: "test"
                }]
            }, options)
        );

        points = chart._plotArea.charts[0].points;
        bubbleChart = chart._plotArea.charts[0];
        legend = chart._model.children[0];
    }

    // ------------------------------------------------------------
    describe('Bubble Chart / Configuration', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("tooltip options are applied to points", () => {
            createBubbleChart({
                tooltip: {
                    format: "a"
                }
            });

            equal(points[0].options.tooltip.format, "a");
        });

        it("sets legend item name from dataItem", () => {
            createBubbleChart({
                legend: {
                    labels: {
                        template: "#= text #-#= series.test #"
                    }
                }
            });

            equal(legend.options.items[0].text, "A-test");
        });

        it("applies color function", () => {
            createBubbleChart({
                dataSource: null,
                series: [{
                    type: "bubble",
                    data: [[1, 10, 100]],
                    color: function(bubble) { return "#f00" }
                }]
            });

            equal(points[0].options.color, "#f00");
        });

        it("applies color function for each point", 1, () => {
            createBubbleChart({
                dataSource: null,
                series: [{
                    type: "bubble",
                    data: [[1, 10, 100]],
                    color: function() { ok(true); }
                }]
            });
        });

        it("color fn argument contains value", 1, () => {
            createBubbleChart({
                dataSource: null,
                series: [{
                    type: "bubble",
                    data: [[1, 10, 100]],
                    color: function(bubble) { equal(bubble.value.size, 100); }
                }]
            });
        });

        it("color fn argument contains dataItem", 1, () => {
            createBubbleChart({
                dataSource: null,
                series: [{
                    type: "bubble",
                    data: [[1, 10, 100]],
                    color: function(bubble) {
                        equal(bubble.dataItem, [1, 10, 100]);
                    }
                }]
            });
        });

        it("color fn argument contains series", 1, () => {
            createBubbleChart({
                dataSource: null,
                series: [{
                    type: "bubble",
                    name: "series 1",
                    data: [[1, 10, 100]],
                    color: function(bubble) { equal(bubble.series.name, "series 1"); }
                }]
            });
        });

        it("evaluated color is set on point", () => {
            createBubbleChart({
                dataSource: null,
                series: [{
                    type: "bubble",
                    name: "series 1",
                    data: [[1, 10, 100]],
                    color: function() { return "red"; }
                }]
            });

            equal(points[0].color, "red");
        });

        it("Points for negative size values are not created by default", () => {
            createBubbleChart({
                series: [{
                    type: "bubble",
                    name: "series 1",
                    data: [[1, 10, -100]]
                }]
            });

            equal(points.length, 1);
            equal(points[0], null);
        });

        it("color function should be with bigger priority negative values color", () => {
            createBubbleChart({
                series: [{
                    type: "bubble",
                    name: "series 1",
                    data: [[1, 10, -100]],
                    color: function() { return "red" },
                    negativeValues: {
                        color: "blue",
                        visible: true
                    }
                }]
            });

            equal(points[0].color, "red");
        });

        it("Points for null size values are not created", () => {
            createBubbleChart({
                series: [{
                    type: "bubble",
                    name: "series 1",
                    data: [[1, 10, null]]
                }]
            });

            equal(points.length, 1);
            equal(points[0], null);
        });
    });

})();

(function() {
    let note;

    describe('Bubble Chart / Note', () => {
        beforeEach(() => {
            chart = createChart({
                series: [{
                    name: "Value",
                    type: "bubble",
                    data: [{ x: 1, y: 10, size: 100, noteText: "A" }]
                }]
            });

            note = chart._plotArea.charts[0].points[0].note;
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("should have text", () => {
            equal(note.text, "A");
        });
    });

    describe('Bubble Chart / Note Template', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        function createNote(options) {
            chart = createChart({
                series: [{
                    name: "Value",
                    type: "bubble",
                    data: [{ x: 1, y: 10, size: 100, noteText: "A", test: "test" }],
                    notes: deepExtend({}, options),
                    name: "name"
                }]
            });

            note = chart._plotArea.charts[0].points[0].note;
        }

        it("dataItem", () => {
            createNote({
                label: {
                    template: "#= dataItem.test #"
                }
            });

            equal(note.label.content, "test");
        });

        it("value", () => {
            createNote({
                label: {
                    template: "x: #= value.x # y: #= value.y # size: #= value.size #"
                }
            });

            equal(note.label.content, "x: 1 y: 10 size: 100");
        });

        it("series", () => {
            createNote({
                label: {
                    template: "#= series.name #"
                }
            });

            equal(note.label.content, "name");
        });
    });
})();

// ------------------------------------------------------------

(function() {

    describe('Bubble Chart / Values exceeding axis min or max options ', () => {

        it("values are not limited", 2, () => {
            const plotArea = {
                axisX: {
                    getSlot: function(a,b,limit) {
                        ok(!limit);
                        return new Box();
                    }
                },
                axisY: {
                    getSlot: function(a,b, limit) {
                        ok(!limit);
                        return new Box();
                    }
                },
                options: {}
            };

            setupBubbleChart(plotArea, { series: [ {data: [{x: 1, y: 1, size: 100}], type: "bubble"} ] });
        });
    });
})();

// ------------------------------------------------------------
(function() {
    describe('Bubble Chart / Multiple series', () => {
        beforeEach(() => {
            setupBubbleChart(plotArea, {
                series: [{
                    data: [{x: 1, y: 1, size: 10}, {x: 1, y: 1, size: 100}],
                    type: "bubble"
                }, {
                    data: [{x: 1, y: 1, size: 100}, {x: 1, y: 1, size: 1000}],
                    type: "bubble"
                }]
            });
        });

        it("Scale is shared across series", () => {
            const sizes = map(bubbleChart.points, function(p) {
                return p.options.markers.size;
            });

            ok(sizes[0] < sizes[1]);
        });
    })
})();
