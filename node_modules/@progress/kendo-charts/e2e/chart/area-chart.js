import 'core-js/es6';
import AreaChart from '../../src/chart/area-chart/area-chart';
import categoriesCount from '../../src/chart/utils/categories-count';
import { RootElement, Box } from '../../src/core';
import { deepExtend } from '../../src/common';
import baseLineChartTests from './base-line-chart';

import { ok, equal, createSpy, mapSegments } from '../../test/test-helpers';
import { clickChart, triggerEvent, createChart, destroyChart, getChartDomElement }  from '../test-helpers';

const chartBox = new Box(0, 0, 800, 600);
const TOLERANCE = 1;
let areaChart, chart, root, pointCoordinates;

function segmentPaths() {
    return areaChart._segments[0].visual.children;
}

function getAreaPath(areaChart) {
    return segmentPaths()[0];
}

function getLinePath(areaChart) {
    return segmentPaths()[1];
}

function setupAreaChart(plotArea, options) {
    areaChart = new AreaChart(plotArea, options);

    root = new RootElement();
    root.append(areaChart);
    root.reflow();

    root.renderVisual();
    pointCoordinates = mapSegments(getAreaPath(areaChart).segments);
}

function stubPlotArea(getCategorySlot, getValueSlot, options) {
    return new function() {
        this.categoryAxis = this.primaryCategoryAxis = {
            getSlot: getCategorySlot,
            lineBox: function() {
                return new Box(0,2,2,2);
            },
            options: {
                categories: ["A", "B"]
            }
        };

        this.valueAxis = {
            getSlot: getValueSlot,
            lineBox: function() {
                return new Box(0,0,0,2);
            },
            options: {},
            startValue: function() {
                return 0;
            }
        };

        this.namedCategoryAxes = {};
        this.namedValueAxes = {};

        this.seriesCategoryAxis = function(series) {
            return series.categoryAxis ?
                this.namedCategoryAxes[series.categoryAxis] : this.primaryCategoryAxis;
        };

        this.options = options;
    };
}

baseLineChartTests("area", AreaChart);
const positiveSeries = { data: [1, 2], labels: {} };
const negativeSeries = { data: [-1, -2], labels: {} };
const sparseSeries = { data: [1, 2, undefined, 2] };
const VALUE_AXIS_MAX = 2;
const CATEGORY_AXIS_Y = 2;

const plotArea = stubPlotArea(
    function(categoryIndex) {
        return new Box(categoryIndex, CATEGORY_AXIS_Y,
                         categoryIndex + 1, CATEGORY_AXIS_Y);
    },
    function(value = 0) {
        const valueY = VALUE_AXIS_MAX - value;
        const slotTop = Math.min(CATEGORY_AXIS_Y, valueY);
        const slotBottom = Math.max(CATEGORY_AXIS_Y, valueY);

        return new Box(0, slotTop, 0, slotBottom);
    }
);
(function() {
    // ------------------------------------------------------------
    describe('Area Chart / Positive Values', () => {
        beforeEach(() => {
            setupAreaChart(plotArea, { series: [ positiveSeries ] });
        });

        it("segments are clipped to category axis", () => {
            setupAreaChart(plotArea, { series: [ positiveSeries ]});

            equal(areaChart._segments[0].points()[0].y, CATEGORY_AXIS_Y);
        });

        it("segments are clipped to secondary category axis", () => {
            plotArea.namedCategoryAxes["secondary"] = {
                getSlot: function(categoryIndex) {
                    return new Box(categoryIndex, 0, categoryIndex + 1, 0);
                },
                lineBox: function() {
                    ok(true)
                    return new Box(0,0,2,0);
                },
                options: {
                    categories: ["A", "B"]
                }
            };

            setupAreaChart(plotArea, { series: [{
                categoryAxis: "secondary",
                data: [1, 2],
                labels: {}
            }]});

            equal(areaChart._segments[0].points()[0].y, 0);
        });
    });

    // ------------------------------------------------------------
    describe('Area Chart / Values exceeding value axis min or max options ', () => {

        it("values are not limited", () => {
            const plotArea = stubPlotArea(
                function(categoryIndex) {
                    return new Box(categoryIndex, CATEGORY_AXIS_Y,
                                     categoryIndex + 1, CATEGORY_AXIS_Y);
                },
                function(value, axisCrossingValue, limit) {
                    ok(!limit);
                    return new Box();
                }
            );
            createSpy(plotArea.valueAxis, "getSlot");
            setupAreaChart(plotArea, { series: [ {data: [1, 2]} ] });
            expect(plotArea.valueAxis.getSlot).toHaveBeenCalledTimes(2);
        });
    });

    // ------------------------------------------------------------
    describe('Area Chart / Multiple Series', () => {
        beforeEach(() => {
            plotArea.namedValueAxes.secondary = plotArea.valueAxis;

            setupAreaChart(plotArea, {
                series: [
                deepExtend({ }, positiveSeries),
                deepExtend({ axis: "secondary" }, negativeSeries  )
            ] });
        });

        it("Reports minimum series value for primary axis", () => {
            equal(areaChart.valueAxisRanges[undefined].min, positiveSeries.data[0]);
        });

        it("Reports maximum series value for primary axis", () => {
            equal(areaChart.valueAxisRanges[undefined].max, positiveSeries.data[1]);
        });

        it("Reports minimum series value for secondary axis", () => {
            equal(areaChart.valueAxisRanges.secondary.min, negativeSeries.data[1]);
        });

        it("Reports maximum series value for secondary axis", () => {
            equal(areaChart.valueAxisRanges.secondary.max, negativeSeries.data[0]);
        });

        it("Reports number of categories for two series", () => {
            setupAreaChart(plotArea, {series: [ positiveSeries, negativeSeries ]});
            equal(categoriesCount(areaChart.options.series), positiveSeries.data.length);
        });

        it("getNearestPoint returns nearest series point", () => {
            const point = areaChart.points[3],
                result = areaChart.getNearestPoint(point.box.x2, point.box.y2 + 100, 1);

            ok(result === point);
        });
    });

    // ------------------------------------------------------------
    describe('Area Chart / Mismatched series', () => {
        beforeEach(() => {
            setupAreaChart(plotArea, {
            series: [ { data: [1, 2, 3] },
                      positiveSeries
                ]
            });
        });

        it("getNearestPoint returns nearest series point", () => {
            const point = areaChart.points[5],
                result = areaChart.getNearestPoint(point.box.x2, point.box.y2 + 10, 1);

            ok(result === point);
        });
    });

    // ------------------------------------------------------------
    describe('Area Chart / Missing values', () => {
        beforeEach(() => {
            setupAreaChart(plotArea, {
                series: [ sparseSeries ]
            });
        });

        it("missing points are assumed to be 0 by default", () => {
            equal(areaChart.points[2].value, 0);
        });

        it("omits missing points", () => {
            setupAreaChart(plotArea, {
                series: [
                    deepExtend({ missingValues: "gap" }, sparseSeries)
                ]
            });

            equal(areaChart.points[2], null);
        });

        it("getNearestPoint returns nearest series point (left)", () => {
            setupAreaChart(plotArea, {
                series: [
                    deepExtend({ missingValues: "gap" }, sparseSeries)
                ]
            });

            const point = areaChart.points[1],
                result = areaChart.getNearestPoint(point.box.x2 + 0.1, point.box.y2, 0);

            ok(result === point);
        });

        it("getNearestPoint returns nearest series point (right)", () => {
            setupAreaChart(plotArea, {
                series: [
                    deepExtend({ missingValues: "gap" }, sparseSeries)
                ]
            });

            const point = areaChart.points[3],
                result = areaChart.getNearestPoint(point.box.x1 - 0.1, point.box.y1, 0);

            ok(result === point);
        });
    });

    // ------------------------------------------------------------
    describe('Area Chart / Panes', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("area fill is clipped to value axis box", () => {
            chart = createChart({
                series: [{
                    type: "area",
                    data: [1, 2, 3]
                }],
                panes: [{
                    name: "top"
                }, {
                    name: "bottom"
                }],
                valueAxis: [{
                }],
                categoryAxis: {
                    pane: "bottom",
                    categories: ["A"]
                }
            });

            const plotArea = chart._model._plotArea;
            const areaChart = plotArea.charts[0];
            equal(areaChart._segments[0].points()[0].y, plotArea.panes[0].axes[0].lineBox().y2);
        });
    });

    // ------------------------------------------------------------
    describe('Area Chart / Stack / Missing values', () => {
        beforeEach(() => {
            sparseSeries.line = { width: 0 };
        });
        afterEach(() => {
            sparseSeries.line = null;
        });

        it("line is drawn between existing points when interpolating", () => {
            setupAreaChart(plotArea, {
                series: [
                    deepExtend({ missingValues: "interpolate" }, sparseSeries)
                ],
                isStacked: true
            });

            equal(pointCoordinates, [
                [ 0.5, 2 ], [ 0.5, 1 ], [ 1.5, 0 ], [ 3.5, 0 ], [ 3.5, 2 ]
            ]);
        });

        it("renders stacked sparse series with interpolation", () => {
            setupAreaChart(plotArea, {
                series: [
                    deepExtend({ missingValues: "interpolate" }, sparseSeries),
                    sparseSeries
                ],
                isStacked: true
            });

            equal(areaChart.points.length, 8);
        });
    });

    // ------------------------------------------------------------
    describe('Area Chart / Stack / Missing values / gap', () => {
        let segments;

        beforeEach(() => {
            setupAreaChart(plotArea, {
                series: [{
                    data: [null, 1, 1, null, null, 1, 1, 1],
                    missingValues: "gap"
                }, {
                    data: [1, 1, 1, null, 1, 1, 1, null],
                    missingValues: "gap"
                }, {
                    data: [1, 1, 1, 1, 1, 1, 1, 1],
                    missingValues: "gap"
                }],
                isStacked: true
            });
            segments = areaChart._segments;
        });

        it("uses previous series point for the stack points", () => {
            ok(segments[4].stackPoints[10] === segments[2].linePoints[0]);
        });

        it("uses fake line point for the stack points if the previous series point is missing", () => {
            equal(segments[2].stackPoints[3].value, 0);
            equal(segments[2].stackPoints[3].categoryIx, 0);
        });

        it("fake gap stack points are reflowed", () => {
            ok(segments[2].stackPoints[3].box);
        });

        it("uses a fake line point and the previous series point for the stack points if previous series previous category point is missing", () => {
            equal(segments[2].stackPoints[2].value, 0);
            equal(segments[2].stackPoints[2].categoryIx, 1);
            ok(segments[2].stackPoints[1] === segments[0].linePoints[0]);
        });

        it("uses the previous series point and the point from the first series with next category point if previous series next category point is missing", () => {
            equal(segments[2].stackPoints[2].value, 0);
            equal(segments[2].stackPoints[2].categoryIx, 1);
            ok(segments[2].stackPoints[1] === segments[0].linePoints[0]);
        });

        it("does not use a fake line point if previous series next category point is missing but the point is the last in the segment", () => {
            ok(segments[2].stackPoints[0] === segments[0].linePoints[1]);
            equal(segments[2].stackPoints.length, 4);
        });

        it("uses a fake line point and the previous series point for the stack points if multiple previous series category next points are missing", () => {
            equal(segments[4].stackPoints[7].value, 0);
            equal(segments[4].stackPoints[7].categoryIx, 2);
            ok(segments[4].stackPoints[8] === segments[2].linePoints[2]);
        });
    });

    // ------------------------------------------------------------
    describe('Area Chart / Stack 100% / Missing values', () => {

        it("renders stacked sparse series with interpolation", () => {
            setupAreaChart(plotArea, {
                series: [
                    deepExtend({ missingValues: "interpolate" }, sparseSeries),
                    sparseSeries
                ],
                isStacked: true,
                isStacked100: true
            });

            equal(areaChart.points.length, 8);
        });
    });

    // ------------------------------------------------------------
    describe('Area Chart / Rendering', () => {
        let linePath, areaPath;

        beforeEach(() => {
            setupAreaChart(plotArea, {
                series: [
                    deepExtend({
                            line: {
                                width: 2,
                                color: "lineColor",
                                opacity: 0.5,
                                dashType: "dot"
                            },
                            color: "areaColor",
                            opacity: 0.1
                        },
                        positiveSeries
                    )
                ]
            });

            linePath = getLinePath(areaChart);
            areaPath = getAreaPath(areaChart);
        });

        it("sets area line width", () => {
            equal(linePath.options.stroke.width, 2);
        });

        it("sets area line color", () => {
            equal(linePath.options.stroke.color, "lineColor");
        });

        it("sets area line opacity", () => {
            equal(linePath.options.stroke.opacity, 0.5);
        });

        it("sets area line dashType", () => {
            equal(linePath.options.stroke.dashType, "dot");
        });

        it("sets area fill color", () => {
            equal(areaPath.options.fill.color, "areaColor");
        });

        it("sets area fill color to default if series color is fn", () => {
            setupAreaChart(plotArea, {
                series: [
                    deepExtend({
                            _defaults: { color: "areaColor" },
                            color: function() { }
                        },
                        positiveSeries
                    )
                ]
            });
            equal(areaPath.options.fill.color, "areaColor");
        });

        it("sets area opacity", () => {
            equal(areaPath.options.fill.opacity, 0.1);
        });
        /* migrate after adding animations
        it("area has same model id as its segment", () => {
            equal(polyline.style.data.modelId, areaChart._segments[0].modelId);
        });

        it("renders group with AreaChart id and no animations", () => {
            const group = view.findInLog("group", function(item) {
                return item.options.id === areaChart.id;
            });

            ok(group && !group.options.animation);
            equal(group.options.id, areaChart.id);
        });

        it("renders area chart group", () => {
            const group = view.findInLog("group", function(item) {
                return item.options.animation;
            });

            ok(group);
        });

        it("sets group animation", () => {
            const group = view.findInLog("group", function(item) {
                return item.options.animation;
            });
            equal(group.options.animation.type, "clip");
        });
        */
        it("area shape is open", () => {
            ok(!areaPath.options.closed);
        });

        it("sets zIndex", () => {
            setupAreaChart(plotArea, {
                series: [{
                    data: [1, 2],
                    zIndex: 10
                }]
            });
            equal(areaChart._segments[0].visual.options.zIndex, 10);
        });

        it("sets zIndex for spline segments", () => {
            setupAreaChart(plotArea, {
                series: [{
                    data: [1, 2],
                    zIndex: 10,
                    line: {
                        style: "smooth"
                    }
                }]
            });
            equal(areaChart._segments[0].visual.options.zIndex, 10);
        });
    });
})();

// ------------------------------------------------------------
describe('Area Chart / Rendering / Missing Values', () => {
    beforeEach(() => {
        sparseSeries.line = { width: 0 };
    });

    afterEach(() => {
        sparseSeries.line = null;
    });

    it("area stops before missing value", () => {
        setupAreaChart(plotArea, {
            series: [
                deepExtend({ missingValues: "gap" }, sparseSeries)
            ]
        });

        equal(pointCoordinates, [
            [ 0.5, 2 ], [ 0.5, 1 ],
            [ 1.5, 0 ], [ 1.5, 2 ]
        ]);
    });

    it("no area is created for isolated points", () => {
        setupAreaChart(plotArea, {
            series: [
                deepExtend({ missingValues: "gap" }, sparseSeries)
            ]
        });

        equal(segmentPaths().length, 1);
    });

    it("area continues after missing value", () => {
        setupAreaChart(plotArea, {
            series: [{
                missingValues: "gap",
                data: [ null, 1, 2 ],
                line: { width: 0 }
            }]
        });

        equal(pointCoordinates, [
            [ 1.5, 2 ], [ 1.5, 1 ],
            [ 2.5, 0 ], [ 2.5, 2 ]
        ]);
    });

    it("area is drawn between existing points", () => {
        setupAreaChart(plotArea, {
            series: [
                deepExtend({ missingValues: "interpolate" }, sparseSeries)
            ]
        });

        equal(pointCoordinates, [
            [ 0.5, 2 ], [ 0.5, 1 ], [ 1.5, 0 ],
            [ 3.5, 0 ], [ 3.5, 2 ]
        ]);
    });

    it("area goes to zero for missing point", () => {
        setupAreaChart(plotArea, {
            series: [
                deepExtend({ missingValues: "zero" }, sparseSeries)
            ]
        });

        equal(pointCoordinates, [
            [ 0.5, 2 ], [ 0.5, 1 ], [ 1.5, 0 ],
            [ 2.5, 2 ], [ 3.5, 0 ], [ 3.5, 2 ]
        ]);
    });
});

(function() {
    let segment;

    function createAreaChart(options) {
        chart = createChart(deepExtend({
            series: [{
                type: "area",
                data: [1, 2]
            }],
            categoryAxis: {
                categories: ["A", "B"]
            }
        }, options));

        const plotArea = chart._model.children[1];
        areaChart = plotArea.charts[0];

        segment = getChartDomElement(areaChart._segments[0]);
    }

    function areaClick(callback, x, y) {
        const options = createSpy({
            seriesClick: callback
        }, "seriesClick");
        createAreaChart(options);

        clickChart(chart, segment, x, y);

        expect(options.seriesClick).toHaveBeenCalledTimes(1);
    }

    function areaHover(callback, x, y) {
        const options = createSpy({
            seriesHover: callback
        }, "seriesHover");
        createAreaChart(options);

        triggerEvent("mouseover", segment, x, y);
        expect(options.seriesHover).toHaveBeenCalledTimes(1);
    }

    // ------------------------------------------------------------
    describe('Area Chart / Events / seriesClick', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when clicking segment", () => {
            const options = areaClick(function() { ok(true); });

        });

        it("fires for closest point when clicking segment (1)", () => {
            areaClick(function(e) { equal(e.value, 1); }, 0, 0);
        });

        it("fires for closest point when clicking segment (2)", () => {
            areaClick(function(e) { equal(e.value, 2); }, 1000, 0);
        });
    });

    // ------------------------------------------------------------
    describe('Area Chart / Events / seriesHover', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when hovering segment", () => {
            areaHover(function() { ok(true); });
        });

        it("fires for closest point when hovering segment (1)", () => {
            areaHover(function(e) { equal(e.value, 1); }, 0, 0);
        });

        it("fires for closest point when hovering segment (2)", () => {
            areaHover(function(e) { equal(e.value, 2); }, 1000, 0);
        });
    });

})();

(function() {
    let note;

    describe('Area Chart / Note', () => {
        beforeEach(() => {
            chart = createChart({
                series: [{
                    name: "Value",
                    type: "area",
                    data: [{ value: 10, noteText: "A" }]
                }]
            });

            note = chart._plotArea.charts[0].points[0].note;
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("should have text", () => {
            equal(note.text, "A");
        });
    });

    describe('Area Chart / Note Template', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        function createNote(options) {
            chart = createChart({
                series: [{
                    name: "Value",
                    type: "area",
                    data: [{ value: 10, noteText: "A", test: "test" }],
                    notes: deepExtend({}, options),
                    name: "name"
                }],
                categoryAxis: {
                    categories: ["Alpha"]
                }
            });

            note = chart._plotArea.charts[0].points[0].note;
        }

        it("dataItem", () => {
            createNote({
                label: {
                    template: "#= dataItem.test #"
                }
            });

            equal(note.label.content, "test");
        });

        it("category", () => {
            createNote({
                label: {
                    template: "#= category #"
                }
            });

            equal(note.label.content, "Alpha");
        });

        it("value", () => {
            createNote({
                label: {
                    template: "#= value #"
                }
            });

            equal(note.label.content, "10");
        });

        it("series", () => {
            createNote({
                label: {
                    template: "#= series.name #"
                }
            });

            equal(note.label.content, "name");
        });
    });
})();
