import 'core-js/es6';

import { DateValueAxis as Axis } from '../../src/core';
import { Box, Point } from '../../src/core';

import IntlService from '../../src/intl-service';

import { setDefaultOptions, map, grep, last } from '../../src/common';

import { ok, equal, close, arrayClose, equalTexts } from '../../test/test-helpers';
import '../../test/text-measure';
import '../../test/intl';

const chartBox = new Box(0, 0, 800, 600);
const TOLERANCE = 1;
let dateAxis;

class DateValueAxis extends Axis {    
}

setDefaultOptions(DateValueAxis.prototype, {
    labels: {
        font: "16px Verdana, sans-serif"
    }
});

function getAxisTextBoxes() {
    return grep(dateAxis.visual.children, function(item) {
        if (item !== dateAxis._lineGroup && item !== dateAxis._backgroundPath && item !== dateAxis._gridLines) {
            return true;
        }
    });
}

function getAxisTexts() {
    return map(getAxisTextBoxes(), function(item) {
        return last(item.children);
    });
}

(function() {
    function createDateValueAxis(min, max, options) {
        dateAxis = new DateValueAxis(
            min, max, options
        );

        dateAxis.reflow(chartBox);
        dateAxis.renderVisual();
    }

    // ------------------------------------------------------------
    describe('Date Value Axis / Configuration', () => {

        it("Min date can be parsed from string", () => {
            createDateValueAxis(
                new Date("2012/02/01"), new Date("2012/02/10"), {
                    min: "2012/02/01"
            });

            equal(new Date(dateAxis.options.min), new Date("2012/02/01"));
        });

        it("Max date can be parsed from string", () => {
            createDateValueAxis(
                new Date("2012/02/01"), new Date("2012/02/10"), {
                    max: "2012/02/29"
            });

            equal(new Date(dateAxis.options.max), new Date("2012/02/29"));
        });

        it("Axis crossing value can be parsed from string", () => {
            createDateValueAxis(
                new Date("2012/02/01"), new Date("2012/02/10"), {
                    axisCrossingValue: "2012/02/29"
            });

            equal(new Date(dateAxis.options.axisCrossingValue), new Date("2012/02/29"));
        });

        it("Axis crossing values can be parsed from string array", () => {
            createDateValueAxis(
                new Date("2012/02/01"), new Date("2012/02/10"), {
                    axisCrossingValue: ["2012/02/28", "2012/02/29"]
            });

            equal(dateAxis.options.axisCrossingValue,
                [new Date("2012/02/28"), new Date("2012/02/29")]
            );
        });

        it("Axis crossing values can be parsed from axisCrossingValues", () => {
            createDateValueAxis(
                new Date("2012/02/01"), new Date("2012/02/10"), {
                    axisCrossingValues: ["2012/02/28", "2012/02/29"]
            });

            equal(dateAxis.options.axisCrossingValue,
                [new Date("2012/02/28"), new Date("2012/02/29")]
            );
        });

        it("Major ticks count is correct", () => {
            createDateValueAxis(new Date("2012/02/01"), new Date("2012/02/06"));
            equal(dateAxis.getMajorTickPositions().length, 5);
        });

        it("Minor ticks count is correct", () => {
            createDateValueAxis(new Date("2012/02/01"), new Date("2012/02/06"));
            equal(dateAxis.getMinorTickPositions().length, 21);
        });

        it("Minor ticks are positioned correctly", () => {
            createDateValueAxis(new Date("2012/02/01"), new Date("2012/02/03"), {
                baseUnit: "hours",
                majorUnit: 24,
                minorUnit: 12
            });

            arrayClose(dateAxis.getMajorTickPositions(),
                [0, 266, 533, 799], 1);
        });

        it("Minor ticks are positioned correctly", () => {
            createDateValueAxis(new Date("2012/02/01"), new Date("2012/02/03"), {
                baseUnit: "hours",
                majorUnit: 24,
                minorUnit: 12
            });

            arrayClose(dateAxis.getMinorTickPositions(),
                [0, 133, 266, 400, 533, 665, 799], 1);
        });

        it("User set empty base unit defaults to automatic", () => {
            createDateValueAxis(new Date("2012/02/01"), new Date("2012/02/06"), {
                baseUnit: ""
            });

            equal(dateAxis.options.baseUnit, "days");
        });
    });

    // ------------------------------------------------------------
    describe('Date Value Axis / Slots', () => {

        it("Returns slot from date string", () => {
            createDateValueAxis(new Date("2012/02/01"), new Date("2012/02/10"));

            equal(dateAxis.getSlot("2012/02/01", "2012/02/02"),
                 dateAxis.getSlot(new Date("2012/02/01"), new Date("2012/02/02")));
        });

        it("limits slots depending on the limit parameter", () => {
            createDateValueAxis(new Date("2012/02/01"), new Date("2012/02/10"));
            const limited = dateAxis.getSlot("2012/02/20", "2012/02/20", true),
                unlimited = dateAxis.getSlot("2012/02/20", "2012/02/20", false);
            close(limited.x1, 799, 1, 1, "value is limited");
            close(unlimited.x1, 1255.57, 1, "value is not limited");
        });

        it("slot method returns slot as rect", () => {
            createDateValueAxis(new Date("2012/02/01"), new Date("2012/02/10"));
            const box = dateAxis.getSlot(new Date("2012/02/01"), new Date("2012/02/02"));
            const slot = dateAxis.slot(new Date("2012/02/01"), new Date("2012/02/02"));
            ok(slot.equals(box.toRect()));
        });
    });

    // ------------------------------------------------------------
    describe('Date Value Axis / Slots / Positions', () => {
        beforeEach(() => {
            createDateValueAxis(new Date("2014/06/01"), new Date("2014/06/15"));
        });

        it("first slot is at min axis value", () => {
            const slot = dateAxis.getSlot("2014/05/25");
            close(slot.x1, 0, TOLERANCE);
        });

        it("mid slot position", () => {
            const slot = dateAxis.getSlot("2014/06/08");
            close(slot.x1, 400, TOLERANCE);
        });

        it("last slot is at max axis value", () => {
            const slot = dateAxis.getSlot("2014/06/22");
            close(slot.x2, 799, TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Date Value Axis / Slots / Positions / Range', () => {
        beforeEach(() => {
            createDateValueAxis(new Date("2014/06/01"), new Date("2014/06/15"), {
                min: new Date("2014/06/01"),
                max: new Date("2014/06/15")
            });
        });

        it("first slot is at min axis value", () => {
            const slot = dateAxis.getSlot("2014/06/01");
            close(slot.x1, 0, TOLERANCE);
        });

        it("mid slot position", () => {
            const slot = dateAxis.getSlot("2014/06/08");
            close(slot.x1, 399.5, TOLERANCE);
        });

        it("last slot is at max axis value", () => {
            const slot = dateAxis.getSlot("2014/06/15");
            close(slot.x2, 799, TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Date Value Axis / Range manipulation', () => {
        beforeEach(() => {
            createDateValueAxis(new Date("2012/02/01"), new Date("2012/02/10"));
        });

        it("translateRange with negative delta", () => {
            const range = dateAxis.translateRange(-2);
            equal(range.min, new Date("2012/01/22"));
            equal(range.max, new Date("2012/02/05"));
        });

        it("translateRange with positive delta", () => {
            const range = dateAxis.translateRange(2);
            equal(range.min, new Date("2012/01/29"));
            equal(range.max, new Date("2012/02/12"));
        });

        it("scaleRange with negative delta expands range", () => {
            const range = dateAxis.scaleRange(-2);
            equal(range.min, new Date("2012/01/25 22:04:48"));
            equal(range.max, new Date("2012/02/15 01:55:12"));
        });

        it("scaleRange with positive delta shrinks range", () => {
            const range = dateAxis.scaleRange(2);
            equal(range.min, new Date("2012/01/31 12:28:48"));
            equal(range.max, new Date("2012/02/9 11:31:12"));
        });
    });

    // ------------------------------------------------------------
    describe('Date Value Axis / Base unit / Days', () => {

        it("Base unit is inferred from series range", () => {
            createDateValueAxis(
                new Date("2012/02/01"), new Date("2012/02/06")
            );

            equal("days", dateAxis.options.baseUnit);
        });

        it("Base unit is inferred from user set min/max", () => {
            createDateValueAxis(
                new Date("2012/02/01"), new Date("2012/12/01"), {
                    min: new Date("2012/02/01"),
                    max: new Date("2012/02/06")
            });

            equal(dateAxis.options.baseUnit, "days");
        });

        it("Base unit can be overriden", () => {
            createDateValueAxis(
                new Date("2012/01/01"), new Date("2012/12/01"), {
                    min: new Date("2012/01/01"),
                    max: new Date("2012/03/01"),
                    baseUnit: "days"
            });

            equal("days", dateAxis.options.baseUnit);
        });

        it("Major unit is calculated for user set min/max", () => {
            createDateValueAxis(
                new Date("2012/01/01"), new Date("2012/12/01"), {
                    min: new Date("2012/02/01"),
                    max: new Date("2012/02/06")
            });

            equal(dateAxis.options.majorUnit, 2);
        });

        it("Major unit is calculated for user set min/max and base unit", () => {
            createDateValueAxis(
                new Date("2012/01/01"), new Date("2012/12/01"), {
                    min: new Date("2012/01/01"),
                    max: new Date("2012/03/01"),
                    baseUnit: "days"
            });

            equal(dateAxis.options.majorUnit, 12);
        });

        it("Major unit is calculated for user set min and automatic max", () => {
            createDateValueAxis(
                new Date("2012/01/01"), new Date("2012/12/01"), {
                    min: new Date("2012/11/01"),
                    baseUnit: "days"
            });

            equal(dateAxis.options.majorUnit, 6);
        });

        it("Major unit is calculated for user set max and automatic min", () => {
            createDateValueAxis(
                new Date("2012/01/01"), new Date("2012/12/01"), {
                    max: new Date("2012/01/10"),
                    baseUnit: "days"
            });

            equal(dateAxis.options.majorUnit, 2);
        });

        it("Major unit is calculated for series when user min/max are not set", () => {
            createDateValueAxis(new Date("2012/02/01"), new Date("2012/02/06"));
            equal(dateAxis.options.majorUnit, 2);
        });

        it("Minor unit is derived from major unit", () => {
            createDateValueAxis(new Date("2012/02/01"), new Date("2012/02/06"));
            equal(dateAxis.options.minorUnit, 0.4);
        });

        it("Automatic maximum is rounded to set major unit", () => {
            createDateValueAxis(
                new Date("2012/02/01"), new Date("2012/02/10"), {
                    baseUnit: "days",
                    majorUnit: 4
            });

            equal(dateAxis.options.max, new Date("2012/02/12"));
        });

        it("Automatic maximum is rounded to auto major unit", () => {
            createDateValueAxis(
                new Date("2012/02/01"), new Date("2012/02/10"));

            equal(dateAxis.options.max, new Date("2012/02/12"));
        });

        it("Automatic minimum is rounded to set major unit", () => {
            createDateValueAxis(
                new Date("2012/02/01"), new Date("2012/02/10"), {
                    baseUnit: "days",
                    majorUnit: 4
            });

            equal(dateAxis.options.min, new Date("2012/01/31"));
        });

        it("Automatic minimum is rounded to auto major unit", () => {
            createDateValueAxis(
                new Date("2012/02/01"), new Date("2012/02/06"));

            equal(dateAxis.options.min, new Date("2012/01/31"));
        });

        it("Reports range minimum equal to options.min", () => {
            createDateValueAxis(
                new Date("2012/02/01"), new Date("2012/02/10"), {
                    min: new Date("2012/02/05")
            });

            equal(dateAxis.range().min, new Date("2012/02/05"));
        });

        it("Reports range maximum equal to options.max", () => {
            createDateValueAxis(
                new Date("2012/02/01"), new Date("2012/02/10"), {
                    max: new Date("2012/02/05")
            });

            equal(dateAxis.range().max, new Date("2012/02/05"));
        });

        it("creates labels with default format", () => {
            createDateValueAxis(new Date("2012/02/01"), new Date("2012/02/02"));

            equalTexts(getAxisTexts(), ["1/31", "2/1", "2/2", "2/3"]);
        });

        it("creates labels with custom date format", () => {
            createDateValueAxis(new Date("2012/02/01"), new Date("2012/02/02"), {
                labels: {
                    dateFormats: {
                        days: "M/d/yy"
                    }
                }
            });

            equalTexts(getAxisTexts(), ["1/31/12", "2/1/12", "2/2/12", "2/3/12"]);
        });

        it("creates labels with custom format", () => {
            createDateValueAxis(new Date("2012/02/01"), new Date("2012/02/02"), {
                labels: {
                    format: "M/d/yy"
                }
            });

            equalTexts(getAxisTexts(), ["1/31/12", "2/1/12", "2/2/12", "2/3/12"]);
        });

        it("creates labels with custom culture", () => {
            const current = IntlService.implementation;
            const toString = current.toString;
            try {        
                current.toString = function(value, format, locale) {
                   equal(locale, "es-ES");
                };
                createDateValueAxis(new Date("2012/02/01"), new Date("2012/02/02"), {
                    labels: {
                        format: "d.MMM",
                        culture: "es-ES"
                    }
                });
            } finally {
                current.toString = toString;
            }
        });

        it("creates labels with custom template", () => {
            createDateValueAxis(new Date("2012/02/01"), new Date("2012/02/02"), {
                categories: [
                    new Date("2012-02-01"), new Date("2012-02-01")
                ],
                labels: {
                    template: function(data) {
                        return IntlService.implementation.toString(data.value, 'yyyy');
                    }
                }
            });

            equalTexts(getAxisTexts(), ["2012", "2012", "2012", "2012"]);
        });
    });

    // ------------------------------------------------------------
    describe('Date Value Axis / Base unit / Weeks', () => {

        it("Major unit is calculated for user set min/max (in weeks)", () => {
            createDateValueAxis(
                new Date("2012/01/01"), new Date("2012/12/01"), {
                    min: new Date("2012/02/01"),
                    max: new Date("2012/02/15"),
                    baseUnit: "weeks"
            });

            equal(dateAxis.options.majorUnit, 1);
        });

        it("creates labels with default format", () => {
            createDateValueAxis(
                new Date("2012/01/01"), new Date("2012/01/15")
            );

            equalTexts(getAxisTexts(), ["12/25", "1/1", "1/8", "1/15", "1/22"]);
        });

        it("creates labels with custom date format", () => {
            createDateValueAxis(new Date("2012/01/01"), new Date("2012/01/15"), {
                labels: {
                    dateFormats: {
                        weeks: "M/d/yy"
                    }
                }
            });

            equalTexts(getAxisTexts(), ["12/25/11", "1/1/12", "1/8/12", "1/15/12", "1/22/12"]);
        });
    });

    // ------------------------------------------------------------
    describe('Date Value Axis / Base unit / Weeks', () => {

        it("Major unit is calculated for user set min/max (in weeks)", () => {
            createDateValueAxis(
                new Date("2012/01/01"), new Date("2012/12/01"), {
                    min: new Date("2012/02/01"),
                    max: new Date("2012/02/29"),
                    baseUnit: "weeks"
            });

            equal(dateAxis.options.majorUnit, 1);
        });

        it("creates labels with default format", () => {
            createDateValueAxis(
                new Date("2012/01/01"), new Date("2012/01/14")
            );

            equalTexts(getAxisTexts(), ["12/25", "1/1", "1/8", "1/15"]);
        });

        it("creates labels with custom date format", () => {
            createDateValueAxis(new Date("2012/01/01"), new Date("2012/01/14"), {
                labels: {
                    dateFormats: {
                        weeks: "M/d/yy"
                    }
                }
            });

            equalTexts(getAxisTexts(), ["12/25/11", "1/1/12", "1/8/12", "1/15/12"]);
        });
    });

    // ------------------------------------------------------------
    describe('Date Value Axis / Base unit / Months', () => {

        it("Major unit is calculated for user set min/max (in months)", () => {
            createDateValueAxis(
                new Date("2012/01/01"), new Date("2012/12/01"), {
                    min: new Date("2012/02/01"),
                    max: new Date("2012/02/29"),
                    baseUnit: "months"
            });

            equal(dateAxis.options.majorUnit, 1);
        });

        it("creates labels with default format", () => {
            createDateValueAxis(
                new Date("2012/01/01"), new Date("2012/02/01")
            );

            equalTexts(getAxisTexts(), ["Dec '11", "Jan '12", "Feb '12", "Mar '12"]);
        });

        it("creates labels with custom date format", () => {
            createDateValueAxis(new Date("2012/01/01"), new Date("2012/02/01"), {
                labels: {
                    dateFormats: {
                        months: "M/d/yy"
                    }
                }
            });

            equalTexts(getAxisTexts(), ["12/1/11", "1/1/12", "2/1/12", "3/1/12"]);
        });
    });

    // ------------------------------------------------------------
    describe('Date Value Axis / Base unit / Years', () => {

        it("Major unit is calculated for user set min/max (in years)", () => {
            createDateValueAxis(
                new Date("2012/01/01"), new Date("2100/01/01"), {
                    min: new Date("2012/02/01"),
                    max: new Date("2013/02/01"),
                    baseUnit: "years"
            });

            equal(dateAxis.options.majorUnit, 1);
        });

        it("creates labels with default format", () => {
            createDateValueAxis(
                new Date("2012/01/01"), new Date("2013/02/01")
            );

            equalTexts(getAxisTexts(), ["2011", "2012", "2013", "2014"]);
        });

        it("creates labels with custom date format", () => {
            createDateValueAxis(new Date("2012/01/01"), new Date("2013/02/01"), {
                labels: {
                    dateFormats: {
                        years: "M/d/yy"
                    }
                }
            });

            equalTexts(getAxisTexts(), ["1/1/11", "1/1/12", "1/1/13", "1/1/14"]);
        });
    });

    // ------------------------------------------------------------
    describe('Date Value Axis / Base unit / Hours', () => {

        it("Major unit is calculated for user set min/max (in hours)", () => {
            createDateValueAxis(
                new Date("2012/01/01"), new Date("2012/01/02"), {
                    min: new Date("2012/02/01 15:00"),
                    max: new Date("2012/02/01 16:00"),
                    baseUnit: "hours"
            });

            equal(dateAxis.options.majorUnit, 1);
        });

        it("creates labels with default format", () => {
            createDateValueAxis(
                new Date("2012/01/01 15:00"), new Date("2012/01/01 16:00")
            );

            equalTexts(getAxisTexts(), ["14:00", "15:00", "16:00", "17:00"]);
        });

        it("creates labels with custom date format", () => {
            createDateValueAxis(
                new Date("2012/01/01 15:00"), new Date("2012/01/01 16:00"), {
                labels: {
                    dateFormats: {
                        hours: "M/d HH:mm"
                    }
                }
            });

            equalTexts(getAxisTexts(), ["1/1 14:00", "1/1 15:00", "1/1 16:00", "1/1 17:00"]);
        });
    });

})();

(function() {
    let dateAxis;

    // ------------------------------------------------------------
    describe('Date ValueAxis / getValue / Horizontal', () => {
        beforeEach(() => {
            dateAxis = new DateValueAxis(
                new Date("2012/02/01"), new Date("2012/02/10"), {
                baseUnit: "days",
                vertical: false,
                labels: { visible: false }
            });
            dateAxis.reflow(chartBox);
        });

        it("returns null for coordinates left of axis", () => {
            equal(dateAxis.getValue(new Point(-1, 0)), null);
        });

        it("returns null for coordinates right of axis", () => {
            equal(dateAxis.getValue(new Point(1000, 0)), null);
        });

        it("returns minimum value for leftmost point", () => {
            equal(dateAxis.getValue(new Point(0, 0)), new Date("2012/01/31"));
        });

        it("returns maximum value for righttmost point", () => {
            equal(dateAxis.getValue(new Point(799, 0)), new Date("2012/02/12"));
        });

        it("returns value for middle point", () => {
            equal(dateAxis.getValue(new Point(399.5, 0)), new Date("2012/02/06 00:00:00"));
        });
    });

    // ------------------------------------------------------------
    describe('Date ValueAxis / getValue / Horizontal / Reverse', () => {
        beforeEach(() => {
            dateAxis = new DateValueAxis(
                new Date("2012/02/01"), new Date("2012/02/10"), {
                baseUnit: "days",
                vertical: false,
                reverse: true,
                labels: { visible: false }
            });

            dateAxis.reflow(chartBox);
        });

        it("returns minimum value for righttmost point", () => {
            equal(dateAxis.getValue(new Point(799, 0)), new Date("2012/01/31"));
        });

        it("returns maximum value for leftmost point", () => {
            equal(dateAxis.getValue(new Point(0, 0)), new Date("2012/02/12"));
        });

        it("returns value for middle point", () => {
            equal(dateAxis.getValue(new Point(399.5, 0)), new Date("2012/02/06 00:00:00"));
        });
    });

    // ------------------------------------------------------------
    describe('Date ValueAxis / getValue / Vertical', () => {
        beforeEach(() => {
            dateAxis = new DateValueAxis(
                new Date("2012/02/01"), new Date("2012/02/10"), {
                baseUnit: "days",
                vertical: true,
                labels: { visible: false }
            });
            dateAxis.reflow(chartBox);
        });

        it("returns null for coordinates above the axis", () => {
            equal(dateAxis.getValue(new Point(0, -1)), null);
        });

        it("returns null for coordinates below the axis", () => {
            equal(dateAxis.getValue(new Point(0, 1000)), null);
        });

        it("returns minimum value for bottommost point", () => {
            equal(dateAxis.getValue(new Point(0, 599)), new Date("2012/01/31"));
        });

        it("returns maximum value for topmost point", () => {
            equal(dateAxis.getValue(new Point(0, 0)), new Date("2012/02/12"));
        });

        it("returns value for middle point", () => {
            equal(dateAxis.getValue(new Point(0, 299.5)), new Date("2012/02/06"));
        });
    });

    // ------------------------------------------------------------
    describe('Date ValueAxis / getValue / Vertical / Reverse', () => {
        beforeEach(() => {
            dateAxis = new DateValueAxis(
                new Date("2012/02/01"), new Date("2012/02/10"), {
                baseUnit: "days",
                vertical: true,
                reverse: true,
                labels: { visible: false }
            });

            dateAxis.reflow(chartBox);
        });

        it("returns minimum value for topmost  point", () => {
            equal(dateAxis.getValue(new Point(0, 0)), new Date("2012/01/31"));
        });

        it("returns maximum value for bottommost point", () => {
            equal(dateAxis.getValue(new Point(0, 599)), new Date("2012/02/12"));
        });

        it("returns value for middle point", () => {
            equal(dateAxis.getValue(new Point(0, 299.5)), new Date("2012/02/06"));
        });
    });
})();
