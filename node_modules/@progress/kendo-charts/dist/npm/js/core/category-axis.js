module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(472);


/***/ },

/***/ 60:
/***/ function(module, exports) {

	module.exports = require("../common/constants");

/***/ },

/***/ 111:
/***/ function(module, exports) {

	module.exports = require("../common/set-default-options");

/***/ },

/***/ 113:
/***/ function(module, exports) {

	module.exports = require("../common/defined");

/***/ },

/***/ 114:
/***/ function(module, exports) {

	module.exports = require("../common/is-number");

/***/ },

/***/ 205:
/***/ function(module, exports) {

	module.exports = require("../common/last");

/***/ },

/***/ 459:
/***/ function(module, exports) {

	module.exports = require("./axis-label");

/***/ },

/***/ 471:
/***/ function(module, exports) {

	module.exports = require("../common/value-or-default");

/***/ },

/***/ 472:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _axis = __webpack_require__(473);

	var _axis2 = _interopRequireDefault(_axis);

	var _axisLabel = __webpack_require__(459);

	var _axisLabel2 = _interopRequireDefault(_axisLabel);

	var _constants = __webpack_require__(60);

	var _defined = __webpack_require__(113);

	var _defined2 = _interopRequireDefault(_defined);

	var _last = __webpack_require__(205);

	var _last2 = _interopRequireDefault(_last);

	var _round = __webpack_require__(474);

	var _round2 = _interopRequireDefault(_round);

	var _isNumber = __webpack_require__(114);

	var _isNumber2 = _interopRequireDefault(_isNumber);

	var _limitValue = __webpack_require__(475);

	var _limitValue2 = _interopRequireDefault(_limitValue);

	var _valueOrDefault = __webpack_require__(471);

	var _valueOrDefault2 = _interopRequireDefault(_valueOrDefault);

	var _setDefaultOptions = __webpack_require__(111);

	var _setDefaultOptions2 = _interopRequireDefault(_setDefaultOptions);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CategoryAxis = function (_Axis) {
	    _inherits(CategoryAxis, _Axis);

	    function CategoryAxis() {
	        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        _classCallCheck(this, CategoryAxis);

	        var _this = _possibleConstructorReturn(this, (CategoryAxis.__proto__ || Object.getPrototypeOf(CategoryAxis)).call(this, options));

	        _this._ticks = {};
	        _this._initCategories(_this.options);
	        return _this;
	    }

	    _createClass(CategoryAxis, [{
	        key: '_initCategories',
	        value: function _initCategories(options) {
	            var categories = (options.categories || []).slice(0);
	            var definedMin = (0, _defined2.default)(options.min);
	            var definedMax = (0, _defined2.default)(options.max);
	            options.categories = categories;

	            if ((definedMin || definedMax) && categories.length) {
	                options.srcCategories = options.categories;
	                var min = definedMin ? Math.floor(options.min) : 0;
	                var max = void 0;

	                if (definedMax) {
	                    max = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);
	                } else {
	                    max = categories.length;
	                }

	                options.categories = options.categories.slice(min, max);
	            }
	        }
	    }, {
	        key: 'rangeIndices',
	        value: function rangeIndices() {
	            var options = this.options;
	            var length = options.categories.length || 1;
	            var min = (0, _isNumber2.default)(options.min) ? options.min % 1 : 0;
	            var max = void 0;

	            if ((0, _isNumber2.default)(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {
	                max = length - (1 - options.max % 1);
	            } else {
	                max = length - (options.justified ? 1 : 0);
	            }

	            return {
	                min: min,
	                max: max
	            };
	        }
	    }, {
	        key: 'totalRangeIndices',
	        value: function totalRangeIndices(limit) {
	            var options = this.options;
	            var min = (0, _isNumber2.default)(options.min) ? options.min : 0;
	            var max = void 0;

	            if ((0, _isNumber2.default)(options.max)) {
	                max = options.max;
	            } else if ((0, _isNumber2.default)(options.min)) {
	                max = min + options.categories.length;
	            } else {
	                max = (options.srcCategories || options.categories).length - (options.justified ? 1 : 0) || 1;
	            }

	            if (limit) {
	                var totalRange = this.totalRange();
	                min = (0, _limitValue2.default)(min, 0, totalRange.max);
	                max = (0, _limitValue2.default)(max, 0, totalRange.max);
	            }

	            return {
	                min: min,
	                max: max
	            };
	        }
	    }, {
	        key: 'range',
	        value: function range() {
	            var options = this.options;
	            return { min: (0, _isNumber2.default)(options.min) ? options.min : 0, max: (0, _isNumber2.default)(options.max) ? options.max : options.categories.length };
	        }
	    }, {
	        key: 'totalRange',
	        value: function totalRange() {
	            var options = this.options;
	            return { min: 0, max: Math.max(this._seriesMax || 0, (options.srcCategories || options.categories).length) - (options.justified ? 1 : 0) };
	        }
	    }, {
	        key: 'getScale',
	        value: function getScale() {
	            var _rangeIndices = this.rangeIndices();

	            var min = _rangeIndices.min;
	            var max = _rangeIndices.max;

	            var lineBox = this.lineBox();
	            var size = this.options.vertical ? lineBox.height() : lineBox.width();
	            var scale = size / (max - min || 1);

	            return scale * (this.options.reverse ? -1 : 1);
	        }
	    }, {
	        key: 'getTickPositions',
	        value: function getTickPositions(stepSize) {
	            var _options = this.options;
	            var vertical = _options.vertical;
	            var reverse = _options.reverse;

	            var _rangeIndices2 = this.rangeIndices();

	            var min = _rangeIndices2.min;
	            var max = _rangeIndices2.max;

	            var lineBox = this.lineBox();
	            var scale = this.getScale();
	            var pos = lineBox[(vertical ? _constants.Y : _constants.X) + (reverse ? 2 : 1)];
	            var positions = [];

	            var current = min % 1 !== 0 ? Math.floor(min / 1) + stepSize : min;

	            while (current <= max) {
	                positions.push(pos + (0, _round2.default)(scale * (current - min), _constants.COORD_PRECISION));
	                current += stepSize;
	            }

	            return positions;
	        }
	    }, {
	        key: 'getLabelsTickPositions',
	        value: function getLabelsTickPositions() {
	            var tickPositions = this.getMajorTickPositions().slice(0);
	            var range = this.rangeIndices();
	            var scale = this.getScale();
	            var box = this.lineBox();
	            var options = this.options;
	            var axis = options.vertical ? _constants.Y : _constants.X;
	            var start = options.reverse ? 2 : 1;
	            var end = options.reverse ? 1 : 2;

	            if (range.min % 1 !== 0) {
	                tickPositions.unshift(box[axis + start] - scale * (range.min % 1));
	            }

	            if (range.max % 1 !== 0) {
	                tickPositions.push(box[axis + end] + scale * (1 - range.max % 1));
	            }

	            return tickPositions;
	        }
	    }, {
	        key: 'labelTickIndex',
	        value: function labelTickIndex(label) {
	            var range = this.rangeIndices();
	            var index = label.index;

	            if (range.min > 0) {
	                index = index - Math.floor(range.min);
	            }

	            return index;
	        }
	    }, {
	        key: 'arrangeLabels',
	        value: function arrangeLabels() {
	            _get(CategoryAxis.prototype.__proto__ || Object.getPrototypeOf(CategoryAxis.prototype), 'arrangeLabels', this).call(this);
	            this.hideOutOfRangeLabels();
	        }
	    }, {
	        key: 'hideOutOfRangeLabels',
	        value: function hideOutOfRangeLabels() {
	            var box = this.box;
	            var labels = this.labels;

	            var valueAxis = this.options.vertical ? _constants.Y : _constants.X;
	            var start = box[valueAxis + 1];
	            var end = box[valueAxis + 2];
	            var firstLabel = labels[0];
	            var lastLabel = (0, _last2.default)(labels);

	            if (labels.length) {
	                if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {
	                    firstLabel.options.visible = false;
	                }
	                if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {
	                    lastLabel.options.visible = false;
	                }
	            }
	        }
	    }, {
	        key: 'getMajorTickPositions',
	        value: function getMajorTickPositions() {
	            return this.getTicks().majorTicks;
	        }
	    }, {
	        key: 'getMinorTickPositions',
	        value: function getMinorTickPositions() {
	            return this.getTicks().minorTicks;
	        }
	    }, {
	        key: 'getTicks',
	        value: function getTicks() {
	            var _options2 = this.options;
	            var reverse = _options2.reverse;
	            var justified = _options2.justified;

	            var cache = this._ticks;
	            var range = this.rangeIndices();
	            var lineBox = this.lineBox();
	            var hash = lineBox.getHash() + range.min + "," + range.max + reverse + justified;

	            if (cache._hash !== hash) {
	                cache._hash = hash;
	                cache.majorTicks = this.getTickPositions(1);
	                cache.minorTicks = this.getTickPositions(0.5);
	            }

	            return cache;
	        }
	    }, {
	        key: 'getSlot',
	        value: function getSlot(from, to, limit) {
	            var options = this.options;
	            var reverse = options.reverse;
	            var justified = options.justified;
	            var vertical = options.vertical;

	            var _rangeIndices3 = this.rangeIndices();

	            var min = _rangeIndices3.min;

	            var valueAxis = vertical ? _constants.Y : _constants.X;
	            var lineBox = this.lineBox();
	            var scale = this.getScale();
	            var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];
	            var slotBox = lineBox.clone();
	            var singleSlot = !(0, _defined2.default)(to);

	            var start = (0, _valueOrDefault2.default)(from, 0);
	            var end = (0, _valueOrDefault2.default)(to, start);
	            end = Math.max(end - 1, start);

	            // Fixes transient bug caused by iOS 6.0 JIT
	            // (one can never be too sure)
	            end = Math.max(start, end);

	            var p1 = lineStart + (start - min) * scale;
	            var p2 = lineStart + (end + 1 - min) * scale;

	            if (singleSlot && justified) {
	                p2 = p1;
	            }

	            if (limit) {
	                p1 = (0, _limitValue2.default)(p1, lineBox[valueAxis + 1], lineBox[valueAxis + 2]);
	                p2 = (0, _limitValue2.default)(p2, lineBox[valueAxis + 1], lineBox[valueAxis + 2]);
	            }

	            slotBox[valueAxis + 1] = reverse ? p2 : p1;
	            slotBox[valueAxis + 2] = reverse ? p1 : p2;

	            return slotBox;
	        }
	    }, {
	        key: 'slot',
	        value: function slot(from, to, limit) {
	            var start = from;
	            var end = to;

	            if (typeof start === "string") {
	                start = this.categoryIndex(start);
	            }

	            if (typeof end === "string") {
	                end = this.categoryIndex(end);
	            }

	            return _get(CategoryAxis.prototype.__proto__ || Object.getPrototypeOf(CategoryAxis.prototype), 'slot', this).call(this, start, end, limit);
	        }
	    }, {
	        key: 'pointCategoryIndex',
	        value: function pointCategoryIndex(point) {
	            var _options3 = this.options;
	            var reverse = _options3.reverse;
	            var justified = _options3.justified;
	            var vertical = _options3.vertical;

	            var valueAxis = vertical ? _constants.Y : _constants.X;
	            var lineBox = this.lineBox();
	            var range = this.rangeIndices();
	            var startValue = reverse ? range.max : range.min;
	            var scale = this.getScale();
	            var lineStart = lineBox[valueAxis + 1];
	            var lineEnd = lineBox[valueAxis + 2];
	            var pos = point[valueAxis];

	            if (pos < lineStart || pos > lineEnd) {
	                return null;
	            }

	            var value = startValue + (pos - lineStart) / scale;
	            var diff = value % 1;

	            if (justified) {
	                value = Math.round(value);
	            } else if (diff === 0 && value > 0) {
	                value--;
	            }

	            return Math.floor(value);
	        }
	    }, {
	        key: 'getCategory',
	        value: function getCategory(point) {
	            var index = this.pointCategoryIndex(point);

	            if (index === null) {
	                return null;
	            }

	            return this.options.categories[index];
	        }
	    }, {
	        key: 'categoryIndex',
	        value: function categoryIndex(value) {
	            var options = this.options;
	            var index = (options.srcCategories || options.categories).indexOf(value);

	            return index - Math.floor(options.min || 0);
	        }
	    }, {
	        key: 'translateRange',
	        value: function translateRange(delta) {
	            var options = this.options;
	            var lineBox = this.lineBox();
	            var size = options.vertical ? lineBox.height() : lineBox.width();
	            var range = options.categories.length;
	            var scale = size / range;
	            var offset = (0, _round2.default)(delta / scale, _constants.DEFAULT_PRECISION);

	            return {
	                min: offset,
	                max: range + offset
	            };
	        }
	    }, {
	        key: 'zoomRange',
	        value: function zoomRange(rate) {
	            var rangeIndices = this.totalRangeIndices();

	            var _totalRange = this.totalRange();

	            var totalMin = _totalRange.min;
	            var totalMax = _totalRange.max;

	            var min = (0, _limitValue2.default)(rangeIndices.min + rate, totalMin, totalMax);
	            var max = (0, _limitValue2.default)(rangeIndices.max - rate, totalMin, totalMax);

	            if (max - min > 0) {
	                return {
	                    min: min,
	                    max: max
	                };
	            }
	        }
	    }, {
	        key: 'scaleRange',
	        value: function scaleRange(scale) {
	            var range = this.options.categories.length;
	            var delta = scale * range;

	            return {
	                min: -delta,
	                max: range + delta
	            };
	        }
	    }, {
	        key: 'labelsCount',
	        value: function labelsCount() {
	            var labelsRange = this.labelsRange();

	            return labelsRange.max - labelsRange.min;
	        }
	    }, {
	        key: 'labelsRange',
	        value: function labelsRange() {
	            var options = this.options;
	            var justified = options.justified;
	            var labelOptions = options.labels;

	            var _totalRangeIndices = this.totalRangeIndices(true);

	            var min = _totalRangeIndices.min;
	            var max = _totalRangeIndices.max;

	            var start = Math.floor(min);

	            if (!justified) {
	                min = Math.floor(min);
	                max = Math.ceil(max);
	            } else {
	                min = Math.ceil(min);
	                max = Math.floor(max);
	            }

	            var skip = void 0;

	            if (min > labelOptions.skip) {
	                skip = labelOptions.skip + labelOptions.step * Math.ceil((min - labelOptions.skip) / labelOptions.step);
	            } else {
	                skip = labelOptions.skip;
	            }

	            return {
	                min: skip - start,
	                max: (options.categories.length ? max + (justified ? 1 : 0) : 0) - start
	            };
	        }
	    }, {
	        key: 'createAxisLabel',
	        value: function createAxisLabel(index, labelOptions) {
	            var options = this.options;
	            var dataItem = options.dataItems ? options.dataItems[index] : null;
	            var category = (0, _valueOrDefault2.default)(options.categories[index], "");
	            var text = this.axisLabelText(category, dataItem, labelOptions);

	            return new _axisLabel2.default(category, text, index, dataItem, labelOptions);
	        }
	    }, {
	        key: 'shouldRenderNote',
	        value: function shouldRenderNote(value) {
	            var categories = this.options.categories;

	            return categories.length && categories.length > value && value >= 0;
	        }
	    }, {
	        key: 'pan',
	        value: function pan(delta) {
	            var range = this.totalRangeIndices(true);
	            var scale = this.getScale();
	            var offset = (0, _round2.default)(delta / scale, _constants.DEFAULT_PRECISION);
	            var totalRange = this.totalRange();
	            var min = range.min + offset;
	            var max = range.max + offset;

	            return this.limitRange(min, max, 0, totalRange.max, offset);
	        }
	    }, {
	        key: 'pointsRange',
	        value: function pointsRange(start, end) {
	            var _options4 = this.options;
	            var reverse = _options4.reverse;
	            var vertical = _options4.vertical;

	            var valueAxis = vertical ? _constants.Y : _constants.X;
	            var lineBox = this.lineBox();
	            var range = this.totalRangeIndices(true);
	            var scale = this.getScale();
	            var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];

	            var diffStart = start[valueAxis] - lineStart;
	            var diffEnd = end[valueAxis] - lineStart;

	            var min = range.min + diffStart / scale;
	            var max = range.min + diffEnd / scale;

	            return {
	                min: Math.min(min, max),
	                max: Math.max(min, max)
	            };
	        }
	    }, {
	        key: 'valueRange',
	        value: function valueRange() {
	            return this.range();
	        }
	    }]);

	    return CategoryAxis;
	}(_axis2.default);

	(0, _setDefaultOptions2.default)(CategoryAxis.prototype, {
	    type: "category",
	    categories: [],
	    vertical: false,
	    majorGridLines: {
	        visible: false,
	        width: 1,
	        color: _constants.BLACK
	    },
	    labels: {
	        zIndex: 1
	    },
	    justified: false
	});

	exports.default = CategoryAxis;

/***/ },

/***/ 473:
/***/ function(module, exports) {

	module.exports = require("./axis");

/***/ },

/***/ 474:
/***/ function(module, exports) {

	module.exports = require("../common/round");

/***/ },

/***/ 475:
/***/ function(module, exports) {

	module.exports = require("../common/limit-value");

/***/ }

/******/ });