import 'core-js/es6';
import { withRoot, $ } from 'e2e-utils';
import { same, equal, ok, compareMatrices, arrayClose, contains } from '../test/test-helpers';
import { canvas, Group, Path, MultiPath, Text, Image, Circle, Arc, Rect, Layout, LinearGradient, RadialGradient, ShapesQuadTree, Element, exportImage } from '../src/drawing';
import { Matrix, transform, Point, Circle as GeometryCircle, Rect as GeometryRect, Arc as GeometryArc } from '../src/geometry';
import animationFrame from '../src/common/animation-frame';
import { baseSurfaceTests, baseSurfaceEventTests } from './base-surface-tests';
import '../test/text-measure';

const { RootNode, Node, ArcNode, CircleNode, GroupNode, PathNode, MultiPathNode, TextNode, ImageNode, RectNode, Surface } = canvas;

class Context {
    constructor() {
        this._state = [];
    }

    beginPath() {}
    clearRect() {}
    close() {}
    drawImage() {}
    fill() {}
    fillText() {}
    lineTo() {}
    moveTo() {}
    restore() {
        Object.assign(this, this._state.pop());
    }
    save() {
        this._state.push(Object.assign({}, this));
    }
    stroke() {}
    strokeText() {}
    createLinearGradient() {}
    createRadialGradient() {}
    rect() {}
    arc() {}
    transform() {}
}

function mockContext(members) {
    const context = new Context();
    return Object.assign(context, members);
}

function noop() {}

(function() {

    baseSurfaceTests("Canvas", Surface);

    let container, surface;

    function createSurface(options) {
        if (surface) {
            surface.destroy();
        }

        surface = new Surface(container[0], options);
    }

    function setupSurface() {
        afterEach(() => {
            surface.destroy();
        });

        beforeEach(withRoot((root) => {
            container = $("<div>").appendTo(root);
            createSurface();
        }));
    }

    function triggerEvent(element, name) {
        const event = new Event(name);
        element.dispatchEvent(event);
    }

    describe('Surface / Canvas', () => {

        setupSurface();


        it("reports actual surface type", () => {
            createSurface({ type: "foo" });
            equal(surface.type, "canvas");
        });

        it("appends canvas element to container", () => {
            equal(container.find("canvas").length, 1);
        });

        it("sets actual width on root element", () => {
            createSurface({ width: "500px" });
            equal(surface._rootElement.width, 500);
        });

        it("sets actual height on root element", () => {
            createSurface({ height: "500px" });
            equal(surface._rootElement.height, 500);
        });

        it("sets actual width on resize", () => {
            surface.element.style.width = "500px";
            surface.resize();
            equal(surface._rootElement.width, 500);
        });

        it("sets actual height on resize", () => {
            surface.element.style.height = "500px";
            surface.resize();
            equal(surface._rootElement.height, 500);
        });

        it("destroys root node", () => {
            surface._root.destroy = function() {
                ok(true);
            };

            surface.destroy();
        });

        it("eventTarget returns shape returned by the searchTree", () => {
            let path = new Path();
            surface._searchTree.pointShape = function() {
                return path;
            };

            ok(surface.eventTarget({}) === path);
        });

        it("eventTarget passes point based on the event coordinates to searchTree", () => {
            let path = new Path();
            let offset = surface._elementOffset();
            surface._searchTree.pointShape = function(point) {
                equal(point.x, 100 - offset.left);
                equal(point.y, 200 - offset.top);
            };

            surface.eventTarget({ pageX: 100, pageY: 200 });
        });

        it("eventTarget returns undefined if there is no searchTree", () => {
            delete surface._searchTree;

            ok(surface.eventTarget() === undefined);
        });

    });

    describe('Surface / Canvas / mouse tracking', () => {
        setupSurface();

        it("inits search tree", () => {
            ok(surface._searchTree instanceof ShapesQuadTree);
        });

        it("draw adds element to tree", () => {
            let path = new Path();
            spyOn(surface._searchTree, "add").and.callFake(function(elements) {
                ok(path === elements[0]);
            });
            surface.draw(path);
            expect(surface._searchTree.add).toHaveBeenCalledTimes(1);
        });

        it("clear clears tree", () => {
            spyOn(surface._searchTree, "clear").and.callThrough();
            surface.clear();
            expect(surface._searchTree.clear).toHaveBeenCalledTimes(1);
        });

        it("destroy clears tree", () => {
            const searchTree = surface._searchTree;
            spyOn(searchTree, "clear").and.callThrough();
            surface.destroy();
            expect(searchTree.clear).toHaveBeenCalledTimes(1);
        });

        it("passes surface point to tree", () => {
            spyOn(surface._searchTree, "pointShape").and.callFake(function(point) {
                let offset = $(surface.element).offset();
                equal(point.x, -offset.left);
                equal(point.y, -offset.top);
            });
            triggerEvent(surface.element, "click");
        });
    });

    describe('Surface / Canvas / mouse tracking / click', () => {
        setupSurface();

        it("triggers the surface click event with the shape returned from the tree", () => {
            let path = new Path();
            surface._searchTree.pointShape = function() {
                return path;
            };
            surface.bind("click", function(e) {
                ok(e.element === path);
                equal(e.type, "click");
            });
            triggerEvent(surface.element, "click");
        });

        it("does not trigger the surface click event if the tree returns no shape",  () => {
            let clickCalls = 0;
            surface._searchTree.pointShape = () => {};
            surface.bind("click", function(e) {
                clickCalls++;
            });
            triggerEvent(surface.element, "click");

            same(clickCalls, 0);
        });

        it("does not trigger surface click if tracking is suspended", () => {
            let clickCalls = 0;
            surface._searchTree.pointShape = function() {
                return new Path();
            };
            surface.bind("click", function(e) {
                clickCalls++;
            });
            surface.suspendTracking();
            triggerEvent(surface.element, "click");

            same(clickCalls, 0);
        });

        it("triggers the click event if tracking is suspended and resumed", () => {
            let clickCalls = 0;

            surface.eventTarget = function() {
                return new Path();
            };
            surface.bind("click", function(e) {
                clickCalls++;
            });
            surface.suspendTracking();
            triggerEvent(surface.element, "click");
            surface.resumeTracking();
            triggerEvent(surface.element, "click");

            same(clickCalls, 1);
        });

    });

    describe('Surface / Canvas / mouse tracking / mousemove', () => {
        setupSurface();

        it("triggers the surface mousemove event with the shape returned from the tree", () => {
            let path = new Path();
            surface._searchTree.pointShape = function() {
                return path;
            };
            surface.bind("mousemove", function(e) {
                ok(e.element === path);
                equal(e.type, "mousemove");
            });
            triggerEvent(surface.element, "mousemove");
        });

        it("does not trigger the surface mousemove event if tracking is suspended", () => {
            let callsCount = 0;

            surface._searchTree.pointShape = function() {
                return new Path();
            };
            surface.bind("mousemove", function(e) {
                callsCount++;
            });
            surface.suspendTracking();
            triggerEvent(surface.element, "mousemove");

            same(callsCount, 0);
        });

        it("triggers mousemove event if tracking is suspended and resumed", () => {
            let callsCount = 0;
            surface.eventTarget = function() {
                return new Path();
            };
            surface.bind("mousemove", function(e) {
                callsCount++;
            });

            surface.suspendTracking();
            triggerEvent(surface.element, "mousemove");
            surface.resumeTracking();
            triggerEvent(surface.element, "mousemove");

            same(callsCount, 1);
        });

        it("triggers the surface mousemove event if the tree returns no shape", () => {
            surface._searchTree.pointShape = noop;

            surface.bind("mousemove", function(e) {
                ok(!e.element);
                equal(e.type, "mousemove");
            });
            triggerEvent(surface.element, "mousemove");
        });

        it("triggers the surface mouseenter event with the shape returned from the tree", () => {
            let path = new Path();
            surface._searchTree.pointShape = function() {
                return path;
            };
            surface.bind("mouseenter", function(e) {
                ok(e.element === path);
                equal(e.type, "mouseenter");
            });
            triggerEvent(surface.element, "mousemove");
        });

        it("does not trigger the surface mouseenter event if tracking is suspended", () => {
            let callsCount = 0;

            surface.eventTarget = function() {
                return new Path();
            };
            surface.bind("mouseenter", function(e) {
                callsCount++;
            });
            surface.suspendTracking();
            triggerEvent(surface.element, "mousemove");

            same(callsCount, 0);
        });

        it("triggers the surface mouseenter event if tracking is suspended and resumed", () => {
            let callsCount = 0;

            surface.eventTarget = function() {
                return new Path();
            };
            surface.bind("mouseenter", function(e) {
                callsCount++;
            });
            surface.suspendTracking();
            triggerEvent(surface.element, "mousemove");
            surface.resumeTracking();
            triggerEvent(surface.element, "mousemove");

            same(callsCount, 1);
        });

        it("does not trigger the surface mouseenter event if the tree returns no shape", () => {
            let callsCount = 0;
            surface._searchTree.pointShape = noop;
            surface.bind("mouseenter", function(e) {
                callsCount++;
            });
            triggerEvent(surface.element, "mousemove");

            same(callsCount, 0);
        });

        it("does not trigger the surface mouseenter event if the tree returns the same shape", () => {
            let callsCount = 0;
            let path = new Path();
            surface._searchTree.pointShape = function() {
                return path;
            };
            surface.bind("mouseenter", function(e) {
                callsCount++;
            });
            triggerEvent(surface.element, "mousemove");
            triggerEvent(surface.element, "mousemove");

            same(callsCount, 1);
        });

        it("triggers the surface mouseleave event if the tree returns no shape", () => {
            let path = new Path();
            let first = true;
            surface._searchTree.pointShape = function() {
                if (first) {
                    first = false;
                    return path;
                }
            };
            surface.bind("mouseleave", function(e) {
                ok(e.element === path);
                equal(e.type, "mouseleave");
            });
            triggerEvent(surface.element, "mousemove");
            triggerEvent(surface.element, "mousemove");
        });

        it("does not trigger the surface mouseleave event if tracking is suspended", () => {
            let callsCount = 0;
            let first = true;
            surface._searchTree.pointShape = function() {
                if (first) {
                    first = false;
                    return new Path();
                }
            };
            surface.bind("mouseleave", function(e) {
                callsCount++;
            });
            surface.suspendTracking();
            triggerEvent(surface.element, "mousemove");
            triggerEvent(surface.element, "mousemove");

            same(callsCount, 0);
        });

        it("triggers the surface mouseleave event if tracking is suspended and resumed", () => {
            let first = true;
            surface.eventTarget = function() {
                if (first) {
                    first = false;
                    return new Path();
                }
            };
            surface.bind("mouseleave", function(e) {
                ok(true);
            });
            triggerEvent(surface.element, "mousemove");
            surface.suspendTracking();
            surface.resumeTracking();
            triggerEvent(surface.element, "mousemove");
        });

        it("triggers the surface mouseleave event if the tree returns different shape", () => {
            let path = new Path();
            let otherPath = new Path();
            let first = true;
            surface._searchTree.pointShape = function() {
                if (first) {
                    first = false;
                    return path;
                }
                return otherPath;
            };
            surface.bind("mouseleave", function(e) {
                ok(e.element === path);
                equal(e.type, "mouseleave");
            });
            triggerEvent(surface.element, "mousemove");
            triggerEvent(surface.element, "mousemove");
        });

        it("does not trigger the surface mouseleave event if there is no current shape", () => {
            let callsCount = 0;
            let path = new Path();
            surface._searchTree.pointShape = function() {
                return path;
            };
            surface.bind("mouseleave", function(e) {
                callsCount++;
            });
            triggerEvent(surface.element, "mousemove");

            same(callsCount, 0);
        });

        it("does not trigger the surface mouseleave event if the shape is the same", () => {
            let callsCount = 0;
            let path = new Path();
            surface._searchTree.pointShape = function() {
                return path;
            };
            surface.bind("mouseleave", function(e) {
                callsCount++;
            });
            triggerEvent(surface.element, "mousemove");
            triggerEvent(surface.element, "mousemove");

            same(callsCount, 0);
        });

    });

})();

describe('RootNode', () => {
    let root;

    function createRoot(ctx) {
        root = new RootNode({
            getContext: function() {
                return ctx;
            }
        });
    }

    beforeEach(() => {
        createRoot(mockContext());
    });

    it("throttles invalidate", (done) => {
        const ctx = mockContext();
        spyOn(ctx, "clearRect");

        createRoot(ctx);

        setTimeout(() => {
            expect(ctx.clearRect).toHaveBeenCalledTimes(2);
            done();
        }, 60);

        root.invalidate();
        root.invalidate();

        animationFrame(() => {
           expect(ctx.clearRect).toHaveBeenCalledTimes(1);
        });
    });

    it("makes a tail call to invalidate",(done) => {
        let count = 0;
        createRoot(mockContext({
            clearRect: function() {
                if (++count == 2) {
                    ok(true);
                    done();
                }
            }
        }));

        root.invalidate();
        root.invalidate();
    });

    it("load invalidates immediately", () => {
        root._invalidate = function() {
           equal(this.childNodes.length, 1);
        };
        root.load([new Group()]);
    });

    it("traverse traverses children", () => {
        let child = new Node();
        root.append(child);

        root.traverse(function(item) {
            same(item, child);
        });
    });

    it("traverse traverses child group nodes", () => {
        let childGroup = new GroupNode();
        root.append(childGroup);

        let child = new Node();
        childGroup.append(child);

        root.traverse(function(item) {
            ok(true);
        });
    });

    it("traverse is chainable", () => {
        equal(root.traverse(noop), root);
    });
});

describe('Node', () => {

    let node;

    beforeEach(() => {
        node = new Node();
    });

    it("load appends Node for Group", () => {
        node.append = function(child) {
            ok(child instanceof Node);
        };

        node.load([new Group()]);
    });

    it("load append Node at position", () => {
        node.insertAt = function(child, pos) {
            equal(pos, 1);
        };

        node.load([new Group()], 1);
    });

    it("load appends PathNode", () => {
        node.append = function(child) {
            ok(child instanceof PathNode);
        };

        node.load([new Path()]);
    });

    it("load appends MultiPathNode", () => {
        node.append = function(child) {
            ok(child instanceof MultiPathNode);
        };

        node.load([new MultiPath()]);
    });

    it("load appends TextNode", () => {
        node.append = function(child) {
            ok(child instanceof TextNode);
        };

        node.load([new Text()]);
    });

    it("load appends CircleNode", () => {
        node.append = function(child) {
            ok(child instanceof CircleNode);
        };

        node.load([new Circle()]);
    });

    it("load appends ArcNode", () => {
        node.append = function(child) {
            ok(child instanceof ArcNode);
        };

        node.load([new Arc()]);
    });

    it("load appends ImageNode", () => {
        node.append = function(child) {
            ok(child instanceof ImageNode);
        };

        node.load([new Image()]);
    });

    it("load appends child nodes", () => {
        let parentGroup = new Group();
        let childGroup = new Group();
        parentGroup.append(childGroup);

        node.load([parentGroup]);

        ok(node.childNodes[0].childNodes[0] instanceof Node);
    });

    it("load invalidates node", () => {
        node.invalidate = function() { ok(true); };
        node.load([new Group()]);
    });
});

describe('Node / source observer', () => {

    let node;
    let srcElement;

    beforeEach(() => {
        srcElement = new Element();
        node = new Node(srcElement);
    });

    it("Adds srcElement observer", () => {
        equal(srcElement.observers()[0], node);
    });

    it("clear removes srcElement observer", () => {
        node.clear();
        equal(srcElement.observers().length, 0);
    });

});

function clipTests(TShape, TNode, nodeName) {

    describe("Clip Tests / " + nodeName, () => {

        let shape;
        let node;
        let clip;

        beforeEach(() => {
            clip = new Path();

            shape = new TShape();
            shape.clip(clip);

            node = new TNode(shape);
        });

        it("inits clip", () => {
            equal(node.clip, clip);
        });

        it("adds clip observer", () => {
            ok(clip.observers().indexOf(node) != -1);
        });

        it("clear removes clip", () => {
            node.clear();
            equal(node.clip, undefined);
        });

        it("clear removes clip observer", () => {
            node.clear();
            equal(clip.observers().indexOf(node), -1);
        });

        it("sets clip", () => {
            let context = mockContext({
                clip: function() {
                    ok(true);
                }
            });
            node.renderTo(context);
        });

        it("sets clip after transformation", () => {
            shape.transform(transform());
            let isSetTransformation = false;
            let context = mockContext({
                clip: function() {
                    ok(isSetTransformation);
                },
                transform: function() {
                    isSetTransformation = true;
                }
            });
            node.renderTo(context);
        });
    });
}

clipTests(Group, GroupNode, "GroupNode");

describe('GroupNode', () => {

    let group;
    let node;

    beforeEach(() => {
        group = new Group();
        node = new GroupNode(group);
    });

    it("renders transform", () => {
        group.transform(new Matrix(1e-6, 2, 3, 4, 5, 6));

        let ctx = mockContext({
            transform: function(a, b, c, d, e, f) {
                equal([a, b, c, d, e, f], [1e-6, 2, 3, 4, 5, 6]);
            }
        });

        node.load([group]);
        node.renderTo(ctx);
    });

    it("does not render transform if not set", () => {
        let ctx = mockContext();
        spyOn(ctx, "transform");

        node.renderTo(ctx);

        expect(ctx.transform).not.toHaveBeenCalled();
    });

    it("renders opacity", () => {
        group.opacity(0.5);

        let ctx = mockContext();
        node.renderTo(ctx);

        equal(ctx.globalAlpha, 0.5);
    });

    it("multiplies opacity with parent opacity", () => {
        group.opacity(0.5);

        let childGroup = new Group({ opacity: 0.5 });
        node.load([childGroup]);

        let ctx = mockContext({
            restore: $.noop
        });
        node.renderTo(ctx);

        equal(ctx.globalAlpha, 0.25);
    });

    it("does not render if source group is not visible", () => {
        let ctx = mockContext();
        spyOn(ctx, "save");

        group.visible(false);

        node.renderTo(ctx);

        expect(ctx.save).not.toHaveBeenCalled();
    });

    it("does not render children if group is not visible", () => {
        let childGroup = new Group({ visible: false });
        node.load([childGroup]);
        spyOn(node.childNodes[0], "renderTo");

        let ctx = mockContext();
        node.renderTo(ctx);

        expect(node.childNodes[0].renderTo).not.toHaveBeenCalled();
    });

});

function paintTests(TShape, TNode, nodeName) {
    let shape;
    let node;

    describe("Paint Tests / " + nodeName, () => {

        beforeEach(() => {
            shape = new TShape()
                .stroke("red", 2).fill("blue");

            node = new TNode(shape);
        });

        it("renders global opacity", () => {
            shape.opacity(0.5);

            let ctx = mockContext();
            node.renderTo(ctx);

            equal(ctx.globalAlpha, 0.5);
        });

        it("renders stroke", () => {
            let ctx = mockContext({
                stroke: function() {
                    equal(ctx.strokeStyle, "red");
                }
            });

            node.renderTo(ctx);
        });

        it("does not render stroke if set to 'none'", () => {
            shape.options.set("stroke.color", "none");

            let ctx = mockContext();

            spyOn(ctx, "stroke");

            node.renderTo(ctx);

            expect(ctx.stroke).not.toHaveBeenCalled();
        });

        it("does not render stroke if set to 'transparent'", () => {
            let callsCount = 0;
            shape.options.set("stroke.color", "transparent");

            let ctx = mockContext();
            spyOn(ctx, "stroke");

            node.renderTo(ctx);

            expect(ctx.stroke).not.toHaveBeenCalled();
        });

        it("does not render stroke if set to ''", () => {
            shape.options.set("stroke.color", "");

            let ctx = mockContext();

            spyOn(ctx, "stroke");

            node.renderTo(ctx);

            expect(ctx.stroke).not.toHaveBeenCalled();
        });

        it("does not render stroke if width is not positive", () => {
            shape.options.set("stroke.width", 0);

            let ctx = mockContext();
            spyOn(ctx, "stroke");

            node.renderTo(ctx);

            expect(ctx.stroke).not.toHaveBeenCalled();
        });

        it("renders stroke width", () => {
            let ctx = mockContext({
                stroke: function() {
                    equal(ctx.lineWidth, 2);
                }
            });

            node.renderTo(ctx);
        });

        it("renders stroke opacity", () => {
            shape.options.set("stroke.opacity", 0.5);

            let ctx = mockContext({
                stroke: function() {
                    equal(ctx.globalAlpha, 0.5);
                }
            });

            node.renderTo(ctx);
        });

        it("multiplies stroke opacity with global opacity", () => {
            shape.options.set("stroke.opacity", 0.5);
            shape.opacity(0.5);

            let ctx = mockContext({
                stroke: function() {
                    equal(ctx.globalAlpha, 0.25);
                }
            });

            node.renderTo(ctx);
        });

        it("does not render stroke opacity if not set", () => {
            let ctx = mockContext({
                stroke: function() {
                    equal(ctx.globalAlpha, undefined);
                }
            });

            node.renderTo(ctx);
        });

        it("renders stroke dashType", () => {
            shape.options.set("stroke.dashType", "dot");

            let ctx = mockContext({
                setLineDash: function(arr) {
                    equal(arr, [1.5, 3.5]);
                }
            });

            node.renderTo(ctx);
        });

        it("does not render stroke dashType if not set", () => {
            let ctx = mockContext({
                setLineDash: () => {}
            });
            spyOn(ctx, "setLineDash");

            node.renderTo(ctx);

            expect(ctx.setLineDash).not.toHaveBeenCalled();
        });

        it("renders fill", () => {
            let ctx = mockContext({
                fill: function() {
                    equal(ctx.fillStyle, "blue");
                }
            });

            node.renderTo(ctx);
        });

        it("renders fill opacity", () => {
            shape.options.set("fill.opacity", 0.5);

            let ctx = mockContext({
                fill: function() {
                    equal(ctx.globalAlpha, 0.5);
                }
            });

            node.renderTo(ctx);
        });

        it("multiplies fill opacity with global opacity", () => {
            shape.options.set("fill.opacity", 0.5);
            shape.opacity(0.5);

            let ctx = mockContext({
                fill: function() {
                    equal(ctx.globalAlpha, 0.25);
                }
            });

            node.renderTo(ctx);
        });

        it("does not render fill if not set", () => {
            shape.options.set("fill", null);

            let ctx = mockContext();

            spyOn(ctx, "fill");

            node.renderTo(ctx);

            expect(ctx.fill).not.toHaveBeenCalled();
        });

        it("does not render fill if set to 'none'", () => {
            shape.options.set("fill.color", "none");

            let ctx = mockContext();
            spyOn(ctx, "fill");

            node.renderTo(ctx);

            expect(ctx.fill).not.toHaveBeenCalled();
        });

        it("does not render fill if set to 'transparent'", () => {
            shape.options.set("fill.color", "transparent");

            let ctx = mockContext();
            spyOn(ctx, "fill");

            node.renderTo(ctx);

            expect(ctx.fill).not.toHaveBeenCalled();
        });

        it("does not render fill if set to ''", () => {
            shape.options.set("fill.color", "");

            let ctx = mockContext();
            spyOn(ctx, "fill");

            node.renderTo(ctx);

            expect(ctx.fill).not.toHaveBeenCalled();
        });

        it("multiplies stroke and fill opacity with global opacity", () => {
            shape.options.set("stroke.opacity", 0.5);
            shape.options.set("fill.opacity", 0.5);
            shape.opacity(0.5);

            let ctx = mockContext({
                fill: function() {
                    equal(ctx.globalAlpha, 0.25);
                },
                stroke: function() {
                    equal(ctx.globalAlpha, 0.25);
                }
            });

            node.renderTo(ctx);
        });
    });


    describe("Paint Tests / " + nodeName + " / gradient fill", () => {

        class MockGradient {
            constructor() {
                this.stops = [];
            }

            addColorStop(offset, color) {
                this.stops.push({
                    offset: offset,
                    color: color
                });
            }
        }

        function createGradient() {
           let gradientFill = new MockGradient();
           gradientFill.params = arguments;
           return gradientFill;
        }

        function renderGradient(gradient) {
            let fillsContext = false;
            let transformation;
            let ctx = mockContext({
                transform: function() {
                    transformation = new Matrix();
                    transformation.constructor.apply(transformation, arguments);
                },
                fill: function() {
                    fillsContext = true;
                },
                createLinearGradient: createGradient,
                createRadialGradient: createGradient
            });

            shape.fill(gradient);
            node.renderTo(ctx);
            return {
                fillsContext: fillsContext,
                transformation: transformation,
                gradient: ctx.fillStyle
            };
        }

        beforeEach(() => {
            shape = new TShape();
            shape.rawBBox = function() {
                return new GeometryRect([10, 20], [100, 200]);
            };
            node = new TNode(shape);
        });

        it("renders linear gradient", () => {
            let result = renderGradient(new LinearGradient({
                start: [0.1, 0.2],
                end: [0.5, 0.6]
            }));
            let params = result.gradient.params;
            ok(result.fillsContext);
            ok(result.gradient);
            equal(params[0], 0.1);
            equal(params[1], 0.2);
            equal(params[2], 0.5);
            equal(params[3], 0.6);
        });

        it("renders radial gradient", () => {
            let result = renderGradient(new RadialGradient({
                center: [10, 20],
                radius: 0.5
            }));
            let params = result.gradient.params;
            ok(result.fillsContext);
            ok(result.gradient);
            equal(params[0], 10);
            equal(params[1], 20);
            equal(params[2], 0);
            equal(params[3], 10);
            equal(params[4], 20);
            equal(params[5], 0.5);
        });

        it("sets transformation based on raw bounding box", () => {
            let result = renderGradient(new LinearGradient());
            compareMatrices(result.transformation, new Matrix(100, 0, 0, 200, 10, 20));
        });

        it("does not set transformation if userSpace is true", () => {
            let result = renderGradient(new LinearGradient({
                userSpace: true
            }));
            ok(!result.transformation);
        });

        it("adds gradient stops", () => {
            let result = renderGradient(new LinearGradient({
                stops: [[
                    0.1, "red", 0.5
                ], [
                    0.7, "blue", 1
                ]]
            }));

            let expectedStops = [{
                offset: 0.1,
                color: "rgba(255,0,0,0.5)"
            }, {
                offset: 0.7,
                color: "rgb(0,0,255)"
            }];
            equal(result.gradient.stops, expectedStops);
        });
    });
}

paintTests(Path, PathNode, "PathNode");
clipTests(Path, PathNode, "PathNode");

describe('PathNode', () => {

    let path,
        pathNode;

    beforeEach(() => {
        path = new Path({
            stroke: {
                color: "red",
                width: 2
            },
            fill: {
                color: "blue"
            }
        });

        pathNode = new PathNode(path);
    });

    it("saves and restores context", () => {
        pathNode.renderTo(mockContext({
            save: function() {
                ok(true);
            },
            restore: function() {
                ok(true);
            }
        }));
    });

    it("renders straight segments", () => {
        path.moveTo(0, 0).lineTo(10, 20);

        pathNode.renderTo(mockContext({
            beginPath: function() {
                ok(true);
            },
            moveTo: function(x, y) {
                equal([x, y], [0, 0]);
            },
            lineTo: function(x, y) {
                equal([x, y], [10, 20]);
            }
        }));
    });

    it("renders closed paths", () => {
        path.moveTo(0, 0).lineTo(10, 20).close();

        pathNode.renderTo(mockContext({
            closePath: function() {
                ok(true);
            }
        }));
    });

    it("renders curve", () => {
        path.moveTo(0, 0).curveTo(Point.create(10, 10), Point.create(20, 10), Point.create(30, 0));

        let order = 0;
        pathNode.renderTo(mockContext({
            moveTo: function(x, y) {
                equal(order++, 0, "#");
                equal([x, y], [0, 0]);
            },
            bezierCurveTo: function(cp1x, cp1y, cp2x, cp2y, x, y) {
                equal(order++, 1, "#");
                equal([cp1x, cp1y, cp2x, cp2y, x, y], [10, 10, 20, 10, 30, 0]);
            }
        }));
    });

    it("switches between line and curve", () => {
        path.moveTo(0, 0).lineTo(5, 5).curveTo(Point.create(10, 10), Point.create(20, 10), Point.create(30, 0));

        let order = 0;
        pathNode.renderTo(mockContext({
            moveTo: function(x, y) {
                equal(order++, 0, "#");
                equal([x, y], [0, 0]);
            },
            lineTo: function(x, y) {
                equal(order++, 1, "#");
                equal([x, y], [5, 5]);
            },
            bezierCurveTo: function(cp1x, cp1y, cp2x, cp2y, x, y) {
                equal(order++, 2, "#");
                equal([cp1x, cp1y, cp2x, cp2y, x, y],
                          [10, 10, 20, 10, 30, 0]);
            }
        }));
    });

    it("switches between curve and line", () => {
        path.moveTo(0, 0).curveTo(Point.create(10, 10), Point.create(20, 10), Point.create(30, 0)).lineTo(40, 10);

        let order = 0;
        pathNode.renderTo(mockContext({
            moveTo: function(x, y) {
                equal(order++, 0, "#");
                equal([x, y], [0, 0]);
            },
            bezierCurveTo: function(cp1x, cp1y, cp2x, cp2y, x, y) {
                equal(order++, 1, "#");
                equal([cp1x, cp1y, cp2x, cp2y, x, y],
                          [10, 10, 20, 10, 30, 0]);
            },
            lineTo: function(x, y) {
                equal(order++, 2, "#");
                equal([x, y], [40, 10]);
            }
        }));
    });

    it("does not render empty path", () => {
        let moveCalls = 0;
        pathNode.renderTo(mockContext({
            moveTo: function() {
                moveCalls++;
            }
        }));
        same(moveCalls, 0);
    });

    it("renders stroke dashType (legacy)", () => {
        path.options.set("stroke.dashType", "dot");

        let ctx = mockContext({
            stroke: function() {
                equal(ctx.mozDash, [1.5, 3.5]);
                equal(ctx.webkitLineDash, ctx.mozDash);
            }
        });

        pathNode.renderTo(ctx);
    });

    it("renders stroke lineJoin", () => {
        path.options.set("stroke.lineJoin", "round");

        let ctx = mockContext({
            stroke: function() {
                equal(ctx.lineJoin, "round");
            }
        });

        pathNode.renderTo(ctx);
    });

    it("renders stroke linecap", () => {
        path.options.set("stroke.lineCap", "round");

        let ctx = mockContext({
            stroke: function() {
                equal(ctx.lineCap, "round");
            }
        });

        pathNode.renderTo(ctx);
    });

    it("overrides stroke linecap when dashType is set", () => {
        path.options.set("stroke.lineCap", "round");
        path.options.set("stroke.dashType", "dot");

        let ctx = mockContext({
            stroke: function() {
                equal(ctx.lineCap, "butt");
            }
        });

        pathNode.renderTo(ctx);
    });

    it("renders stroke linecap when dashType is set to solid", () => {
        path.options.set("stroke.lineCap", "round");
        path.options.set("stroke.dashType", "solid");

        let ctx = mockContext({
            stroke: function() {
                equal(ctx.lineCap, "round");
            }
        });

        pathNode.renderTo(ctx);
    });

    it("renders transform", () => {
        path.transform(new Matrix(1e-6, 2, 3, 4, 5, 6));

        let ctx = mockContext({
            transform: function(a, b, c, d, e, f) {
                equal([a, b, c, d, e, f], [1e-6, 2, 3, 4, 5, 6]);
            }
        });

        pathNode.renderTo(ctx);
    });

    it("does not render transform if not set", () => {
        let transformCalls = 0;
        let ctx = mockContext({
            transform: function(mx) {
                transformCalls++;
            }
        });

        pathNode.renderTo(ctx);
        same(transformCalls, 0);
    });
});

paintTests(MultiPath, MultiPathNode, "MultiPathNode");
clipTests(MultiPath, MultiPathNode, "MultiPathNode");

describe('MultiPathNode', () => {

    let multiPath,
        multiPathNode;

    beforeEach(() => {
        multiPath = new MultiPath();
        multiPathNode = new MultiPathNode(multiPath);
    });

    it("renders composite paths", () => {
        multiPath
            .moveTo(0, 0).lineTo(10, 20)
            .moveTo(10, 10).lineTo(10, 20);

        let order = 0;
        multiPathNode.renderTo(mockContext({
            moveTo: function(x, y) {
                if (order === 0) {
                    equal([x, y], [0, 0]);
                } else if (order === 2) {
                    equal([x, y], [10, 10]);
                }

                order++;
            },
            lineTo: function(x, y) {
                equal([x, y], [10, 20]);

                order++;
            }
        }));
    });

});

paintTests(Circle, CircleNode, "CircleNode");
clipTests(Circle, CircleNode, "CircleNode");

describe('CircleNode', () => {

    let circle,
        circleNode;

    beforeEach(() => {
            let geometry = new GeometryCircle(new Point(10, 20), 30);
            circle = new Circle(geometry);
            circleNode = new CircleNode(circle);
    });

    it("renders arc", () => {
        circleNode.renderTo(mockContext({
            arc: function(x, y, r, start, end) {
                equal([x, y, r, start, end],
                          [10, 20, 30, 0, Math.PI * 2]);
            }
        }));
    });
});

paintTests(Arc, ArcNode, "ArcNode");
clipTests(Arc, ArcNode, "ArcNode");

describe('ArcNode', () => {

    let arc,
        arcNode;

    beforeEach(() => {
        let geometry = new GeometryArc(new Point(10, 20), {
            radiusX: 10,
            radiusY: 10,
            startAngle: 0,
            endAngle: 90
        });
        arc = new Arc(geometry);
        arcNode = new ArcNode(arc);
    });

    it("renders equivalent curve", () => {
        let order = 0;
        arcNode.renderTo(mockContext({
            moveTo: function(x, y) {
                equal(order++, 0, "#");
                equal([x, y], [20, 20]);
            },
            bezierCurveTo: function(cp1x, cp1y, cp2x, cp2y, x, y) {
                let expected;
                if (order++ === 1) {
                    expected = [20, 22.6, 18.9, 25.2, 17, 27];
                } else {
                    expected = [15.2, 28.9, 12.6, 30, 10, 30];
                }

                arrayClose([cp1x, cp1y, cp2x, cp2y, x, y], expected, 0.3);
            }
        }));
    });
});

paintTests(Text, TextNode, "TextNode");
clipTests(Text, TextNode, "TextNode");

describe('TextNode', () => {

    let text;
    let textNode;

    beforeEach(() => {
        text = new Text("Foo", new Point(10, 20), { font: "arial" });
        text.measure = function() {
            return {
                width: 20, height: 10, baseline: 15
            };
        };

        textNode = new TextNode(text);
    });

    it("renders position accounting for baseline", () => {
        textNode.renderTo(mockContext({
            fillText: function(content, x, y) {
                equal([x, y], [10, 35]);
            }
        }));
    });

    it("renders content", () => {
        textNode.renderTo(mockContext({
            fillText: function(content) {
                equal(content, "Foo");
            }
        }));
    });

    it("sets font", () => {
        let ctx = mockContext({
            fillText: function(content) {
                equal(ctx.font, "arial");
            }
        });

        textNode.renderTo(ctx);
    });

    it("does not fill text if no fill is set",() => {
        text.options.set("fill", null);

        let ctx = mockContext();
        spyOn(ctx, "fillText");

        textNode.renderTo(ctx);

        expect(ctx.fillText).not.toHaveBeenCalled();
    });

    it("setting content invalidates node", () => {
        textNode.invalidate = function() {
            ok(true);
        };

        text.content("Bar");
    });

    it("strokes text", () => {
        text.stroke("red", 1);

        let ctx = mockContext({
            strokeText: function(content, x, y) {
                equal(content, "Foo");
                equal([x, y], [10, 35]);
            }
        });

        textNode.renderTo(ctx);
    });

    it("does not stroke text if no stroke is set", () => {
        let ctx = mockContext();
        spyOn(ctx, "strokeText");

        textNode.renderTo(ctx);

        expect(ctx.strokeText).not.toHaveBeenCalled();
    });

    it("renders transform", () => {
        text.transform(new Matrix(1e-6, 2, 3, 4, 5, 6));

        let ctx = mockContext({
            transform: function(a, b, c, d, e, f) {
                equal([a, b, c, d, e, f], [1e-6, 2, 3, 4, 5, 6]);
            }
        });

        textNode.renderTo(ctx);
    });

    it("does not render transform if not set", () => {
        let ctx = mockContext();
        spyOn(ctx, "transform");

        textNode.renderTo(ctx);

        expect(ctx.transform).not.toHaveBeenCalled();
    });

    it("creates new path", () => {
        let ctx = mockContext({
            beginPath: function(mx) {
                ok(true);
            }
        });

        textNode.renderTo(ctx);
    });
});

class LoadedImageNode extends ImageNode {
    constructor(srcElement) {
        super(srcElement);
        this.loading.resolve();
    }
}

clipTests(Image, LoadedImageNode, "ImageNode");

describe('ImageNode', () => {

    let image;
    let imageNode;

    beforeEach(() => {
        image = new Image("Foo", new GeometryRect(new Point(10, 20), [90, 80]));
        imageNode = new ImageNode(image);
        imageNode.loading.resolve();
    });

    it("renders position", () => {
        imageNode.renderTo(mockContext({
            drawImage: function(img, x, y) {
                equal([x, y], [10, 20]);
            }
        }));
    });

    it("renders size", () => {
        imageNode.renderTo(mockContext({
            drawImage: function(img, x, y, width, height) {
                equal([width, height], [90, 80]);
            }
        }));
    });

    it("setting src resets loading state", () => {
        image.src("Bar");
        equal(imageNode.loading.state, "pending");
    });

    it("load handler resolves loading state", () => {
        imageNode.onLoad();
        equal(imageNode.loading.state, "resolved");
    });

    it("error handler rejects loading state", () => {
        image.src("Baz");
        imageNode.onError();
        equal(imageNode.loading.state, "rejected");
    });

    it("load handler invalidates node", () => {
        imageNode.invalidate = function() {
            ok(true);
        };

        imageNode.onLoad();
    });

    it("geometryChange invalidates node", () => {
        imageNode.invalidate = function() {
            ok(true);
        };

        image.rect().origin.setX(20);
    });

    it("renders transform", () => {
        image.transform(new Matrix(1e-6, 2, 3, 4, 5, 6));

        let ctx = mockContext({
            transform: function(a, b, c, d, e, f) {
                equal([a, b, c, d, e, f], [1e-6, 2, 3, 4, 5, 6]);
            }
        });

        imageNode.renderTo(ctx);
    });

    it("does not render transform if not set", () => {
        let ctx = mockContext();
        spyOn(ctx, "transform");

        imageNode.renderTo(ctx);

        expect(ctx.transform).not.toHaveBeenCalled();
    });
});

paintTests(Rect, RectNode, "RectNode");
clipTests(Rect, RectNode, "RectNode");

describe('RectNode', () => {

    let rect,
        rectNode;

    beforeEach(() => {
        let geometry = new GeometryRect([10,20],[30,40]);
        rect = new Rect(geometry);
        rectNode = new RectNode(rect);
    });

    it("renders rect", () => {
        rectNode.renderTo(mockContext({
            rect: function(x, y, width, height) {
                equal(x, 10);
                equal(y, 20);
                equal(width, 30);
                equal(height, 40);
            }
        }));
    });

});

describe('exportImage', () => {

    let group;


    beforeEach(() => {
        group = new Group();
    });

    it("exports group", () => {
        exportImage(group).then(function(data) {
            contains(data, "data:image/png;base64,");
        });
    });

    it("exports with auto size", () => {
        let rect = new GeometryRect([0, 0], [100, 100]);
        group.append(Path.fromRect(rect));

        exportImage(group).then(function(auto) {
            exportImage(group, { width: "100px", height: "100px" }).then(function(manual) {
                equal(auto, manual);
            });
        });
    });

    it("exports with set size", () => {
        exportImage(group).then(function(small) {
            exportImage(group, { width: "1000px", height: "500px" }).then(function(large) {
                ok(large.length > small.length);
            });
        });
    });

    it("waits for images to load", () => {
        let image = new Image("foo", new GeometryRect([0, 0], [100, 100]));
        group.append(image);

        let loaded = false;
        exportImage(group).then(function(small) {
            ok(loaded);
        });

        loaded = true;
        image._observers[0].loading.resolve();
    });

    it("forces invalidate", () => {
        let surface = new Surface($("<div />")[0]);
        surface._root._invalidate = function() {
            ok(true);
        };

        surface.draw(group);
        surface.image();

        surface.destroy();
    });

    it("throws an error if the canvas becomes tainted", (done) => {
        let image = new Image("http://kendobuild/pesho.jpg", new GeometryRect([0, 0], [100, 100]));
        group.append(image);

        exportImage(group).then(function() {
            ok(false, "Should fail");
            done();
        }).catch(function(e) {
            contains(e.message, "Unable to load");
            contains(e.message, "pesho.jpg");
            done();
        });
    });

    /*
    it("does not throw an error if image is CORS-enabled", (done) => {
        let image = new Image("http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png", new GeometryRect([0, 0], [100, 100]));
        group.append(image);

        exportImage(group).then(function() {
            ok(true);
            done();
        }).catch(function() {
            ok(false);
            done();
        });
    }, 10000);
    */

    it("discards target origin", () => {
        let text = new Text("Foo", [10, 10]);
        group.append(text);

        exportImage(group).then(function(withOrigin) {
            text.position([0, 0]);
            exportImage(group).then(function(noOrigin) {
                equal(withOrigin, noOrigin);
            });
        });
    });

    it("does not reparent target", () => {
        let parent = new Group();
        parent.append(group);
        group.append(new Text("Foo", [10, 10]));

        exportImage(group).then(function() {
            ok(group.parent === parent);
        });
    });

});
