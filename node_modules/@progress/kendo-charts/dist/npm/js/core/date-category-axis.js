module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(479);


/***/ },

/***/ 60:
/***/ function(module, exports) {

	module.exports = require("../common/constants");

/***/ },

/***/ 107:
/***/ function(module, exports) {

	module.exports = require("./constants");

/***/ },

/***/ 111:
/***/ function(module, exports) {

	module.exports = require("../common/set-default-options");

/***/ },

/***/ 112:
/***/ function(module, exports) {

	module.exports = require("../common/deep-extend");

/***/ },

/***/ 113:
/***/ function(module, exports) {

	module.exports = require("../common/defined");

/***/ },

/***/ 115:
/***/ function(module, exports) {

	module.exports = require("../common/sparse-array-limits");

/***/ },

/***/ 205:
/***/ function(module, exports) {

	module.exports = require("../common/last");

/***/ },

/***/ 302:
/***/ function(module, exports) {

	module.exports = require("../date-utils/to-date");

/***/ },

/***/ 459:
/***/ function(module, exports) {

	module.exports = require("./axis-label");

/***/ },

/***/ 468:
/***/ function(module, exports) {

	module.exports = require("../common/in-array");

/***/ },

/***/ 474:
/***/ function(module, exports) {

	module.exports = require("../common/round");

/***/ },

/***/ 475:
/***/ function(module, exports) {

	module.exports = require("../common/limit-value");

/***/ },

/***/ 479:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _categoryAxis = __webpack_require__(480);

	var _categoryAxis2 = _interopRequireDefault(_categoryAxis);

	var _axisLabel = __webpack_require__(459);

	var _axisLabel2 = _interopRequireDefault(_axisLabel);

	var _constants = __webpack_require__(60);

	var _round = __webpack_require__(474);

	var _round2 = _interopRequireDefault(_round);

	var _deepExtend = __webpack_require__(112);

	var _deepExtend2 = _interopRequireDefault(_deepExtend);

	var _last = __webpack_require__(205);

	var _last2 = _interopRequireDefault(_last);

	var _defined = __webpack_require__(113);

	var _defined2 = _interopRequireDefault(_defined);

	var _inArray = __webpack_require__(468);

	var _inArray2 = _interopRequireDefault(_inArray);

	var _limitValue = __webpack_require__(475);

	var _limitValue2 = _interopRequireDefault(_limitValue);

	var _sparseArrayLimits = __webpack_require__(115);

	var _sparseArrayLimits2 = _interopRequireDefault(_sparseArrayLimits);

	var _setDefaultOptions = __webpack_require__(111);

	var _setDefaultOptions2 = _interopRequireDefault(_setDefaultOptions);

	var _constants2 = __webpack_require__(481);

	var _dateComparer = __webpack_require__(482);

	var _dateComparer2 = _interopRequireDefault(_dateComparer);

	var _toDate = __webpack_require__(302);

	var _toDate2 = _interopRequireDefault(_toDate);

	var _addTicks = __webpack_require__(483);

	var _addTicks2 = _interopRequireDefault(_addTicks);

	var _addDuration = __webpack_require__(484);

	var _addDuration2 = _interopRequireDefault(_addDuration);

	var _dateDiff = __webpack_require__(485);

	var _dateDiff2 = _interopRequireDefault(_dateDiff);

	var _absoluteDateDiff = __webpack_require__(486);

	var _absoluteDateDiff2 = _interopRequireDefault(_absoluteDateDiff);

	var _dateIndex = __webpack_require__(487);

	var _dateIndex2 = _interopRequireDefault(_dateIndex);

	var _dateEquals = __webpack_require__(488);

	var _dateEquals2 = _interopRequireDefault(_dateEquals);

	var _toTime = __webpack_require__(489);

	var _toTime2 = _interopRequireDefault(_toTime);

	var _floorDate = __webpack_require__(490);

	var _floorDate2 = _interopRequireDefault(_floorDate);

	var _constants3 = __webpack_require__(107);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var AUTO = "auto";
	var BASE_UNITS = [_constants2.MILLISECONDS, _constants2.SECONDS, _constants2.MINUTES, _constants2.HOURS, _constants2.DAYS, _constants2.WEEKS, _constants2.MONTHS, _constants2.YEARS];
	var FIT = "fit";

	var DateCategoryAxis = function (_CategoryAxis) {
	    _inherits(DateCategoryAxis, _CategoryAxis);

	    function DateCategoryAxis() {
	        var axisOptions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	        _classCallCheck(this, DateCategoryAxis);

	        var _this = _possibleConstructorReturn(this, (DateCategoryAxis.__proto__ || Object.getPrototypeOf(DateCategoryAxis)).call(this, axisOptions));

	        var options = _this.options;

	        options = (0, _deepExtend2.default)({
	            roundToBaseUnit: true
	        }, options, {
	            categories: (0, _toDate2.default)(options.categories),
	            min: (0, _toDate2.default)(options.min),
	            max: (0, _toDate2.default)(options.max)
	        });

	        options.userSetBaseUnit = options.userSetBaseUnit || options.baseUnit;
	        options.userSetBaseUnitStep = options.userSetBaseUnitStep || options.baseUnitStep;

	        if (options.categories && options.categories.length > 0) {
	            var baseUnit = (options.baseUnit || "").toLowerCase();
	            var useDefault = baseUnit !== FIT && !(0, _inArray2.default)(baseUnit, BASE_UNITS);

	            if (useDefault) {
	                options.baseUnit = _this.defaultBaseUnit(options);
	            }

	            if (baseUnit === FIT || options.baseUnitStep === AUTO) {
	                _this.autoBaseUnit(options);
	            }

	            _this._groupsStart = (0, _addDuration2.default)(options.categories[0], 0, options.baseUnit, options.weekStartDay);

	            _this.groupCategories(options);
	        } else {
	            options.baseUnit = options.baseUnit || _constants2.DAYS;
	        }

	        _this.options = options;
	        return _this;
	    }

	    _createClass(DateCategoryAxis, [{
	        key: '_initCategories',
	        value: function _initCategories() {}
	    }, {
	        key: 'shouldRenderNote',
	        value: function shouldRenderNote(value) {
	            var range = this.range();
	            var categories = this.options.categories || [];

	            return (0, _dateComparer2.default)(value, range.min) >= 0 && (0, _dateComparer2.default)(value, range.max) <= 0 && categories.length;
	        }
	    }, {
	        key: 'parseNoteValue',
	        value: function parseNoteValue(value) {
	            return (0, _toDate2.default)(value);
	        }
	    }, {
	        key: 'translateRange',
	        value: function translateRange(delta) {
	            var options = this.options;
	            var baseUnit = options.baseUnit;
	            var weekStartDay = options.weekStartDay;
	            var vertical = options.vertical;

	            var lineBox = this.lineBox();
	            var size = vertical ? lineBox.height() : lineBox.width();
	            var range = this.range();
	            var scale = size / (range.max - range.min);
	            var offset = (0, _round2.default)(delta / scale, _constants.DEFAULT_PRECISION);

	            if (range.min && range.max) {
	                var from = (0, _addTicks2.default)(options.min || range.min, offset);
	                var to = (0, _addTicks2.default)(options.max || range.max, offset);

	                range = {
	                    min: (0, _addDuration2.default)(from, 0, baseUnit, weekStartDay),
	                    max: (0, _addDuration2.default)(to, 0, baseUnit, weekStartDay)
	                };
	            }

	            return range;
	        }
	    }, {
	        key: 'scaleRange',
	        value: function scaleRange(delta) {
	            var rounds = Math.abs(delta);
	            var result = this.range();
	            var _result = result;
	            var from = _result.min;
	            var to = _result.max;


	            if (from && to) {
	                while (rounds--) {
	                    var range = (0, _dateDiff2.default)(from, to);
	                    var step = Math.round(range * 0.1);
	                    if (delta < 0) {
	                        from = (0, _addTicks2.default)(from, step);
	                        to = (0, _addTicks2.default)(to, -step);
	                    } else {
	                        from = (0, _addTicks2.default)(from, -step);
	                        to = (0, _addTicks2.default)(to, step);
	                    }
	                }

	                result = { min: from, max: to };
	            }

	            return result;
	        }
	    }, {
	        key: 'defaultBaseUnit',
	        value: function defaultBaseUnit(options) {
	            var categories = options.categories;
	            var count = (0, _defined2.default)(categories) ? categories.length : 0;
	            var minDiff = _constants.MAX_VALUE;
	            var lastCategory = void 0,
	                unit = void 0;

	            for (var categoryIx = 0; categoryIx < count; categoryIx++) {
	                var category = categories[categoryIx];

	                if (category && lastCategory) {
	                    var diff = (0, _absoluteDateDiff2.default)(category, lastCategory);
	                    if (diff > 0) {
	                        minDiff = Math.min(minDiff, diff);

	                        if (minDiff >= _constants2.TIME_PER_YEAR) {
	                            unit = _constants2.YEARS;
	                        } else if (minDiff >= _constants2.TIME_PER_MONTH - _constants2.TIME_PER_DAY * 3) {
	                            unit = _constants2.MONTHS;
	                        } else if (minDiff >= _constants2.TIME_PER_WEEK) {
	                            unit = _constants2.WEEKS;
	                        } else if (minDiff >= _constants2.TIME_PER_DAY) {
	                            unit = _constants2.DAYS;
	                        } else if (minDiff >= _constants2.TIME_PER_HOUR) {
	                            unit = _constants2.HOURS;
	                        } else if (minDiff >= _constants2.TIME_PER_MINUTE) {
	                            unit = _constants2.MINUTES;
	                        } else {
	                            unit = _constants2.SECONDS;
	                        }
	                    }
	                }

	                lastCategory = category;
	            }

	            return unit || _constants2.DAYS;
	        }
	    }, {
	        key: '_categoryRange',
	        value: function _categoryRange(categories) {
	            var range = categories._range;
	            if (!range) {
	                range = categories._range = (0, _sparseArrayLimits2.default)(categories);
	            }

	            return range;
	        }
	    }, {
	        key: 'totalRange',
	        value: function totalRange() {
	            return {
	                min: 0,
	                max: this.options.categories.length
	            };
	        }
	    }, {
	        key: 'rangeIndices',
	        value: function rangeIndices() {
	            var options = this.options;
	            var categories = options.categories;
	            var baseUnit = options.baseUnit;
	            var _options$baseUnitStep = options.baseUnitStep;
	            var baseUnitStep = _options$baseUnitStep === undefined ? 1 : _options$baseUnitStep;

	            var categoryLimits = this.categoriesRange();
	            var min = (0, _toDate2.default)(options.min || categoryLimits.min);
	            var max = (0, _toDate2.default)(options.max || categoryLimits.max);
	            var minIdx = 0,
	                maxIdx = 0;

	            if (categories.length) {
	                minIdx = (0, _dateIndex2.default)(min, categories[0], baseUnit, baseUnitStep);
	                maxIdx = (0, _dateIndex2.default)(max, categories[0], baseUnit, baseUnitStep);

	                if (options.roundToBaseUnit) {
	                    minIdx = Math.floor(minIdx);
	                    maxIdx = options.justified ? Math.floor(maxIdx) : Math.ceil(maxIdx);
	                }
	            }

	            return { min: minIdx, max: maxIdx };
	        }
	    }, {
	        key: 'labelsRange',
	        value: function labelsRange() {
	            var options = this.options;
	            var labelOptions = options.labels;
	            var range = this.rangeIndices();
	            var min = Math.floor(range.min);
	            var max = Math.ceil(range.max);

	            return {
	                min: min + labelOptions.skip,
	                max: options.categories.length ? max + (options.justified ? 1 : 0) : 0
	            };
	        }
	    }, {
	        key: 'categoriesRange',
	        value: function categoriesRange() {
	            var options = this.options;
	            var range = this._categoryRange(options.srcCategories || options.categories);

	            var max = (0, _toDate2.default)(range.max);
	            if (!options.justified && (0, _dateEquals2.default)(max, this._roundToTotalStep(max, options, false))) {
	                max = this._roundToTotalStep(max, options, true, true);
	            }
	            return {
	                min: (0, _toDate2.default)(range.min),
	                max: max
	            };
	        }
	    }, {
	        key: 'currentRange',
	        value: function currentRange() {
	            var options = this.options;
	            var round = options.roundToBaseUnit !== false;
	            var totalRange = this.categoriesRange();
	            var min = options.min;
	            var max = options.max;


	            if (!min) {
	                min = round ? this._roundToTotalStep(totalRange.min, options, false) : totalRange.min;
	            }

	            if (!max) {
	                max = round ? this._roundToTotalStep(totalRange.max, options, !options.justified) : totalRange.max;
	            }

	            return {
	                min: min,
	                max: max
	            };
	        }
	    }, {
	        key: 'datesRange',
	        value: function datesRange() {
	            var range = this._categoryRange(this.options.srcCategories || this.options.categories);
	            return {
	                min: (0, _toDate2.default)(range.min),
	                max: (0, _toDate2.default)(range.max)
	            };
	        }
	    }, {
	        key: 'pan',
	        value: function pan(delta) {
	            var options = this.options;
	            var lineBox = this.lineBox();
	            var size = options.vertical ? lineBox.height() : lineBox.width();

	            var _currentRange = this.currentRange();

	            var min = _currentRange.min;
	            var max = _currentRange.max;

	            var totalLimits = this.totalLimits();
	            var scale = size / (max - min);
	            var offset = (0, _round2.default)(delta / scale, _constants.DEFAULT_PRECISION);
	            var from = (0, _addTicks2.default)(min, offset);
	            var to = (0, _addTicks2.default)(max, offset);

	            var panRange = this.limitRange((0, _toTime2.default)(from), (0, _toTime2.default)(to), (0, _toTime2.default)(totalLimits.min), (0, _toTime2.default)(totalLimits.max), offset);

	            if (panRange) {
	                panRange.min = (0, _toDate2.default)(panRange.min);
	                panRange.max = (0, _toDate2.default)(panRange.max);
	                panRange.baseUnit = options.baseUnit;
	                panRange.baseUnitStep = options.baseUnitStep || 1;
	                panRange.userSetBaseUnit = options.userSetBaseUnit;
	                panRange.userSetBaseUnitStep = options.userSetBaseUnitStep;

	                return panRange;
	            }
	        }
	    }, {
	        key: 'pointsRange',
	        value: function pointsRange(start, end) {
	            var pointsRange = _get(DateCategoryAxis.prototype.__proto__ || Object.getPrototypeOf(DateCategoryAxis.prototype), 'pointsRange', this).call(this, start, end);
	            var datesRange = this.currentRange();
	            var indicesRange = this.rangeIndices();
	            var scale = (0, _dateDiff2.default)(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);
	            var options = this.options;

	            var min = (0, _addTicks2.default)(datesRange.min, pointsRange.min * scale);
	            var max = (0, _addTicks2.default)(datesRange.min, pointsRange.max * scale);

	            return {
	                min: min,
	                max: max,
	                baseUnit: options.userSetBaseUnit,
	                baseUnitStep: options.userSetBaseUnitStep
	            };
	        }
	    }, {
	        key: 'zoomRange',
	        value: function zoomRange(delta) {
	            var options = this.options;
	            var totalLimits = this.totalLimits();
	            var weekStartDay = options.weekStartDay;
	            var baseUnit = options.baseUnit;
	            var _options$baseUnitStep2 = options.baseUnitStep;
	            var baseUnitStep = _options$baseUnitStep2 === undefined ? 1 : _options$baseUnitStep2;

	            var _currentRange2 = this.currentRange();

	            var rangeMin = _currentRange2.min;
	            var rangeMax = _currentRange2.max;

	            var min = (0, _addDuration2.default)(rangeMin, delta * baseUnitStep, baseUnit, weekStartDay);
	            var max = (0, _addDuration2.default)(rangeMax, -delta * baseUnitStep, baseUnit, weekStartDay);

	            if (options.userSetBaseUnit === FIT) {
	                var autoBaseUnitSteps = options.autoBaseUnitSteps;
	                var maxDateGroups = options.maxDateGroups;


	                var maxDiff = (0, _last2.default)(autoBaseUnitSteps[baseUnit]) * maxDateGroups * _constants2.TIME_PER_UNIT[baseUnit];
	                var rangeDiff = (0, _dateDiff2.default)(rangeMax, rangeMin);
	                var diff = (0, _dateDiff2.default)(max, min);
	                var baseUnitIndex = BASE_UNITS.indexOf(baseUnit);
	                var autoBaseUnitStep = void 0,
	                    ticks = void 0;

	                if (diff < _constants2.TIME_PER_UNIT[baseUnit] && baseUnit !== _constants2.MILLISECONDS) {
	                    baseUnit = BASE_UNITS[baseUnitIndex - 1];
	                    autoBaseUnitStep = (0, _last2.default)(autoBaseUnitSteps[baseUnit]);
	                    ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * _constants2.TIME_PER_UNIT[baseUnit]) / 2;
	                    min = (0, _addTicks2.default)(rangeMin, ticks);
	                    max = (0, _addTicks2.default)(rangeMax, -ticks);
	                } else if (diff > maxDiff && baseUnit !== _constants2.YEARS) {
	                    var stepIndex = 0;

	                    do {
	                        baseUnitIndex++;
	                        baseUnit = BASE_UNITS[baseUnitIndex];
	                        stepIndex = 0;
	                        ticks = 2 * _constants2.TIME_PER_UNIT[baseUnit];
	                        do {
	                            autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];
	                            stepIndex++;
	                        } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);
	                    } while (baseUnit !== _constants2.YEARS && ticks * autoBaseUnitStep < rangeDiff);

	                    ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;
	                    if (ticks > 0) {
	                        min = (0, _addTicks2.default)(rangeMin, -ticks);
	                        max = (0, _addTicks2.default)(rangeMax, ticks);
	                        min = (0, _addTicks2.default)(min, (0, _limitValue2.default)(max, totalLimits.min, totalLimits.max) - max);
	                        max = (0, _addTicks2.default)(max, (0, _limitValue2.default)(min, totalLimits.min, totalLimits.max) - min);
	                    }
	                }
	            }

	            min = (0, _toDate2.default)((0, _limitValue2.default)(min, totalLimits.min, totalLimits.max));
	            max = (0, _toDate2.default)((0, _limitValue2.default)(max, totalLimits.min, totalLimits.max));

	            if (min && max && (0, _dateDiff2.default)(max, min) > 0) {
	                return {
	                    min: min,
	                    max: max,
	                    baseUnit: options.userSetBaseUnit,
	                    baseUnitStep: options.userSetBaseUnitStep
	                };
	            }
	        }
	    }, {
	        key: 'totalLimits',
	        value: function totalLimits() {
	            var options = this.options;
	            var datesRange = this.datesRange();

	            var min = this._roundToTotalStep((0, _toDate2.default)(datesRange.min), options, false);
	            var max = datesRange.max;

	            if (!options.justified) {
	                max = this._roundToTotalStep(max, options, true, (0, _dateEquals2.default)(max, this._roundToTotalStep(max, options, false)));
	            }

	            return {
	                min: min,
	                max: max
	            };
	        }
	    }, {
	        key: 'range',
	        value: function range(rangeOptions) {
	            var options = rangeOptions || this.options;

	            var categories = options.categories;
	            var autoUnit = options.baseUnit === FIT;
	            var baseUnit = autoUnit ? BASE_UNITS[0] : options.baseUnit;
	            var baseUnitStep = options.baseUnitStep || 1;
	            var stepOptions = {
	                baseUnit: baseUnit,
	                baseUnitStep: baseUnitStep,
	                weekStartDay: options.weekStartDay
	            };
	            var categoryLimits = this._categoryRange(categories);
	            var min = (0, _toDate2.default)(options.min || categoryLimits.min);
	            var max = (0, _toDate2.default)(options.max || categoryLimits.max);

	            return {
	                min: this._roundToTotalStep(min, stepOptions, false),
	                max: this._roundToTotalStep(max, stepOptions, true, true)
	            };
	        }
	    }, {
	        key: 'autoBaseUnit',
	        value: function autoBaseUnit(options) {
	            var categoryLimits = this._categoryRange(options.categories);
	            var span = (0, _toDate2.default)(options.max || categoryLimits.max) - (0, _toDate2.default)(options.min || categoryLimits.min);
	            var maxDateGroups = options.maxDateGroups || this.options.maxDateGroups;
	            var autoUnit = options.baseUnit === FIT;
	            var autoUnitIx = 0;
	            var baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options.baseUnit;
	            var units = span / _constants2.TIME_PER_UNIT[baseUnit];
	            var totalUnits = units;
	            var autoBaseUnitSteps = (0, _deepExtend2.default)({}, this.options.autoBaseUnitSteps, options.autoBaseUnitSteps);
	            var unitSteps = void 0,
	                step = void 0,
	                nextStep = void 0;

	            while (!step || units >= maxDateGroups) {
	                unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);
	                nextStep = unitSteps.shift();

	                if (nextStep) {
	                    step = nextStep;
	                    units = totalUnits / step;
	                } else if (baseUnit === (0, _last2.default)(BASE_UNITS)) {
	                    step = Math.ceil(totalUnits / maxDateGroups);
	                    break;
	                } else if (autoUnit) {
	                    baseUnit = BASE_UNITS[autoUnitIx++] || (0, _last2.default)(BASE_UNITS);
	                    totalUnits = span / _constants2.TIME_PER_UNIT[baseUnit];
	                    unitSteps = null;
	                } else {
	                    if (units > maxDateGroups) {
	                        step = Math.ceil(totalUnits / maxDateGroups);
	                    }
	                    break;
	                }
	            }

	            options.baseUnitStep = step;
	            options.baseUnit = baseUnit;
	        }
	    }, {
	        key: 'groupCategories',
	        value: function groupCategories(options) {
	            var categories = options.categories;
	            var baseUnit = options.baseUnit;
	            var _options$baseUnitStep3 = options.baseUnitStep;
	            var baseUnitStep = _options$baseUnitStep3 === undefined ? 1 : _options$baseUnitStep3;

	            var maxCategory = (0, _toDate2.default)((0, _sparseArrayLimits2.default)(categories).max);

	            var _range = this.range(options);

	            var min = _range.min;
	            var max = _range.max;

	            var groups = [];
	            var nextDate = void 0;

	            for (var date = min; date < max; date = nextDate) {
	                groups.push(date);

	                nextDate = (0, _addDuration2.default)(date, baseUnitStep, baseUnit, options.weekStartDay);
	                if (nextDate > maxCategory && !options.max) {
	                    break;
	                }
	            }

	            options.srcCategories = categories;
	            options.categories = groups;
	        }
	    }, {
	        key: '_roundToTotalStep',
	        value: function _roundToTotalStep(value, axisOptions, upper, roundToNext) {
	            var options = axisOptions || this.options;
	            var baseUnit = options.baseUnit;
	            var _options$baseUnitStep4 = options.baseUnitStep;
	            var baseUnitStep = _options$baseUnitStep4 === undefined ? 1 : _options$baseUnitStep4;

	            var start = this._groupsStart;

	            if (start) {
	                var step = (0, _dateIndex2.default)(value, start, baseUnit, baseUnitStep);
	                var roundedStep = upper ? Math.ceil(step) : Math.floor(step);
	                if (roundToNext) {
	                    roundedStep++;
	                }
	                return (0, _addDuration2.default)(start, roundedStep * baseUnitStep, baseUnit, options.weekStartDay);
	            }

	            return (0, _addDuration2.default)(value, upper ? baseUnitStep : 0, baseUnit, options.weekStartDay);
	        }
	    }, {
	        key: 'createAxisLabel',
	        value: function createAxisLabel(index, labelOptions) {
	            var options = this.options;
	            var dataItem = options.dataItems ? options.dataItems[index] : null;
	            var date = options.categories[index];
	            var baseUnit = options.baseUnit;
	            var unitFormat = labelOptions.dateFormats[baseUnit];
	            var visible = true;

	            if (options.justified) {
	                var roundedDate = (0, _floorDate2.default)(date, baseUnit, options.weekStartDay);
	                visible = (0, _dateEquals2.default)(roundedDate, date);
	            } else if (!options.roundToBaseUnit) {
	                visible = !(0, _dateEquals2.default)(this.range().max, date);
	            }

	            if (visible) {
	                labelOptions.format = labelOptions.format || unitFormat;
	                var text = this.axisLabelText(date, dataItem, labelOptions);
	                if (text) {
	                    return new _axisLabel2.default(date, text, index, dataItem, labelOptions);
	                }
	            }
	        }
	    }, {
	        key: 'categoryIndex',
	        value: function categoryIndex(value) {
	            var options = this.options;
	            var categories = options.categories;
	            var index = -1;

	            if (categories.length) {
	                index = Math.floor((0, _dateIndex2.default)((0, _toDate2.default)(value), categories[0], options.baseUnit, options.baseUnitStep || 1));
	            }

	            return index;
	        }
	    }, {
	        key: 'getSlot',
	        value: function getSlot(a, b, limit) {
	            var start = a;
	            var end = b;

	            if ((typeof start === 'undefined' ? 'undefined' : _typeof(start)) === _constants.OBJECT) {
	                start = this.categoryIndex(start);
	            }

	            if ((typeof end === 'undefined' ? 'undefined' : _typeof(end)) === _constants.OBJECT) {
	                end = this.categoryIndex(end);
	            }

	            return _get(DateCategoryAxis.prototype.__proto__ || Object.getPrototypeOf(DateCategoryAxis.prototype), 'getSlot', this).call(this, start, end, limit);
	        }
	    }, {
	        key: 'valueRange',
	        value: function valueRange() {
	            var options = this.options;
	            var range = this._categoryRange(options.srcCategories || options.categories);

	            return {
	                min: (0, _toDate2.default)(range.min),
	                max: (0, _toDate2.default)(range.max)
	            };
	        }
	    }]);

	    return DateCategoryAxis;
	}(_categoryAxis2.default);

	(0, _setDefaultOptions2.default)(DateCategoryAxis.prototype, {
	    type: _constants.DATE,
	    labels: {
	        dateFormats: _constants3.DateLabelFormats
	    },
	    autoBaseUnitSteps: {
	        milliseconds: [1, 10, 100],
	        seconds: [1, 2, 5, 15, 30],
	        minutes: [1, 2, 5, 15, 30],
	        hours: [1, 2, 3],
	        days: [1, 2, 3],
	        weeks: [1, 2],
	        months: [1, 2, 3, 6],
	        years: [1, 2, 3, 5, 10, 25, 50]
	    },
	    maxDateGroups: 10
	});

	exports.default = DateCategoryAxis;

/***/ },

/***/ 480:
/***/ function(module, exports) {

	module.exports = require("./category-axis");

/***/ },

/***/ 481:
/***/ function(module, exports) {

	module.exports = require("../date-utils/constants");

/***/ },

/***/ 482:
/***/ function(module, exports) {

	module.exports = require("../date-utils/date-comparer");

/***/ },

/***/ 483:
/***/ function(module, exports) {

	module.exports = require("../date-utils/add-ticks");

/***/ },

/***/ 484:
/***/ function(module, exports) {

	module.exports = require("../date-utils/add-duration");

/***/ },

/***/ 485:
/***/ function(module, exports) {

	module.exports = require("../date-utils/date-diff");

/***/ },

/***/ 486:
/***/ function(module, exports) {

	module.exports = require("../date-utils/absolute-date-diff");

/***/ },

/***/ 487:
/***/ function(module, exports) {

	module.exports = require("../date-utils/date-index");

/***/ },

/***/ 488:
/***/ function(module, exports) {

	module.exports = require("../date-utils/date-equals");

/***/ },

/***/ 489:
/***/ function(module, exports) {

	module.exports = require("../date-utils/to-time");

/***/ },

/***/ 490:
/***/ function(module, exports) {

	module.exports = require("../date-utils/floor-date");

/***/ }

/******/ });