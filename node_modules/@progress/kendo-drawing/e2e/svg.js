import 'core-js/es6';
import { withRoot, $ } from 'e2e-utils';
import { same, equal, ok, contains } from '../test/test-helpers';
import { svg, Group, Path, MultiPath, Text, Image, Circle, Arc, Rect, Layout, LinearGradient, RadialGradient, exportSVG, GradientStop } from '../src/drawing';
import { Matrix, transform, Point, Circle as GeometryCircle, Rect as GeometryRect } from '../src/geometry';
import { baseSurfaceTests, baseSurfaceEventTests } from './base-surface-tests';
import '../test/text-measure';

const { RootNode, Node, ArcNode, CircleNode, GroupNode, PathNode,
    MultiPathNode, TextNode, ImageNode, RectNode, Surface,
    DefinitionNode, GradientStopNode, LinearGradientNode,
    RadialGradientNode, ClipNode } = svg;

describe('Surface', () => {
    let container, surface;

    function createSurface(options) {
        if (surface) {
            surface.destroy();
        }

        surface = new Surface(container[0], options);
    }

    afterEach(() => {
        surface.destroy();
    });

    beforeEach(withRoot((root) => {
        container = $("<div>").appendTo(root);
        createSurface();
    }));

    baseSurfaceTests("SVG", Surface);
    baseSurfaceEventTests("SVG", Surface);

    it("reports actual surface type", () => {
        createSurface({ type: "foo" });
        equal(surface.type, "svg");
    });

    it("appends svg element to container", () => {
        equal(container.find("svg").length, 1);
    });

    it("size updates translate", () => {
        surface.translate({ x: 10, y: 10 });
        surface.size({ width: 100, height: 100 });

        equal(surface._rootElement.getAttribute("viewBox"), "10 10 100 100");
    });

    it("exportVisual returns root visual", () => {
        const element = surface.exportVisual();
        same(element, surface._visual);
    });
});

describe('Node', () => {

    let node;

    beforeEach(() => {
        node = new Node();
    });

    it("load appends GroupNode", () => {
        node.append = function(child) {
            ok(child instanceof GroupNode);
        };

        node.load([new Group()]);
    });

    it("load appends GroupNode at position", () => {
        node.insertAt = function(child, pos) {
            equal(pos, 1);
        };

        node.load([new Group()], 1);
    });

    it("load appends PathNode", () => {
        node.append = function(child) {
            ok(child instanceof PathNode);
        };

        node.load([new Path()]);
    });

    it("load appends MultiPathNode", () => {
        node.append = function(child) {
            ok(child instanceof MultiPathNode);
        };

        node.load([new MultiPath()]);
    });

    it("load appends TextNode", () => {
        node.append = function(child) {
            ok(child instanceof TextNode);
        };

        node.load([new Text()]);
    });

    it("load appends ImageNode", () => {
        node.append = function(child) {
            ok(child instanceof ImageNode);
        };

        node.load([new Image()]);
    });

    it("load appends child nodes", () => {
        let parentGroup = new Group();
        let childGroup = new Group();
        parentGroup.append(childGroup);

        node.load([parentGroup]);

        ok(node.childNodes[0].childNodes[0] instanceof GroupNode);
    });

    it("load creates definitions", () => {
        let path = new Path();
        node.definitionChange = function(e) {
            equal(e.action, "add");
            equal(e.definitions.clip, path);
        };

        node.load([new Group({
            clip: path
        })]);

        equal(node.childNodes[0].definitions.clip, path);
    });

    it("load does not create definitions if source does not have definitions", () => {
        let path = new Path();
        let definitions;
        let definitionChangeCalls = 0;

        node.definitionChange = function() {
            definitionChangeCalls++;
        };

        node.load([new Group()]);
        definitions = node.childNodes[0].definitions;

        expect(definitionChangeCalls).toBe(0);
        equal(Object.keys(definitions).length, 0);
    });

    it("attachTo renders children", () => {
        class ChildNode extends Node {}

        let child = new ChildNode();
        node.append(child);

        let grandChild = new ChildNode();
        child.append(grandChild);

        let renderCalls = 0;

        ChildNode.prototype.render = function() {
            renderCalls++;
            return Node.prototype.render.call(this);
        };

        node.attachTo(document.createElement("div"));

        expect(renderCalls).toBe(2);
    });

});

describe('RootNode', () => {

    let rootNode;

    beforeEach(() => {
        rootNode = new RootNode();
    });


    it("inits definition node", () => {
        ok(rootNode.defs instanceof DefinitionNode);
    });

    it("renders definition node", () => {
        rootNode.defs.render = function() {
            ok(true);
        };
        rootNode.render();
    });

    it("propagates definition change to definition node", () => {
        let defs = rootNode.defs;
        defs.definitionChange = function(e) {
            equal(e, "foo");
        };
        rootNode.definitionChange("foo");
    });

    it("attachTo directly sets element", () => {
        let container = document.createElement("div");
        rootNode.attachTo(container);

        equal(rootNode.element, container);
    });

    it("attachTo attaches first child to definition node", () => {
        let container = document.createElement("div");
        let child = document.createElement("div");
        container.appendChild(child);
        rootNode.attachTo(container);

        equal(rootNode.defs.element, child);
    });
});


function nodeTests(TShape, TNode, name) {
    let shape,
        node,
        clip,
        container;

    describe("Base Node tests / " + name, () => {

        beforeEach(() => {
            container = document.createElement("div");

            shape = new TShape();
            node = new TNode(shape);
            node.attachTo(container);
        });

        it("renders visibility", () => {
            shape.visible(false);
            ok(node.render().indexOf("display:none;") !== -1);
        });

        it("does not render visibility if not set", () => {
            ok(node.render().indexOf("display") === -1);
        });

        it("does not render visibility if set to true", () => {
            shape.visible(true);
            ok(node.render().indexOf("display") === -1);
        });

        it("renders opacity", () => {
            shape.opacity(0.5);
            ok(node.render().indexOf("opacity='0.5'") !== -1);
        });

        it("does not render opacity if not set", () => {
            ok(node.render().indexOf("opacity") === -1);
        });

        it("optionsChange sets visibility to hidden", () => {
            node.css = function(name, value) {
                equal(name, "display");
                equal(value, "none");
            };

            shape.visible(false);
        });

        it("optionsChange sets visibility to visible", () => {
            node.css = function(name, value) {
                equal(name, "display");
                equal(value, "");
            };

            shape.visible(true);
        });

        it("optionsChange sets opacity", () => {
            node.attr = function(name, value) {
                equal(name, "opacity");
                equal(value, 0.5);
            };

            shape.opacity(0.5);
        });

        it("clear destroys children", () => {
            let child = new TNode();
            child.destroy = function() { ok(true); };

            node.append(child);
            node.clear();
        });

        it("removeSelf destroys element", () => {
            let element = node.element;
            node.removeSelf();

            equal(element.parentNode, null);
            equal(node.element, null);
        });
    });

    describe("Base Node tests / " + name + " / observer", () => {

        beforeEach(() => {
            shape = new TShape();
            node = new TNode(shape);
        });

        it("Adds srcElement observer", () => {
            equal(shape.observers()[0], node);
        });

        it("destroy removes srcElement observer", () => {
            node.destroy();
            equal(shape.observers().length, 0);
        });

        it("destroy removes element reference", () => {
            node.attachTo($("<div>")[0]);
            let element = $(node.element);
            node.destroy();
            ok(!element._kendoNode);
        });
    });

    describe("Base Node tests / " + name + " / definitions", () => {

        beforeEach(() => {
            container = new GroupNode();
            clip = new Path();
            shape = new TShape();
            shape.clip(clip);
            container.load([shape]);
            node = container.childNodes[0];
        });

        it("renders clip-path", () => {
            ok(node.render().indexOf("clip-path='url(#" + clip.id + ")'") != -1);
        });

        it("clearing definition in the options removes definition", () => {
            shape.options.set("clip", null);
            equal(node.definitions.clip, undefined);
        });

        it("clearing definition triggers definition change", () => {
            node.definitionChange = function(e) {
                equal(e.action, "remove");
                equal(e.definitions.clip, clip);
            };
            shape.options.set("clip", null);
        });

        it("clearing definition removes attribute", () => {
            node.removeAttr = function(attr) {
                equal(attr, "clip-path");
            };
            shape.options.set("clip", null);
        });

        it("sets new definition", () => {
            let newClip = new Path();

            node.definitionChange = function(e) {
                if (e.action == "add") {
                    equal(e.definitions.clip, newClip);
                }
            };
            shape.options.set("clip", newClip);
            equal(node.definitions.clip, newClip);
        });

        it("setting new definition updates attribute", () => {
            let newClip = new Path();
            node.attr = function(attr, value) {
                equal(attr, "clip-path");
                equal(value, "url(#" + newClip.id + ")");
            };
            shape.clip(newClip);
            equal(node.definitions.clip, newClip);
        });

        it("setting new definition removes the old one", () => {
            let newClip = new Path();
            node.definitionChange = function(e) {
                if (e.action == "remove") {
                    equal(e.definitions.clip, clip);
                }
            };
            shape.clip(newClip);
        });

        it("destroy removes definitions", () => {
            node.definitionChange = function(e) {
                equal(e.action, "remove");
                equal(e.definitions.clip, clip);
            };
            node.destroy();
            for (let definition in node.definitions) {
                ok(false);
            }
        });
    });
}

nodeTests(Group, GroupNode, "GroupNode");

describe('GroupNode', () => {

    let group;
    let groupNode;

    beforeEach(() => {
        group = new Group();
        groupNode = new GroupNode(group);
    });

    it("attachTo sets element", () => {
        groupNode.attachTo(document.createElement("div"));

        ok(groupNode.element);
    });

    it("attachTo sets element for child nodes", () => {
        groupNode.append(new GroupNode(new Group()));
        groupNode.attachTo(document.createElement("div"));

        ok(groupNode.childNodes[0].element);
    });

    it("attachTo sets element for grandchild nodes", () => {
        let child = new GroupNode(new Group());
        let grandChild = new GroupNode(new Group());

        child.append(grandChild);
        groupNode.append(child);

        groupNode.attachTo(document.createElement("div"));

        ok(grandChild.element);
    });

    it("attachTo sets _kendoNode expando", () => {
        groupNode.attachTo(document.createElement("div"));

        same(groupNode.element._kendoNode, groupNode);
    });

    it("attachTo sets _kendoNode expando on child elements", () => {
        let childGroup = new GroupNode(new Group());
        groupNode.append(childGroup);
        groupNode.attachTo(document.createElement("div"));

        same(childGroup.element._kendoNode, childGroup);
    });

    it("attachTo sets _kendoNode expando for grandchild nodes", () => {
        let child = new GroupNode(new Group());
        let grandChild = new GroupNode(new Group());

        child.append(grandChild);
        groupNode.append(child);

        groupNode.attachTo(document.createElement("div"));

        same(grandChild.element._kendoNode, grandChild);
    });

    it("attachTo inserts element at specific position", () => {
        let domElement = {
            childNodes: ["foo", "bar"],
            insertBefore: function(element, referenceNode) {
                equal(referenceNode, "bar");
            }
        };

        groupNode.attachTo(domElement, 1);
    });

    it("attachTo passes null for reference node when inserting element at last position", () => {
        let domElement = {
            childNodes: ["foo", "bar"],
            insertBefore: function(element, referenceNode) {
                ok(referenceNode === null);
            }
        };

        groupNode.attachTo(domElement, 2);
    });

    it("destroy removes element", () => {
        groupNode.attachTo(document.createElement("div"));
        groupNode.destroy();

        ok(!groupNode.element);
    });

    it("destroy removes _kendoNode expando from element", () => {
        let container = document.createElement("div");
        groupNode.attachTo(container);
        groupNode.destroy();

        ok(!container._kendoNode);
    });

    it("load attaches node", () => {
        groupNode.attachTo(document.createElement("div"));

        let group = new Group();
        groupNode.load([group]);

        ok(groupNode.childNodes[0].element);
    });

    it("load attaches node at position", () => {
        groupNode.attachTo(document.createElement("div"));

        let group1 = new Group();
        groupNode.load([group1]);

        let group2 = new Group();
        groupNode.load([group2], 0);

        equal(groupNode.element.childNodes[0], group2._observers[0].element);
    });

    it("renders group tag", () => {
        equal(groupNode.render(), "<g></g>");
    });

    it("renders group transform", () => {
        groupNode = new GroupNode(new Group({transform: new Matrix(1,1,1,1,1,1)}));
        equal(groupNode.render(), "<g transform='matrix(1,1,1,1,1,1)' ></g>");
    });

    it("does not render transform if not set", () => {
        ok(groupNode.render().indexOf("transform") === -1);
    });

    it("options change renders transform", () => {
        groupNode.attr = function(key, value) {
            equal(key, "transform");
            equal(value, "matrix(1,0,0,1,0,0)");
        };
        group.transform(Matrix.unit());

    });

    it("clearing transform removes transform attribute", () => {
        groupNode.removeAttr = function(key) {
            equal(key, "transform");
        };
        group.transform(null);
    });
});

nodeTests(Path, PathNode, "PathNode");

describe('PathNode', () => {

    let path,
        pathNode,
        container;

    beforeEach(() => {
        container = document.createElement("div");

        path = new Path();
        pathNode = new PathNode(path);
        pathNode.attachTo(container);
    });

    it("renders straight segments", () => {
        path.moveTo(0, 0).lineTo(10, 20);

        ok(pathNode.render().indexOf("d='M0 0 L 10 20'") !== -1);
    });

    it("renders points with precision to the third sign", () => {
        path.moveTo(0, 0).lineTo(10.001, 20.0005);

        ok(pathNode.render().indexOf("d='M0 0 L 10.001 20.001'") !== -1);
    });

    it("renders closed paths", () => {
        path.moveTo(0, 0).lineTo(10, 20).close();

        ok(pathNode.render().indexOf("d='M0 0 L 10 20Z'") !== -1);
    });

    it("renders curve", () => {
        path.moveTo(0, 0).curveTo(Point.create(10, 10), Point.create(20, 10), Point.create(30, 0));

        ok(pathNode.render().indexOf("d='M0 0 C 10 10 20 10 30 0'") !== -1);
    });

    it("switches between line and curve", () => {
        path.moveTo(0, 0).lineTo(5, 5).curveTo(Point.create(10, 10), Point.create(20, 10), Point.create(30, 0));

        ok(pathNode.render().indexOf("d='M0 0 L 5 5 C 10 10 20 10 30 0'") !== -1);
    });

    it("switches between curve and line", () => {
        path.moveTo(0, 0).curveTo(Point.create(10, 10), Point.create(20, 10), Point.create(30, 0)).lineTo(40, 10);

        ok(pathNode.render().indexOf("d='M0 0 C 10 10 20 10 30 0 L 40 10'") !== -1);
    });

    it("does not render segments for empty path", () => {
        equal(pathNode.render().indexOf("d="), -1);
    });

    it("renders stroke", () => {
        path.options.set("stroke.color", "red");

        ok(pathNode.render().indexOf("stroke='red'") !== -1);
    });

    it("renders empty stroke if set to 'transparent'", () => {
        path.options.set("stroke.color", "transparent");
        ok(pathNode.render().indexOf("stroke='none'") !== -1);
    });

    it("renders empty stroke if set to 'none'", () => {
        path.options.set("stroke.color", "none");
        ok(pathNode.render().indexOf("stroke='none'") !== -1);
    });

    it("renders empty stroke if set to ''", () => {
        path.options.set("stroke.color", "");
        ok(pathNode.render().indexOf("stroke='none'") !== -1);
    });

    it("renders stroke width", () => {
        path.options.set("stroke.width", 2);

        ok(pathNode.render().indexOf("stroke-width='2'") !== -1);
    });

    it("renders stroke opacity", () => {
        path.options.set("stroke.opacity", 0.5);

        ok(pathNode.render().indexOf("stroke-opacity='0.5'") !== -1);
    });

    it("does not render stroke opacity if not set", () => {
        equal(pathNode.render().indexOf("stroke-opacity="), -1);
    });

    it("renders stroke dashType", () => {
        path.options.set("stroke.dashType", "dot");

        ok(pathNode.render().indexOf("stroke-dasharray='1.5 3.5'") !== -1);
    });

    it("does not render stroke dashType if not set", () => {
        equal(pathNode.render().indexOf("stroke-dasharray="), -1);
    });

    it("renders stroke linejoin", () => {
        path.options.set("stroke.lineJoin", "round");

        ok(pathNode.render().indexOf("stroke-linejoin='round'") !== -1);
    });

    it("renders stroke linecap", () => {
        path.options.set("stroke.lineCap", "butt");

        ok(pathNode.render().indexOf("stroke-linecap='butt'") !== -1);
    });

    it("overrides stroke linecap when dashType is set", () => {
        path.options.set("stroke.dashType", "dot");
        path.options.set("stroke.lineCap", "foo");

        ok(pathNode.render().indexOf("stroke-linecap='butt'") !== -1);
    });

    it("renders stroke linecap when dashType is set to solid", () => {
        path.options.set("stroke.dashType", "solid");
        path.options.set("stroke.lineCap", "foo");

        ok(pathNode.render().indexOf("stroke-linecap='foo'") !== -1);
    });

    it("renders fill", () => {
        path.options.set("fill", { color: "red", opacity: 0.5 });
        let svg = pathNode.render();

        ok(svg.indexOf("fill='red'") !== -1);
        ok(svg.indexOf("fill-opacity='0.5'") !== -1);
    });

    it("renders fill gradient", () => {
        let gradient = new LinearGradient();
        path.fill(gradient);
        ok(pathNode.render().indexOf("fill='url(#" + gradient.id + ")'") != -1);
    });

    it("renders empty fill if not set", () => {
        ok(pathNode.render().indexOf("fill='none'") !== -1);
    });

    it("renders empty fill if set to none", () => {
        path.options.set("fill.color", "none");
        ok(pathNode.render().indexOf("fill='none'") !== -1);
    });

    it("renders empty fill if set to transparent", () => {
        path.options.set("fill.color", "transparent");
        ok(pathNode.render().indexOf("fill='none'") !== -1);
    });

    it("renders empty fill if set to null", () => {
        path.options.set("fill", null);
        ok(pathNode.render().indexOf("fill='none'") !== -1);
    });

    it("renders empty fill if set to ''", () => {
        path.options.set("fill", '');
        ok(pathNode.render().indexOf("fill='none'") !== -1);
    });

    it("renders cursor", () => {
        path.options.set("cursor", "hand");
        ok(pathNode.render().indexOf("cursor:hand;") !== -1);
    });

    it("does not render cursor if not set", () => {
        ok(pathNode.render().indexOf("cursor") === -1);
    });

    it("does not render style if not set", () => {
        ok(pathNode.render().indexOf("style") === -1);
    });

    it("renders transform if set", () => {
        path.transform(new Matrix(1,1,1,1,1,1));
        ok(pathNode.render().indexOf("transform='matrix(1,1,1,1,1,1)'") !== -1);
    });

    it("does not render transform if not set", () => {
        ok(pathNode.render().indexOf("transform") === -1);
    });

    it("geometryChange sets path", () => {
        path.moveTo(0, 0);
        pathNode.attr = function(name, value) {
            equal(name, "d");
            ok(value);
        };

        path.lineTo(10, 10);
    });

    it("optionsChange sets fill color", () => {
        pathNode.attr = function(name, value) {
            equal(name, "fill");
            equal(value, "red");
        };

        path.options.set("fill.color", "red");
    });

    it("optionsChange sets fill opacity", () => {
        pathNode.attr = function(name, value) {
            equal(name, "fill-opacity");
            equal(value, 0.4);
        };

        path.options.set("fill.opacity", 0.4);
    });

    it("optionsChange sets fill gradient", () => {
        let gradient = new LinearGradient();

        pathNode.attr = function(key, value) {
            equal(key, "fill");
            equal(value, "url(#" + gradient.id + ")");
        };

        path.options.set("fill", gradient);
    });

    it("optionsChange sets fill color to none for 'transparent'", () => {
        pathNode.attr = function(name, value) {
            equal(name, "fill");
            equal(value, "none");
        };

        path.options.set("fill.color", "transparent");
    });

    it("optionsChange sets fill color to none for 'none'", () => {
        pathNode.attr = function(name, value) {
            equal(name, "fill");
            equal(value, "none");
        };

        path.options.set("fill.color", "none");
    });

    it("optionsChange sets fill color to none for ''", () => {
        pathNode.attr = function(name, value) {
            equal(name, "fill");
            equal(value, "none");
        };

        path.options.set("fill.color", "");
    });

    it("optionsChange sets fill", () => {
        let fillCalls = 0;
        pathNode.attr = function(name, value) {
            if (name === "fill") {
                equal(value, "red");
                fillCalls++;
            } else if (name === "fill-opacity") {
                equal(value, 0.4);
                fillCalls++;
            } else {
                ok(false);
            }
        };

        path.options.set("fill", { color: "red", opacity: 0.4 });

        expect(fillCalls).toBe(2);
    });

    it("optionsChange clears stroke", () => {
        pathNode.removeAttr = function(name) {
            equal(name, "fill");
        };

        path.options.set("fill", null);
    });

    it("optionsChange sets stroke color", () => {
        pathNode.attr = function(name, value) {
            equal(name, "stroke");
            equal(value, "red");
        };

        path.options.set("stroke.color", "red");
    });

    it("optionsChange sets stroke width", () => {
        pathNode.attr = function(name, value) {
            equal(name, "stroke-width");
            equal(value, 4);
        };

        path.options.set("stroke.width", 4);
    });

    it("optionsChange sets stroke opacity", () => {
        pathNode.attr = function(name, value) {
            equal(name, "stroke-opacity");
            equal(value, 0.4);
        };

        path.options.set("stroke.opacity", 0.4);
    });

    it("optionsChange sets stroke", () => {
        let strokeCalls = 0;
        pathNode.attr = function(name, value) {
            if (name === "stroke") {
                equal(value, "red");
                strokeCalls++;
            } else if (name === "stroke-opacity") {
                equal(value, 0.4);
                strokeCalls++;
            } else if (name === "stroke-width") {
                equal(value, 4);
                strokeCalls++;
            }
        };

        path.options.set("stroke", { color: "red", opacity: 0.4, width: 4 });
        expect(strokeCalls).toBe(3);
    });

    it("optionsChange clears stroke", () => {
        pathNode.removeAttr = function(name) {
            equal(name, "stroke");
        };

        path.options.set("stroke", null);
    });

    it("options change renders transform", () => {
        pathNode.attr = function(key, value) {
            equal(key, "transform");
            equal(value, "matrix(1,0,0,1,0,0)");
        };
        path.transform(Matrix.unit());
    });

    it("clearing transform removes transform attribute", () => {
        pathNode.removeAttr = function(key) {
            equal(key, "transform");
        };
        path.transform(null);
    });
});

nodeTests(MultiPath, MultiPathNode, "MultiPathNode");

describe('MultiPathNode', () => {

    let multiPath,
        multiPathNode;

    beforeEach(() => {
        multiPath = new MultiPath();
        multiPathNode = new MultiPathNode(multiPath);
    });

    it("renders composite paths", () => {
        multiPath
            .moveTo(0, 0).lineTo(10, 20)
            .moveTo(10, 10).lineTo(10, 20);

        ok(multiPathNode.render().indexOf("d='M0 0 L 10 20 M10 10 L 10 20'") !== -1);
    });
});

nodeTests(Circle, CircleNode, "CircleNode");

describe('CircleNode', () => {

    let circle,
        circleNode;

    beforeEach(() => {
        let geometry = new GeometryCircle(new Point(10, 20), 30);
        circle = new Circle(geometry);
        circleNode = new CircleNode(circle);
    });

    it("renders center", () => {
        ok(circleNode.render().indexOf("cx='10' cy='20'") !== -1);
    });

    it("renders radius", () => {
        ok(circleNode.render().indexOf("r='30'") !== -1);
    });

    it("geometryChange sets center", () => {
        let callsCount = 0;

        circleNode.attr = function(name, value) {
            if (name === "cx") {
                equal(value, 20);
                callsCount++;
            } else if (name === "cy") {
                equal(value, 40);
                callsCount++;
            }
        };

        circle.geometry().center.scale(2);

        expect(callsCount).toBe(2);
    });

    it("geometryChange sets radius", () => {
        let callsCount = 0;

        circleNode.attr = function(name, value) {
            if (name === "r") {
                equal(value, 60);
                callsCount++;
            }
        };

        circle.geometry().setRadius(60);
        expect(callsCount).toBe(1);
    });
});

nodeTests(Text, TextNode, "TextNode");

describe('TextNode', () => {

    let text;
    let textNode;

    beforeEach(() => {
        text = new Text("Foo&Bar", new Point(10, 20), { font: "'serif'" });
        text.measure = function() {
            return {
                width: 20, height: 10, baseline: 15
            };
        };

        textNode = new TextNode(text);
    });

    it("renders position accounting for baseline", () => {
        contains(textNode.render(), "x='10' y='35'");
    });

    it("renders encoded content", () => {
        contains(textNode.render(), "Foo&amp;Bar");
    });

    it("renders encoded font", () => {
        contains(textNode.render(), "font:&#39;serif&#39;;");
    });

    it("renders transformation", () => {
        text.transform(transform(new Matrix(1,1,1,1,1,1)));
        ok(textNode.render().indexOf("transform='matrix(1,1,1,1,1,1)'") > -1);
    });

    it("does not render tspan", () => {
        ok(textNode.render().indexOf("<tspan>") == -1);
    });

    it("geometryChange sets position", () => {
        let callsCount = 0;
        textNode.attr = function(name, value) {
            if (name === "x") {
                equal(value, 20);
                callsCount++;
            } else if (name === "y") {
                equal(value, 55);
                callsCount++;
            }
        };

        text.position().scale(2);

        expect(callsCount).toBe(2)
    });

    it("optionsChange does not encode font", () => {
        textNode.attr = function(name, value) {
            if (name == "style") {
                equal(value, "font:'arial';");
            }
        };

        text.options.set("font", "'arial'");
    });

    it("optionsChange does not encode content", () => {
        textNode.element = {};

        text.content("Bar&Baz");
        equal(textNode.element.textContent, "Bar&Baz");
    });
});

nodeTests(Image, ImageNode, "ImageNode");

describe('ImageNode', () => {

    let image;
    let imageNode;

    beforeEach(() => {
        image = new Image("Foo&Bar", new GeometryRect(new Point(10, 20), [90, 80]));
        imageNode = new ImageNode(image);
    });

    it("renders X position", () => {
        ok(imageNode.render().indexOf("x='10'") > -1);
    });

    it("renders Y position", () => {
        ok(imageNode.render().indexOf("y='20'") > -1);
    });

    it("renders width", () => {
        ok(imageNode.render().indexOf("width='90px'") > -1);
    });

    it("renders height", () => {
        ok(imageNode.render().indexOf("height='80px'") > -1);
    });

    it("renders encoded source", () => {
        ok(imageNode.render().indexOf("xlink:href='Foo&amp;Bar'") > -1);
    });

    it("renders transformation", () => {
        image.transform(transform(new Matrix(1,1,1,1,1,1)));
        ok(imageNode.render().indexOf("transform='matrix(1,1,1,1,1,1)'") > -1);
    });

    it("geometryChange sets position", () => {
        let callsCount = 0;

        imageNode.attr = function(name, value) {
            if (name === "x") {
                equal(value, 20);
                callsCount++;
            } else if (name === "y") {
                equal(value, 40);
                callsCount++;
            }
        };

        image.rect().origin.scale(2);

        expect(callsCount).toBe(2);
    });

    it("geometryChange sets size", () => {
        let callsCount = 0;

        imageNode.attr = function(name, value) {
            if (name === "width") {
                equal(value, "80px");
                callsCount++;
            } else if (name === "height") {
                equal(value, "60px");
                callsCount++;
            }
        };

        image.rect().setSize([80, 60]);

        expect(callsCount).toBe(2);
    });

    it("optionsChange does not encode source", () => {
        imageNode.attr = function(name, value) {
            equal(name, "xlink:href");
            equal(value, "Bar&Baz");
        };

        image.src("Bar&Baz");
    });
});

nodeTests(Rect, RectNode, "RectNode");

describe('RectNode', () => {

    let rect,
        rectNode;

    beforeEach(() => {
        rect = new Rect(new GeometryRect([10, 20], [30, 40]));
        rectNode = new RectNode(rect);
    });

    it("renders x", () => {
        ok(rectNode.render().indexOf("x='10'") !== -1);
    });

    it("renders y", () => {
        ok(rectNode.render().indexOf("y='20'") !== -1);
    });

    it("renders width", () => {
        ok(rectNode.render().indexOf("width='30'") !== -1);
    });

    it("renders height", () => {
        ok(rectNode.render().indexOf("height='40'") !== -1);
    });

    it("geometryChange sets x", () => {
        rectNode.attr = function(name, value) {
            if (name === "x") {
                equal(value, 5);
            }
        };

        rect.geometry().origin.setX(5);
    });

    it("geometryChange sets y", () => {
        rectNode.attr = function(name, value) {
            if (name === "y") {
                equal(value, 5);
            }
        };

        rect.geometry().origin.setY(5);
    });

    it("geometryChange sets width", () => {
        rectNode.attr = function(name, value) {
            if (name === "width") {
                equal(value, 5);
            }
        };

        rect.geometry().size.setWidth(5);
    });

    it("geometryChange sets height", () => {
        rectNode.attr = function(name, value) {
            if (name === "height") {
                equal(value, 5);
            }
        };

        rect.geometry().size.setHeight(5);
    });
});

describe('DefinitionNode', () => {

    let definitionNode;

    beforeEach(() => {
        definitionNode = new DefinitionNode();
    });

    it("renders defs", () => {
        ok(definitionNode.render().indexOf("defs") !== -1);
    });

    it("attachTo sets element", () => {
        definitionNode.attachTo("foo");
        equal(definitionNode.element, "foo");
    });
});

describe('DefinitionNode / definitionChange', () => {

    let definitionNode, path, definitions;

    beforeEach(() => {
        path = new Path();
        definitions = {
            clip: path
        };
        definitionNode = new DefinitionNode();
    });

    it("add creates ClipNode", () => {
        definitionNode.definitionChange({
            action: "add",
            definitions: definitions
        });
        ok(definitionNode.childNodes[0] instanceof ClipNode);
    });

    it("add creates LinearGradientNode", () => {
        definitionNode.definitionChange({
            action: "add",
            definitions: {
                fill: new LinearGradient()
            }
        });
        ok(definitionNode.childNodes[0] instanceof LinearGradientNode);
    });

    it("add creates RadialGradientNode", () => {
        definitionNode.definitionChange({
            action: "add",
            definitions: {
                fill: new RadialGradient()
            }
        });
        ok(definitionNode.childNodes[0] instanceof RadialGradientNode);
    });

    it("add does not create another node if definition has the same id", () => {
        definitionNode.definitionChange({
            action: "add",
            definitions: definitions
        });
        definitionNode.definitionChange({
            action: "add",
            definitions: definitions
        });
        equal(definitionNode.childNodes.length, 1);
    });

    it("remove clears definition", () => {
        definitionNode.definitionChange({
            action: "add",
            definitions: definitions
        });
        let node = definitionNode.definitionMap[path.id].element;
        let clearCalls = 0;
        node.clear = function() {
            clearCalls++;
        };
        definitionNode.definitionChange({
            action: "remove",
            definitions: definitions
        });
        equal(definitionNode.childNodes.length, 0);

        expect(clearCalls).toBe(1)
    });

    it("remove does not clear definition if it was added more times", () => {
        definitionNode.definitionChange({
            action: "add",
            definitions: definitions
        });
        definitionNode.definitionChange({
            action: "add",
            definitions: definitions
        });
        definitionNode.definitionChange({
            action: "remove",
            definitions: definitions
        });
        equal(definitionNode.childNodes.length, 1);
    });
});

describe('ClipNode', () => {

    let clipNode;
    let path;

    beforeEach(() => {
        path = new Path();
        clipNode = new ClipNode(path);
    });

    it("renders clipPath", () => {
        ok(clipNode.render().indexOf("clipPath") !== -1);
    });

    it("renders clip path id", () => {
        ok(clipNode.render().indexOf("id='" + path.id + "'") !== -1);
    });

    it("loads path", () => {
        let pathNode = clipNode.childNodes[0];
        ok(pathNode instanceof PathNode);
        equal(pathNode.srcElement, path);
    });

});

describe('GradientStopNode', () => {

    let stopNode;
    let stop;

    beforeEach(() => {
        stop = new GradientStop(0.3, "red", 0.5);
        stopNode = new GradientStopNode(stop);
    });

    function rendersStyle(style) {
        ok(new RegExp("style='.*?" + style + ";.*?'", "g"));
    }

    it("renders stop element", () => {
        equal(stopNode.render().indexOf("<stop"), 0);
    });

    it("renders offset", () => {
        ok(stopNode.render().indexOf("offset='0.3'") !== -1);
    });

    it("renders stop-color style", () => {
        rendersStyle("stop-color:red");
    });

    it("renders stop-opacity style", () => {
        rendersStyle("stop-opacity:0.5");
    });

    it("changing offset updates offset attribute", () => {
        stopNode.attr = function(key, value) {
            equal(key, "offset");
            equal(value, 1);
        };
        stop.offset(1);
    });

    it("changing color updates stop-color style", () => {
        stopNode.css = function(key, value) {
            equal(key, "stop-color");
            equal(value, "blue");
        };
        stop.color("blue");
    });

    it("changing opacity updates stop-opacity style", () => {
        stopNode.css = function(key, value) {
            equal(key, "stop-opacity");
            equal(value, 1);
        };
        stop.opacity(1);
    });

});

function gradientBaseTests(name, type, gradientType) {
    let gradient;
    let gradientNode;
    let stopNode;

    function createdStopNodes() {
        let stops = gradient.stops;
        let childNodes = gradientNode.childNodes;
        equal(stops.length, childNodes.length);

        for (let idx = 0; idx < stops.length; idx++) {
            ok(childNodes[idx] instanceof svg.GradientStopNode);
            equal(childNodes[idx].srcElement, stops[idx]);
        }
    }

    describe(name + " / stops", () => {

        beforeEach(() => {
            gradient = new gradientType({
                stops: [[0.5, "red"]]
            });
            gradientNode = new type(gradient);
            stopNode = gradientNode.childNodes[0];
        });

        it("renders id", () => {
            ok(gradientNode.render().indexOf("id='" + gradient.id + "'") != -1);
        });

        it("renders gradientUnits based on userSpace", () => {
            ok(gradientNode.render().indexOf("gradientUnits='objectBoundingBox'") != -1);
            gradient.userSpace(true);
            ok(gradientNode.render().indexOf("gradientUnits='userSpaceOnUse'") != -1);
        });

        it("renders children", () => {
            gradientNode.renderChildren = function() {
                ok(true);
            };
            gradientNode.render();
        });

        it("creates stop nodes", () => {
            createdStopNodes();
        });

        it("changing gradient stops clears previous stop nodes", () => {
            stopNode.clear = function() {
                ok(true);
            };
            gradient.stops.pop();
        });

        it("changing gradient stops creates new stop nodes", () => {
            gradient.addStop(1, "red");
            createdStopNodes();
        });

        it("attaches stops to element", () => {
            gradientNode.element = document.createElement("div");
            gradient.addStop(1, "red");
            equal(gradientNode.element.children.length, 2);
            ok(gradientNode.childNodes[0].element);
            ok(gradientNode.childNodes[1].element);
        });
    });
}

gradientBaseTests("LinearGradientNode", LinearGradientNode, LinearGradient);

describe('LinearGradientNode', () => {

    let gradientNode;
    let gradient;

    beforeEach(() => {
        gradient = new LinearGradient({
            start: [0, 0.5],
            end: [0.3, 0.7]
        });
        gradientNode = new LinearGradientNode(gradient);
    });

    function renders(value) {
        ok(gradientNode.render().indexOf(value) != -1);
    }

    it("renders start point", () => {
        renders("x1='0'");
        renders("y1='0.5'");
    });

    it("renders end point", () => {
        renders("x2='0.3'");
        renders("y2='0.7'");
    });

    it("changing point updates coordinates", () => {
        gradientNode.allAttr = function(attrs) {
            equal(attrs[0][0], "x1");
            equal(attrs[0][1], 0.5);
        };
        gradient.start().setX(0.5);
    });

});

gradientBaseTests("RadialGradientNode", RadialGradientNode, RadialGradient);

describe('RadialGradientNode', () => {

    let gradientNode;
    let gradient;

    beforeEach(() => {
        gradient = new RadialGradient({
            center: [0, 0.5],
            radius: 0.7
        });
        gradientNode = new RadialGradientNode(gradient);
    });

    function renders(value) {
        ok(gradientNode.render().indexOf(value) != -1);
    }

    it("renders center", () => {
        renders("cx='0'");
        renders("cy='0.5'");
    });

    it("renders radius", () => {
        renders("r='0.7'");
    });

    it("changing center updates coordinates", () => {
        gradientNode.allAttr = function(attrs) {
            equal(attrs[0][0], "cx");
            equal(attrs[0][1], 0.5);
        };
        gradient.center().setX(0.5);
    });

    it("changing radius updates coordinates", () => {
        gradientNode.allAttr = function(attrs) {
            equal(attrs[2][0], "r");
            equal(attrs[2][1], 0.9);
        };
        gradient.radius(0.9);
    });
});

describe('exportSVG', () => {

    let group;

    beforeEach(() => {
        group = new Group();
    });

    it("exports SVG Data URI", () => {
        exportSVG(group).then(function(svg) {
            contains(svg, "data:image/svg+xml;base64,PD94");
        });
    });

    it("exports raw SVG", () => {
        exportSVG(group, { raw: true }).then(function(svg) {
            equal(svg.indexOf("<?xml version='1.0' ?><svg"), 0);
        });
    });

    it("sets xmlns namespace", () => {
        exportSVG(group, { raw: true }).then(function(svg) {
            contains(svg, "xmlns='http://www.w3.org/2000/svg'");
        });
    });

    it("sets xmlns:xlink namespace", () => {
        exportSVG(group, { raw: true }).then(function(svg) {
            contains(svg, "xmlns:xlink='http://www.w3.org/1999/xlink'");
        });
    });

    it("encodes entities", () => {
        group = new Text("Foo & Bar", [0, 0]);
        exportSVG(group, { raw: true }).then(function(svg) {
            contains(svg, "Foo &amp; Bar");
        });
    });

    it("preserves encoded entities", () => {
        group = new Text("Foo &amp; Bar", [0, 0]);
        exportSVG(group, { raw: true }).then(function(svg) {
            contains(svg, "Foo &amp; Bar");
        });
    });

    it("encodes entites in font name", () => {
        group = new Text("Foo", [0, 0], { font: "'serif'" });
        exportSVG(group, { raw: true }).then(function(svg) {
            contains(svg, "font:&#39;serif&#39;;");
        });
    });

    it("discards target origin", () => {
        group.append(new Text("Foo", [10, 10]));

        exportSVG(group, { raw: true }).then(function(svg) {
            contains(svg, "<g transform='matrix(1,0,0,1,-10,-10)' ><g>")
        });
    });

    it("does not reparent target", () => {
        let parent = new Group();
        parent.append(group);
        group.append(new Text("Foo", [10, 10]));

        exportSVG(group).then(function() {
            ok(group.parent === parent);
        });
    });

});
