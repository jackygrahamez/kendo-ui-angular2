import 'core-js/es6';

import { drawing as draw } from '@progress/kendo-drawing';

import CategoricalPlotArea from '../../src/chart/plotarea/categorical-plotarea';
import CandlestickChart from '../../src/chart/candlestick-chart/candlestick-chart';
import Candlestick from '../../src/chart/candlestick-chart/candlestick';
import ClipAnimation from '../../src/chart/animations/clip-animation';
import { RootElement, Box } from '../../src/core';
import { deepExtend } from '../../src/common';
import categoriesCount from '../../src/chart/utils/categories-count';

import { ok, equal, sameBox, sameLinePath } from '../../test/test-helpers';
import { createChart, destroyChart }  from '../test-helpers';

const chartBox = new Box(0, 0, 800, 600);
const SANS = "Arial,Helvetica,sans-serif";
const SANS12 = "12px " + SANS;
const TOLERANCE = 1;
let chart, candlestickChart, root, firstPoint, firstLine, pointBody;

function setupCandlestickChart(plotArea, options, rootOptions) {
    candlestickChart = new CandlestickChart(plotArea, options);

    root = new RootElement(rootOptions);
    root.append(candlestickChart);
    root.box = chartBox.clone();
    candlestickChart.reflow(chartBox);
    root.renderVisual();

    firstPoint = candlestickChart.points[0];
    firstLine = getLine(getMainGroup(firstPoint));
    pointBody = getBody(getMainGroup(firstPoint));
}

function getMainGroup(point) {
    return point.visual.children[0];
}

function getLine(group) {
    return group.children[2];
}

function getBody(group) {
    return group.children[0];
}

function stubPlotArea(getCategorySlot, getValueSlot, options) {
    return new function() {
        this.categoryAxis = this.primaryCategoryAxis = {
            getSlot: getCategorySlot,
            options: {
                axisCrossingValue: 0,
                categories: options.categoryAxis.categories
            }
        };

        this.valueAxis = {
            getSlot: getValueSlot,
            options: {
                axisCrossingValue: 0
            },
            startValue: function() {
                return 0;
            }
        };

        this.namedCategoryAxes = { };
        this.namedValueAxes = {};

        this.seriesCategoryAxis = function(series) {
            return series.categoryAxis ?
                this.namedCategoryAxes[series.categoryAxis] : this.primaryCategoryAxis;
        };

        this.options = options;
    };
}

(function() {
    const series = { data: [[2,4,1,3]], type: "candlestick" };
    const VALUE_AXIS_MAX = 4;
    const CATEGORY_AXIS_Y = 2;

    const getCategorySlot = function(categoryIndex) {
        return new Box(categoryIndex, CATEGORY_AXIS_Y, categoryIndex + 1, CATEGORY_AXIS_Y);
    };
    const getValueSlot = function(value = 0) {
        const valueY = VALUE_AXIS_MAX - value;
        const slotTop = Math.min(CATEGORY_AXIS_Y, valueY);
        const slotBottom = Math.max(CATEGORY_AXIS_Y, valueY);

        return new Box(0, slotTop, 0, slotBottom);
    };

    const plotArea = stubPlotArea(getCategorySlot, getValueSlot, {
            categoryAxis: {
                categories: ["A", "B"]
            }
        }
    );

    // ------------------------------------------------------------
    describe('Candlestick Chart', () => {
        beforeEach(() => {
            setupCandlestickChart(plotArea, { series: [ series ] });
        });

        it("creates points for candlestickChart data points", () => {
            equal(candlestickChart.points.length, series.data.length);
        });

        it("removes the series points if the visible is set to false", () => {
            chart = createChart({
                seriesDefaults: {
                    type: "candlestick"
                },
                series: [{
                    data: [[2,4,1,3]],
                    visible: false
                },{
                    data: [[2,4,1,3]]
                }]
            });

            const points = chart._plotArea.charts[0].points;

            ok(points.length === 1);

            destroyChart(chart);
        });

        it("creates empty points for null values", () => {
            setupCandlestickChart(plotArea, { series: [{
                data: [[2,4,1,3], null], type: "candlestick"
            }]});
            equal(candlestickChart.points[1], undefined);
        });

        it("creates empty points for undefined values", () => {
            setupCandlestickChart(plotArea, { series: [{
                data: [[2,4,1,3], undefined], type: "candlestick"
            }]});
            equal(candlestickChart.points[1], undefined);
        });

        it("creates empty points for partially undefined values", () => {
            setupCandlestickChart(plotArea, { series: [{
                data: [[2,4,1,3], [0, 1, undefined, 2]], type: "candlestick"
            }]});
            equal(candlestickChart.points[1], undefined);
        });

        it("empty points are not collapsed", () => {
            setupCandlestickChart(plotArea, { series: [{
                data: [[2,4,1,3], null, [2, 4, 1, 3]], type: "candlestick"
            }]});
            equal(candlestickChart.points[2].box.x1, 2);
        });

        it("reports minimum series value for default axis", () => {
            equal(candlestickChart.valueAxisRanges[undefined].min, series.data[0][2]);
        });

        it("reports maximum series value for default axis", () => {
            equal(candlestickChart.valueAxisRanges[undefined].max, series.data[0][1]);
        });

        it("reports number of categories", () => {
            setupCandlestickChart(plotArea, { series: [ series ]});
            equal(categoriesCount(candlestickChart.options.series), series.data.length);
        });

        it("sets point owner", () => {
            ok(candlestickChart.points[0].owner === candlestickChart);
        });

        it("sets point series", () => {
            ok(candlestickChart.points[0].series === series);
        });

        it("sets point series index", () => {
            ok(candlestickChart.points[0].seriesIx === 0);
        });

        it("sets point category", () => {
            equal(candlestickChart.points[0].category, "A");
        });

        it("sets correct category if multiple categoryAxis are used", () => {
            const plotArea = new CategoricalPlotArea([{
                categoryAxis: "A",
                type: "candlestick",
                data: [[2,4,1,3]]
            }, {
                type: "candlestick",
                categoryAxis: "B",
                data: [[1,2,3,4]]
            }], {
                categoryAxis: [{
                    name: "A",
                    categories: [1]
                }, {
                    name: "B",
                    categories: [2]
                }]
            });

            equal(plotArea.charts.length, 2);
            equal(plotArea.charts[0].points[0].category, 1);
            equal(plotArea.charts[1].points[0].category, 2);
        });

        it("sets point dataItem", () => {
            equal(typeof candlestickChart.points[0].dataItem, "object");
        });
    });

    // ------------------------------------------------------------

    describe('Candlestick Chart / Values exceeding value axis min or max options ', () => {

        it("values are not limited", 5, () => {
            const plotArea = stubPlotArea(
                function(categoryIndex) {
                    return new Box(categoryIndex, CATEGORY_AXIS_Y, categoryIndex + 1, CATEGORY_AXIS_Y);
                },
                function(value, axisCrossingValue, limit) {
                    ok(!limit);
                    return new Box();
                }, {
                    categoryAxis: {
                        categories: ["A"]
                    }
                }
            );

            setupCandlestickChart(plotArea, { series: [ {data: [[1,2,3,4]], type: "candlestick"} ] });
        });
    });

    // ------------------------------------------------------------
    describe('Candlestick Chart / Rendering', () => {
        beforeEach(() => {
            setupCandlestickChart(plotArea, {
                series: [ deepExtend({
                    line: {
                        width: 4,
                        color: "lineColor",
                        opacity: 0.5,
                        dashType: "dot"
                    },
                    color: "rectColor",
                    border: {
                        color: "borderColor",
                        width: 2,
                        opacity: 0.2,
                        dashType: "dot"
                    }
                },
                series)]
            });
        });

        it("sets line width", () => {
            equal(firstLine.options.stroke.width, 4);
        });

        it("sets line color", () => {
            equal(firstLine.options.stroke.color, "lineColor");
        });

        it("sets line opacity", () => {
            equal(firstLine.options.stroke.opacity, 0.5);
        });

        it("sets line dashType", () => {
            equal(firstLine.options.stroke.dashType, "dot");
        });

        it("sets rect border", () => {
            equal(pointBody.options.stroke.width, 2);
            equal(pointBody.options.stroke.color, "borderColor");
            equal(pointBody.options.stroke.opacity, 0.2);
            equal(pointBody.options.stroke.dashType, "dot");
        });

        it("sets rect color(open < close)", () => {
            equal(pointBody.options.fill.color, "rectColor");
        });

        it("sets rect down body color(open > close)", () => {
            setupCandlestickChart(plotArea, {
                series: [{
                    type: "candlestick",
                    data: [[3,4,1,2]],
                    downColor: "downColor"
                }]
            });

            equal(pointBody.options.fill.color, "downColor");
        });

        it("sets rect default color if down color is null or empty(open > close)", () => {
            setupCandlestickChart(plotArea, {
                series: [{
                    type: "candlestick",
                    data: [[3,4,1,2]],
                    color: "color",
                    downColor: ""
                }]
            });

            equal(pointBody.options.fill.color, "color");
        });

        it("creates visual", () => {
            ok(candlestickChart.visual);
        });

        it("creates clip animation", () => {
            ok(candlestickChart.animation);
            ok(candlestickChart.animation instanceof ClipAnimation);
            sameBox(candlestickChart.animation.options.box, root.box);
            sameLinePath(candlestickChart.animation.element, draw.Path.fromRect(root.box.toRect()));
        });

        it("does not create clip animation if transitions are disabled", () => {
            setupCandlestickChart(plotArea, { series: [ series ] }, {
                transitions: false
            });

            ok(!candlestickChart.animation);
            ok(!candlestickChart.visual.clip());
        });

        it("does not set clip on points by default", () => {
            const points = candlestickChart.points;
            for (let idx = 0; idx < points.length; idx++) {
                ok(!points[idx].visual.clip());
            }
        });

        it("sets animation clip path to points with zIndex", () => {
            setupCandlestickChart(plotArea, {
                series: [{
                    type: "candlestick",
                    data: [[3,4,1,2], null],
                    zIndex: 1
                }]
            });

            const clip = candlestickChart.points[0].visual.clip();
            ok(clip);
            ok(clip === candlestickChart.animation.element);
        });
    });

    // ------------------------------------------------------------
    describe('Candlestick Chart / Rendering / Highlight', () => {
        beforeEach(() => {
            setupCandlestickChart(plotArea, {
                series: [series]
            });
        });

        it("createHighlight renders default border width", () => {
            const rect = getBody(firstPoint.createHighlight());

            equal(rect.options.stroke.width, 1);
        });

        it("createHighlight renders custom border width", () => {
            firstPoint.options.highlight.border.width = 2;
            const rect = getBody(firstPoint.createHighlight());

            equal(rect.options.stroke.width, 2);
        });

        it("createHighlight renders default border color (computed)", () => {
            firstPoint.color = "#ffffff";
            const rect = getBody(firstPoint.createHighlight());

            equal(rect.options.stroke.color, "#cccccc");
        });

        it("createHighlight renders custom border color", () => {
            firstPoint.options.border.color = "red";
            const rect = getBody(firstPoint.createHighlight());

            equal(rect.options.stroke.color, "red");
        });

        it("createHighlight renders default border opacity", () => {
            const rect = getBody(firstPoint.createHighlight());

            equal(rect.options.stroke.opacity, 1);
        });

        it("createHighlight renders custom border opacity", () => {
            firstPoint.options.highlight.border.opacity = 0.5;
            const rect = getBody(firstPoint.createHighlight());

            equal(rect.options.stroke.opacity, 0.5);
        });

        it("createHighlight renders default border width", () => {
            const rect = getBody(firstPoint.createHighlight());

            equal(rect.options.stroke.width, 1);
        });

        it("createHighlight renders custom line width", () => {
            firstPoint.options.highlight.line.width = 2;
            const line = getLine(firstPoint.createHighlight());

            equal(line.options.stroke.width, 2);
        });

        it("createHighlight renders default line color (computed)", () => {
            firstPoint.color = "#ffffff";
            const line = getLine(firstPoint.createHighlight());

            equal(line.options.stroke.color, "#cccccc");
        });

        it("createHighlight renders custom line color", () => {
            firstPoint.options.highlight.line.color = "red";
            const line = getLine(firstPoint.createHighlight());

            equal(line.options.stroke.color, "red");
        });

        it("createHighlight renders default line opacity", () => {
            const line = getLine(firstPoint.createHighlight());

            equal(line.options.stroke.opacity, 1);
        });

        it("createHighlight renders custom line opacity", () => {
            firstPoint.options.highlight.line.opacity = 0.5;
            const line = getLine(firstPoint.createHighlight());

            equal(line.options.stroke.opacity, 0.5);
        });
    });

})();

(function() {
    const MARGIN = 5;
    const PADDING = 5;
    const BORDER = 5;
    let candlestickChart, candlestick;

    const plotArea = stubPlotArea(
        function(categoryIndex) {
            return new Box();
        },
        function(value) {
            return new Box();
        },
        {
            categoryAxis: { }
        }
    );

    function createCandlestickChart(options) {
        candlestickChart = new CandlestickChart(plotArea, {
            series: [deepExtend({
                name: "candlestickSeries",
                data: [[1,4,2,3]],
                border: {
                    opacity: 0.5,
                    dashType: "dot",
                },
                line: {
                    dashType: "dot",
                    color: "red",
                    opacity: 0.7,
                    width: 0.2
                },
                color: "#f00",
                opacity: 0.2,
                type: "candlestick"
            }, options)]
        });
        candlestick = candlestickChart.points[0];
    }

    // ------------------------------------------------------------
    describe('Candlestick Chart / Configuration', () => {
        beforeEach(() => {
            createCandlestickChart();
        });

        it("applies series color to point", () => {
            equal(candlestick.options.color, "#f00");
        });

        it("applies opacity to point", () => {
            equal(candlestick.options.opacity, 0.2);
        });

        it("applies border color to point", () => {
            createCandlestickChart({ border: { color: "point-border" } });
            equal(candlestick.options.border.color, "point-border");
        });

        it("applies dashType", () => {
            equal(candlestick.options.border.dashType, "dot");
        });

        it("applies line dashType", () => {
            equal(candlestick.options.line.dashType, "dot");
        });

        it("applies line color", () => {
            equal(candlestick.options.line.color, "red");
        });

        it("applies line width", () => {
            equal(candlestick.options.line.width, 0.2);
        });

        it("applies line opacity", () => {
            equal(candlestick.options.line.opacity, 0.7);
        });

        it("applies color function", () => {
            createCandlestickChart({
                color: function(bubble) { return "#f00" }
            });

            equal(candlestick.options.color, "#f00");
        });

        it("applies color function for each point", 2, () => {
            createCandlestickChart({
                data: [[1,4,2,3], [1,4,2,3]],
                color: function(bubble) { ok(true); }
            });
        });

        it("color fn argument contains value", 1, () => {
            createCandlestickChart({
                color: function(c) { equal(c.value.open, 1); }
            });
        });

        it("color fn argument contains dataItem", 1, () => {
            createCandlestickChart({
                color: function(c) {
                    equal(c.dataItem, [1,4,2,3]);
                }
            });
        });

        it("color fn argument contains series", 1, () => {
            createCandlestickChart({
                color: function(c) { equal(c.series.name, "candlestickSeries"); }
            });
        });
    });

})();

(function() {
    const VALUE = {
        open: 2,
        high: 4,
        low: 1,
        close: 3

    };
    const TOOLTIP_OFFSET = 5;
    const CATEGORY = "A";
    const SERIES_NAME = "series";
    let point, box, label, root;

    function createPoint(options, clipBox) {
        point = new Candlestick(VALUE,
            deepExtend({
                labels: { font: SANS12 }
            }, options)
        );

        point.category = CATEGORY;
        point.dataItem = { value: VALUE };
        point.series = { name: SERIES_NAME };

        point.owner = {
            formatPointValue: function(point, tooltipFormat) {
                return autoFormat(tooltipFormat, point.value);
            },
            seriesValueAxis: function(series) {
                return {
                    getSlot: function(a,b) {
                        return new Box(a,a,b,b);
                    }
                };
            },
            pane: {
                clipBox: function(){
                    return clipBox || new Box(0, 0, 100, 100);
                }
            }
        }

        box = new Box(0, 0, 100, 100);
        point.reflow(box);

        root = new RootElement();
        root.append(point);
        root.box = box.clone();
        root.renderVisual();
    }

    // ------------------------------------------------------------
    describe('Candlestick', () => {
        beforeEach(() => {
            createPoint();
        });

        it("sets point border width", () => {
            createPoint({ border: { width: 4 } });
            equal(point.options.border.width, 4);
        });

        it("sets point opacity", () => {
            createPoint({ opacity: 0.5 });
            equal(point.options.opacity, 0.5);
        });

        it("tooltipAnchor is at top right of point", () => {
            const { point: anchor, align } = point.tooltipAnchor();
            equal([anchor.x, anchor.y], [point.box.x2 + TOOLTIP_OFFSET, point.box.y1 + TOOLTIP_OFFSET], TOLERANCE);
            equal(align.horizontal, "left");
            equal(align.vertical, "top");
        });

        it("tooltipAnchor is limited to the clip box", () => {
            createPoint({}, new Box(0,2,100,4));

            const { point: anchor } = point.tooltipAnchor();
            equal([anchor.x, anchor.y],
                 [point.box.x2 + TOOLTIP_OFFSET, 2 + TOOLTIP_OFFSET], TOLERANCE)
        });

        it("highlightVisual returns _mainVisual", () => {
            createPoint({});
            const visual = point.highlightVisual();
            ok(visual instanceof draw.Group);
            ok(visual === point._mainVisual);
        });

        it("highlightVisualArgs returns an object with the options, the candlestick rect and the _mainVisual", () => {
            createPoint({});
            const result = point.highlightVisualArgs();
            equal(result.options, point.options);
            ok(point.box.toRect().equals(result.rect));
            ok(point._mainVisual === result.visual);
        });
    });
})();

(function() {
    const COLOR = "red";
    const DOWN_COLOR = "blue";
    const data = [{
        open: 2,
        high: 4,
        low: 1,
        close: 3,
        color: COLOR,
        downColor: DOWN_COLOR
    }];
    let point;

    function createCandlestickChart(candlestickSeries) {
        chart = createChart({
            series: [deepExtend({
                data: data,
                type: "candlestick"
            }, candlestickSeries)]
        });

        point = chart._plotArea.charts[0].points[0];
    }

    // ------------------------------------------------------------
    describe('Candlestick Chart / Data Binding', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("binds to 4-element array", () => {
            createCandlestickChart({
                data: [[2, 4, 0, 3]]
            });

            equal(point.value, { open: 2, high: 4, low: 0, close: 3 });
        });

        it("binds open, high, low and close field", () => {
            createCandlestickChart({
                openField: "open",
                highField: "high",
                lowField: "low",
                closeField: "close"
            });

            equal(point.value, { open: 2, high: 4, low: 1, close: 3 });
        });

        it("binds color field", () => {
            createCandlestickChart({
                openField: "open",
                highField: "high",
                lowField: "low",
                closeField: "close",
                colorField: "color"
            });

            equal(point.color, COLOR);
        });

        it("binds downColor field", () => {
            chart = createChart({                
                series: [{
                    data: [{ open: 3, high: 4, low: 1, close: 2, color: COLOR, downColor: DOWN_COLOR }],
                    type: "candlestick",
                    openField: "open",
                    highField: "high",
                    lowField: "low",
                    closeField: "close",
                    baseField: "downColor"
                }]
            });

            point = chart._plotArea.charts[0].points[0];

            equal(point.color, DOWN_COLOR);
        });

        it("evaluates color function", () => {
            createCandlestickChart({
                openField: "open",
                highField: "high",
                lowField: "low",
                closeField: "close",
                colorField: "color",
                color: function() {
                    return COLOR;
                }
            });

            equal(point.color, COLOR);
        });

        it("does not taint following points with down color", () => {
            chart = createChart({
                series: [{
                    data: [{
                        open: 3, high: 4, low: 1, close: 2, color: COLOR, downColor: DOWN_COLOR
                    }, {
                        open: 2, high: 4, low: 1, close: 3, color: COLOR, downColor: DOWN_COLOR
                    }],
                    type: "candlestick",
                    openField: "open",
                    highField: "high",
                    lowField: "low",
                    closeField: "close",
                    baseField: "downColor"
                }]
            });

            point = chart._plotArea.charts[0].points[1];

            equal(point.color, COLOR);
        });
    });
})();

(function() {
    let note;

    describe('Candlestick Chart / Note', () => {
        beforeEach(() => {
            chart = createChart({
                series: [{
                    type: "candlestick",
                    data: [{ open: 3, high: 4, low: 1, close: 2, noteText: "A" }]
                }]
            });

            note = chart._plotArea.charts[0].points[0].note;
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("should have text", () => {
            equal(note.text, "A");
        });
    });

    describe('Candlestick Chart / Note Template', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        function createNote(options) {
            chart = createChart({
                series: [{
                    type: "candlestick",
                    data: [{ open: 3, high: 4, low: 1, close: 2, noteText: "A", test: "test" }],
                    notes: deepExtend({}, options),
                    name: "name"
                }]
            });

            note = chart._plotArea.charts[0].points[0].note;
        }

        it("dataItem", () => {
            createNote({
                label: {
                    template: "#= dataItem.test #"
                }
            });

            equal(note.label.content, "test");
        });

        it("value", () => {
            createNote({
                label: {
                    template: "open: #= value.open # high: #= value.high # low: #= value.low # close: #= value.close #"
                }
            });

            equal(note.label.content, "open: 3 high: 4 low: 1 close: 2");
        });

        it("series", () => {
            createNote({
                label: {
                    template: "#= series.name #"
                }
            });

            equal(note.label.content, "name");
        });
    });
})();
