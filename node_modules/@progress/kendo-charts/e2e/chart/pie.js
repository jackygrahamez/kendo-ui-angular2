import 'core-js/es6';

import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';

import { RootElement, Title, Sector, Box, Point } from '../../src/core';
import { deepExtend, map, last } from '../../src/common';

import PieChart from '../../src/chart/pie-chart/pie-chart';
import PieSegment from '../../src/chart/pie-chart/pie-segment';
import PiePlotArea from '../../src/chart/plotarea/pie-plotarea';
import Legend from '../../src/chart/legend/legend';
import categoriesCount from '../../src/chart/utils/categories-count';

import { ok, equal, close, arrayClose, closePaths, sameBox, each, closeTextPosition, equalTexts } from '../../test/test-helpers';
import { triggerEvent, clickChart, createChart, destroyChart, getChartDomElement }  from '../test-helpers';
import '../../test/intl';
import '../../test/text-measure';

const chartBox = new Box(0, 0, 800, 600);
const TOLERANCE = 0.1;
let plotArea, pieChart, firstSegment, root;

function setupPieChart(plotArea, options) {

    pieChart = new PieChart(plotArea, deepExtend({}, { padding: 60 }, options));

    root = new RootElement();
    root.append(pieChart);

    root.box = chartBox;
    pieChart.reflow(chartBox);

    root.renderVisual();

    firstSegment = pieChart.points[0];
}

function getTextBoxes() {
    return map(pieChart.points, function(item) {
        return item.label.visual;
    });
}

function getTexts() {
    return map(getTextBoxes(), function(item) {
        return last(item.children);
    });
}

describe('Pie Chart / pointVisibility', () => {
    let element;
    let chart;

    afterEach(() => {
        destroyChart(chart);
    });

    it('should hide points based on pointVisibility', () => {
        chart = createChart({
            series: [{
                type: "pie",
                data: [ 1, 2 ],
                pointVisibility: { 1: false }
            }]
        });

        const points = chart.findSeriesByIndex(0).points();
        expect(points.length).toBe(1);
        expect(points[0].value).toBe(1);
    });
});

(function() {
    const values = { type: "pie", data: [1, 2] };
    const dataValues = {
        type: "pie",
        data: [{
           value: 1,
           category: "A",
           color: "red",
           explode: true
       }, {
           value: 2,
           category: "B"
       }]
    };

    function PlotAreaStub() { }

    deepExtend(PlotAreaStub.prototype, {
        options: { }
    });

    // ------------------------------------------------------------
    describe('Pie Chart / Array with values', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupPieChart(plotArea, { series: [ values ] });
        });

        it("creates points for pie chart data points", () => {
            equal(pieChart.points.length, values.data.length);
        });

        it("points have set angle", () => {
            each(pieChart.points, function() {
                ok(this.sector.angle);
            });
        });

        it("points have set startAngle", () => {
            each(pieChart.points, function() {
                ok(this.sector.angle);
            });
        });

        it("points have set owner", () => {
            ok(firstSegment.owner === pieChart);
        });

        it("sets segment category", () => {
            equal(firstSegment.category, "");
        });

        it("sets segment series", () => {
            ok(firstSegment.series === values);
        });

        it("sets segment series index", () => {
            ok(firstSegment.seriesIx === 0);
        });

        it("sets segment dataItem", () => {
            equal(typeof firstSegment.dataItem, "number");
        });
    });

    // ------------------------------------------------------------
    describe('Pie Chart / Array with items', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupPieChart(plotArea, { series: [ dataValues ] });
        });

        it("sets segment category", () => {
            equal(firstSegment.category, "A");
        });

        it("points have set owner", () => {
            ok(firstSegment.owner === pieChart);
        });

        it("sets segment series", () => {
            ok(firstSegment.series === dataValues);
        });

        it("sets segment series index", () => {
            ok(firstSegment.seriesIx === 0);
        });

        it("sets segment dataItem", () => {
            equal(typeof firstSegment.dataItem, "object");
        });

        it("sets segment percentage", () => {
            close(firstSegment.percentage, 0.333, TOLERANCE);
        });

        it("sets segment percentage to zero if total is zero", () => {
            plotArea = new PlotAreaStub();
            setupPieChart(plotArea, { series: [{
                type: "pie",
                data: [{
                   value: 0
                }]
            }] });
            equal(firstSegment.percentage, 0);
        });

        it("sets segment explode", () => {
            ok(firstSegment.explode == true);
        });

        it("sets segment different center if segment have explode sets to true", () => {
            ok(firstSegment.sector.center != pieChart.points[1].sector.center);
        });
    });

    // ------------------------------------------------------------
    describe('Pie Chart / Legend items', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupPieChart(plotArea, { series: [ { type: "pie", data: dataValues.data } ] });
        });

        it("return legend item for each segment", () => {
            equal(pieChart.legendItems.length, 2);
        });

        it("set legend item point index", () => {
            equal(pieChart.legendItems[0].pointIndex, 0);
            equal(pieChart.legendItems[1].pointIndex, 1);
        });

        it("set legend item name to category", () => {
            equal(pieChart.legendItems[0].text, "A");
        });

        it("set legend item color", () => {
            equal(pieChart.legendItems[0].markerColor, "red");
        });

        it("skip points with visibleInLegend set to false", () => {
            const data = [{
                value: 1,
                category: "A"
            }, {
                value: 2,
                category: "B",
                visibleInLegend: false
            }];

            setupPieChart(plotArea, { series: [ { type: "pie", data: data } ] });
            equal(pieChart.legendItems.length, 1);
        });

        it("skip points with null or empty text", () => {
            const data = [{
                    value: 1,
                    category: ""
                }, {
                    value: 2,
                    category: null
                }, {
                    value: 3,
                    category: "foo"
                }];

            setupPieChart(plotArea, { series: [ { type: "pie", data: data } ] });
            equal(pieChart.legendItems.length, 1);
        });

        it("set legend item name with template", () => {
            setupPieChart(plotArea, {
                series: [ { type: "pie", data: dataValues.data, test: "test" } ],
                legend: {
                    labels: {
                        template: "#= series.test #"
                    }
                }
            });

            equal(pieChart.legendItems[0].text, "test");
            setupPieChart(plotArea, { series: [ {
                type: "pie",
                data: dataValues.data,
                legend: {
                    labels: {
                        template: "#= text #"
                    }
                }
            } ] });
            equal(pieChart.legendItems[0].text, "A");
        });
    });

    // ------------------------------------------------------------

    function setupInactiveItemsPieChart(options) {
        setupPieChart(plotArea, deepExtend({ series: [ { type: "pie", data: [{
                value: 1,
                category: "A",
                color: "red"
            }, {
                value: 2,
                category: "B",
                color: "blue",
                visible: false
            }] } ],
            legend: {
                inactiveItems: {
                    labels: {
                        color: "foo",
                        font: "bar"
                    },
                    markers: {
                        color: "green"
                    }
                }
            }
        }, options));
    }

    describe('Pie Chart / Inactive Legend items', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupInactiveItemsPieChart();
        });

        it("return legend item for each segment", () => {
            equal(pieChart.legendItems.length, 2);
        });

        it("set legend item name to category", () => {
            equal(pieChart.legendItems[0].text, "A");
            equal(pieChart.legendItems[1].text, "B");
        });

        it("set legend item color", () => {
            equal(pieChart.legendItems[0].markerColor, "red");
            equal(pieChart.legendItems[1].markerColor, "green");
        });

        it("set legend item labels", () => {
            const inactiveLabels = pieChart.legendItems[1].labels;
            equal(inactiveLabels.color, "foo");
            equal(inactiveLabels.font, "bar");
        });

        it("set legend item text with template", () => {
            setupInactiveItemsPieChart({
                legend: {
                    inactiveItems: {
                        labels: {
                            template: "baz"
                        }
                    }
                }
            });
            equal(pieChart.legendItems[1].text, "baz");
        });

        it("set inactive legend item text with labels template if inactive items template is not specified", () => {
            setupInactiveItemsPieChart({
                legend: {
                    labels: {
                        template: "baz"
                    }
                }
            });
            equal(pieChart.legendItems[1].text, "baz");
        });
    });

})();


(function() {
    const DEFAULT_DATA = [{
        value: 10,
        explode: true,
        color: "red",
        category: "A",
        test: "test"
    }, {
        value: 50,
        explode: false,
        color: "red",
        category: "B"
    }];
    let chart, pieChart, firstSegment;

    function createPieChart(data) {
        chart = createChart({
            series: [{
                data: data || DEFAULT_DATA,
                type: "pie",
                field: "value",
                categoryField: "category",
                colorField: "color",
                explodeField: "explode"
            }]
        });

        pieChart = chart._plotArea.charts[0];
        firstSegment = pieChart.points[0];
    }

    // ------------------------------------------------------------
    describe('Pie Chart / Data', () => {
        beforeEach(() => {
            createPieChart();
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("sets segment angle based on value", () => {
            equal(firstSegment.sector.angle, 60);
        });

        it("sets segment angle for negative values", () => {
            destroyChart(chart);
            createPieChart([{
                value: -10
            }, {
                value: 10
            }]);

            equal(firstSegment.sector.angle, 180);
        });

        it("sets segment category from dataItem", () => {
            equal(firstSegment.category, "A");
        });

        it("sets segment color from dataItem", () => {
            equal(firstSegment.options.color, "red");
        });

        it("sets segment explode from dataItem", () => {
            ok(firstSegment.explode == true);
        });

        it("sets legend item name from dataItem", () => {
            destroyChart(chart);
            chart = createChart({
                series: [{
                    type: "pie",
                    field: "value",
                    categoryField: "category",
                    data: [{
                        value: 10,
                        category: "A",
                        test: "test"
                    }]
                }],
                legend: {
                    labels: {
                        template: "#= dataItem.test #"
                    }
                }
            });

            equal(chart._plotArea.charts[0].legendItems[0].text, "test");
        });
    });

})();


(function() {
    const VALUE = 1;
    const CATEGORY = "A";
    const PERCENTAGE = 0.5;
    const SERIES_NAME = "series";
    let point, box, label, root, sector, segment;

    function createSegment(options) {
        segment = new PieSegment(
            VALUE,
            new Sector(new Point(0,0), 100, 90, 100),
            options
        );

        segment.percentage = PERCENTAGE;
        segment.category = CATEGORY;
        segment.series = { name: SERIES_NAME };
        segment.dataItem = { value: VALUE };

        box = new Box(0, 0, 100, 100);
        segment.reflow(box);

        root = new RootElement();
        root.box = box;
        root.append(segment);
        root.renderVisual();
        sector = segment.visual.children[0];
    }

    // ------------------------------------------------------------
    describe('Pie Segment', () => {
        beforeEach(() => {
            createSegment();
        });

        it("fills target box", () => {
            sameBox(segment.box, box);
        });

        it("sets border color", () => {
            createSegment({ border: { color: "red" } });
            equal(sector.options.stroke.color, "red");
        });

        it("sets pie border width", () => {
            createSegment({ border: { width: 4 } });
            equal(sector.options.stroke.width, 4);
        });

        it("sets pie border opacity", () => {
            createSegment({ border: { width: 4, opacity: 0.5 } });
            equal(sector.options.stroke.opacity, 0.5);
        });

        it("tooltipAnchor is set distance from segment", () => {
            const { point, align } = segment.tooltipAnchor();
            arrayClose([Math.round(point.x), Math.round(point.y)], [80, -67], TOLERANCE);
            equal(align.horizontal, "left");
            equal(align.vertical, "bottom");
        });

        it("renders overlay with same path", () => {
            closePaths(sector, segment.visual.children[1]);
        });

        it("does not render overlay when no overlay is defined", () => {
            createSegment({ overlay: null });
            equal(segment.visual.children.length, 1);
        });
    });

    // ------------------------------------------------------------
    describe('Pie Segment / custom visual', () => {

        it("adds custom visual", () => {
            let visual;
            createSegment({
                visual: function(e) {
                    visual = new draw.Path();
                    return visual;
                }
            });
            equal(segment.visual.children.length, 1);
            ok(segment.visual.children[0] === visual);
        });

        it("doesn't add visual  if custom visual function returns undefined", () => {
            createSegment({
                visual: function() {}
            });
            equal(segment.visual.children.length, 0);
        });

        it("passes options to custom visual function", () => {
            createSegment({
                visual: function(e) {
                   equal(segment.options, e.options);
                }
            });
        });

        it("passes category, dataItem, value, series and percentage to custom visual function", () => {
            createSegment({
                visual: function(e) {
                   equal(segment.category, CATEGORY);
                   equal(segment.dataItem.value, VALUE);
                   equal(segment.value, VALUE);
                   equal(e.series.name, SERIES_NAME);
                   equal(e.percentage, PERCENTAGE);
                }
            });
        });

        it("passes radius, startAngle, endAngle and center to custom visual function", () => {
            createSegment({
                visual: function(e) {
                   const startAngle = (segment.sector.startAngle + 180) % 360;
                   equal(e.radius, segment.sector.radius);
                   equal(e.startAngle, startAngle);
                   equal(e.endAngle, startAngle + segment.sector.angle);
                   equal(e.center.x, segment.sector.center.x);
                   equal(e.center.y, segment.sector.center.y);
                }
            });
        });

        it("createVisual creates default visual", () => {
            createSegment({
                visual: function(e) {
                   const defaultVisual = e.createVisual();
                   ok(defaultVisual instanceof draw.Group);
                   ok(defaultVisual.children[0] instanceof draw.Path);
                   ok(defaultVisual.children[1] instanceof draw.Path);
                }
            });
        });
    });

    // ------------------------------------------------------------
    describe('Pie Segment / Highlight', () => {
        beforeEach(() => {
            createSegment();
        });

        it("createHighlight renders same path", () => {
            closePaths(sector, segment.createHighlight());
        });

        it("highlightOverlay renders default border width", () => {
            const highlight = segment.createHighlight();

            equal(highlight.options.stroke.width, 1);
        });

        it("highlightOverlay renders custom border width", () => {
            segment.options.highlight.border.width = 2;
            const highlight = segment.createHighlight();

            equal(highlight.options.stroke.width, 2);
        });

        it("highlightOverlay renders custom highlight color", () => {
            segment.options.highlight.color = "red";
            const highlight = segment.createHighlight();

            equal(highlight.options.fill.color, "red");
        });

        it("highlightOverlay renders custom border color", () => {
            segment.options.highlight.border.color = "red";
            const highlight = segment.createHighlight();

            equal(highlight.options.stroke.color, "red");
        });

        it("highlightOverlay renders custom border opacity", () => {
            segment.options.highlight.border.opacity = 0.5;
            const highlight = segment.createHighlight();

            equal(highlight.options.stroke.opacity, 0.5);
        });

        it("highlightVisual returns segment visual", () => {
            const visual = segment.highlightVisual();

            ok(visual instanceof draw.Path);
            ok(visual === segment.visual.children[0]);
        });

        it("highlightVisualArgs returns an object with the options, the visual and the sector options", () => {
            const result = segment.highlightVisualArgs();
            const sector = segment.sector;
            equal(result.options, segment.options);
            ok(segment.visual === result.visual);
            equal(result.radius, sector.radius);
            equal(result.innerRadius, sector.innerRadius);
            ok(result.center instanceof geom.Point);
            equal(result.center.x, sector.center.x);
            equal(result.center.y, sector.center.y);
            equal(result.startAngle, sector.startAngle);
            equal(result.endAngle, sector.angle + sector.startAngle);
        });
    });

})();

(function() {
    const MARGIN = 10;
    let chart, model, title, legend, plotArea;

    function createPieChart(series) {
        chart = createChart({
            title: {
                text: "Chart Title"
            },
            series: series,
            chartArea: {
                margin: 0
            }
        });

        model = chart._model;
        title = model.children[0];
        legend = model.children[1];
        plotArea = model.children[2];
    }

    describe('Pie Chart / Model', () => {
        beforeEach(() => {
            createPieChart([{
                name: "Value",
                type: "pie",
                data: [{
                    value: 100,
                    category: "Value A"
                }, {
                    value: 200,
                    category: "Value B"
                }, {
                    value: 300,
                    category: "Value C"
                }]
            }]);
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("model is a RootElement", () => {
            ok(model instanceof RootElement);
        });

        it("title is created", () => {
            ok(title instanceof Title);
        });

        it("title text is set", () => {
            equal(title.options.text, "Chart Title");
        });

        it("title box is positioned at top", () => {
            equal(title.box.y1, 0);
        });

        it("legend is created", () => {
            ok(legend instanceof Legend);
        });

        it("legend series are populated", () => {
            equal(legend.options.items[0].text, "Value A");
        });

        it("points can be removed with visible false", () => {
            destroyChart(chart);
            createPieChart([{
                type: "pie",
                data: [{
                    value: 100,
                    category: "Value A"
                }, {
                    value: 200,
                    category: "Value B",
                    visible: false
                }, {
                    value: 300,
                    category: "Value C",
                    visible: false
                }]
            }]);

            equal(chart._plotArea.charts[0].points.length, 1);
        });

        it("points can be excluded from legend", () => {
            destroyChart(chart);
            createPieChart([{
                name: "Value",
                type: "pie",
                data: [{
                    value: 100,
                    category: "Value A",
                    visibleInLegend: false
                }]
            }]);

            equal(legend.options.items.length, 0);
        });

        it("legend is positioned at right", () => {
            equal(legend.box.x1,
                model.box.width() - legend.box.width());
        });

        it("legend is positioned at vertical center", () => {
            const titleHeight = title.box.height(),
                vCenter = titleHeight +
                          ((model.box.height() - titleHeight - legend.box.height()) / 2);
            equal(legend.box.y1, vCenter);
        });

        it("plotArea is created", () => {
            ok(plotArea instanceof PiePlotArea);
        });
    });

})();


(function() {
    const PADDING = 5;
    const MARGIN = 5;
    const START_ANGLE = 20;
    let pieSegment;

    function PlotAreaStub() { }

    deepExtend(PlotAreaStub.prototype, {
        options: { }
    });

    function createPieChart(seriesOptions, options) {
        plotArea = new PlotAreaStub();
        setupPieChart(plotArea, deepExtend({
            series: [
                deepExtend({
                    data: [{ value: 1, explode: true }]
                }, seriesOptions)
            ],
            padding: PADDING,
            startAngle: START_ANGLE,
            connectors: { width: 2, color: "blue", padding: 4 }
        }, options));
        pieSegment = firstSegment;
    }

    // ------------------------------------------------------------
    describe('Pie Chart / Configuration', () => {
        beforeEach(() => {
            createPieChart();
        });

        it("sets padding to the pie chart", () => {
            equal(pieChart.options.padding, PADDING);
        });

        it("sets startAngle to the pie chart", () => {
            equal(pieChart.options.startAngle, START_ANGLE);
        });

        it("sets points if points are more then 1", () => {
            equal(pieSegment.explode, false);
        });

        it("sets connectors settings to the pie labels", () => {
            equal(pieChart.options.connectors.width, 2);
            equal(pieChart.options.connectors.color, "blue");
            equal(pieChart.options.connectors.padding, 4);
        });

        it("sets default radius to 5 pixels", () => {
            createPieChart({}, { padding: 500 });
            equal(pieSegment.sector.radius, 5);
        });

        it("applies color function", () => {
            createPieChart({
                color: function(p) { return "#f00" }
            });

            equal(pieSegment.options.color, "#f00");
        });

        it("applies color function for each point", 2, () => {
            createPieChart({
                data: [1, 2],
                color: function() { ok(true); }
            });
        });

        it("color fn argument contains value", 1, () => {
            createPieChart({
                color: function(p) { equal(p.value, 1); }
            });
        });

        it("color fn argument contains percentage", 1, () => {
            createPieChart({
                color: function(p) { equal(p.percentage, 1); }
            });
        });

        it("color fn argument contains dataItem", 1, () => {
            createPieChart({
                color: function(p) {
                    equal(p.dataItem, {
                        "explode": true,
                        "value": 1
                    });
                }
            });
        });

        it("color fn argument contains series", 1, () => {
            createPieChart({
                name: "pieSeries",
                color: function(p) { equal(p.series.name, "pieSeries"); }
            });
        });
    });

    // ------------------------------------------------------------
    describe('Pie Chart / Labels', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
        });

        it("applies full label format", () => {
            setupPieChart(plotArea, {
                series: [{
                    data: [1, 2],
                    labels: { visible: true, format: "{0:C}" }
                }]
            });

            equalTexts(getTexts(), ["$1.00", "$2.00"]);
        });

        it("applies simple label format", () => {
            setupPieChart(plotArea, {
                series: [{
                    data: [1, 2],
                    labels: { visible: true, format: "C" }
                }]
            });

            equalTexts(getTexts(), ["$1.00", "$2.00"]);
        });
    });

    // ------------------------------------------------------------
    describe('Pie Chart / Labels / Configuration', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupPieChart(plotArea, {
                series: [ { data: [1, 2],
                    labels: {
                        visible: false,
                        color: "labels-color",
                        background: "labels-background",
                        border: {
                            color: "labels-border-color",
                            width: 2,
                            dashType: "dot"
                        },
                        padding: PADDING,
                        margin: MARGIN,
                        distance: 20,
                        font: "labels-font",
                        position: "center"
                    }
                } ]
            });
            pieSegment = firstSegment;
        });

        it("applies visible to data labels", () => {
            equal(pieSegment.options.labels.visible, false);
        });

        it("applies color to data labels", () => {
            equal(pieSegment.options.labels.color, "labels-color");
        });

        it("applies background to data labels", () => {
            equal(pieSegment.options.labels.background, "labels-background");
        });

        it("applies border color to data labels", () => {
            equal(pieSegment.options.labels.border.color, "labels-border-color");
        });

        it("applies border width to data labels", () => {
            equal(pieSegment.options.labels.border.width, 2);
        });

        it("applies padding to data labels", () => {
            equal(pieSegment.options.labels.padding, PADDING);
        });

        it("applies margin to data labels", () => {
            equal(pieSegment.options.labels.margin, MARGIN);
        });

        it("applies margin to data labels", () => {
            equal(pieSegment.options.labels.border.dashType, "dot");
        });

        it("applies distance to data labels", () => {
            equal(pieSegment.options.labels.distance, 20);
        });

        it("applies font to data labels", () => {
            equal(pieSegment.options.labels.font, "labels-font");
        });

        it("applies font to data labels", () => {
            equal(pieSegment.options.labels.position, "center");
        });
    });

    // ------------------------------------------------------------
    describe('Pie Chart / Labels / Connectors (1)', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupPieChart(plotArea, {
                series: [ {
                    data: [ 1, 2, 3, 4, 4, 3, 2, 1 ],
                    labels: {
                        visible: true,
                        distance: 20
                    }
                } ]
            });
        });

        it("start point", () => {
            const points = [];
            each(pieChart._connectorLines, function() {
                const point = this.segments[0].anchor();
                points.push([ point.x, point.y ]);
            });

            arrayClose(points, [ [ 438.17, 59.004 ], [ 543.42, 102.6 ],
                           [ 640.996, 261.83 ], [ 543.42, 497.4 ],
                           [ 256.58, 497.4 ], [ 159.004, 261.83 ],
                           [ 256.58, 102.6 ], [ 361.83, 59.004 ] ],
                       TOLERANCE);
        });

        it("middle point", () => {
            const points = [];
            each(pieChart._connectorLines, function() {
                const point = this.segments[1].anchor();
                points.push([ point.x, point.y ]);
            });

            arrayClose(points, [ [ 440.467, 44.5 ], [ 552.211, 90.5 ],
                           [ 649.393, 260.5 ], [ 553.196, 511.5 ],
                           [ 246.804, 511.5 ], [ 150.607, 260.5 ],
                           [ 247.789, 90.5 ], [ 359.533, 44.5 ] ],
                       TOLERANCE);
        });

        it("end point", () => {
            const points = [];
            each(pieChart._connectorLines, function() {
                const point = this.segments[2].anchor();
                points.push([ point.x, point.y ]);
            });

            arrayClose(points, [ [ 477.185, 44.5 ], [ 560.921, 90.5 ],
                           [ 654.145, 260.5 ], [ 557.196, 511.5 ],
                           [ 242.804, 511.5 ], [ 145.855, 260.5 ],
                           [ 239.079, 90.5 ], [ 322.815, 44.5 ] ],
                       TOLERANCE);
        });

        it("middle point Y and end point Y should be equal", () => {
            each(pieChart._connectorLines, function() {
                if (this.segments.length > 3) {
                    equal(this.segments[2].anchor().y, this.segments[3].anchor().y);
                } else {
                    equal(this.segments[1].anchor().y, this.segments[2].anchor().y);
                }
            });
        });
    });

    // ------------------------------------------------------------
    describe('Pie Chart / Labels / Connectors (2)', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupPieChart(plotArea, {
                series: [ {
                    data: [ 1, 2, 3, 4, 5, 6, 6, 5, 4, 3, 2, 1 ],
                    labels: {
                        visible: true,
                        distance: 20
                    }
                } ]
            });
        });

        it("start point", () => {
            const points = [];
            each(pieChart._connectorLines, function() {
                const point = this.segments[0].anchor();
                points.push([ point.x, point.y ]);
            });

            arrayClose(points, [ [ 418.234, 56.682 ], [ 471.92, 66.84 ],
                           [ 552.132, 109.233 ], [ 627.133, 210.857 ],
                           [ 633.16, 371.92 ], [ 505.868, 519.836 ],
                           [ 294.132, 519.836 ], [ 166.84, 371.92 ],
                           [ 172.867, 210.857 ], [ 247.868, 109.233 ],
                           [ 328.08, 66.84 ], [ 381.766, 56.682 ] ],
                       TOLERANCE);
        });

        it("second point", () => {
            const points = [];
            each(pieChart._connectorLines, function() {
                const point = this.segments[1].anchor();
                points.push([ point.x, point.y ]);
            });

            arrayClose(points, [ [ 419.746, 36.5 ], [ 476.343, 52.5 ],
                           [ 561.489, 97.5 ], [ 637.365, 205.5 ],
                           [ 642.4, 377.5 ], [ 513.411, 535.5 ],
                           [ 286.589, 535.5 ], [ 157.6, 377.5 ],
                           [ 162.635, 205.5 ], [ 238.511, 97.5 ],
                           [ 323.657, 52.5 ], [ 380.254, 36.5 ] ],
                       TOLERANCE);
        });

        it("end point", () => {
            const points = [];
            each(pieChart._connectorLines, function() {
                const point = this.segments[2].anchor();
                points.push([ point.x, point.y ]);
            });

            arrayClose(points, [ [ 446.744, 36.5 ], [ 498.367, 52.5 ],
                           [ 569.101, 97.5 ], [ 641.365, 205.5 ],
                           [ 646.4, 377.5 ], [ 520.964, 535.5 ],
                           [ 279.036, 535.5 ], [ 153.6, 377.5 ],
                           [ 158.635, 205.5 ], [ 230.899, 97.5 ],
                           [ 301.633, 52.5 ], [ 353.256, 36.5 ] ],
                       TOLERANCE);
        });

        it("middle point Y and end point Y should be equal", () => {
            each(pieChart._connectorLines, function() {
                if (this.segments.length > 3) {
                    equal(this.segments[2].anchor().y, this.segments[3].anchor().y);
                } else {
                    equal(this.segments[1].anchor().y, this.segments[2].anchor().y);
                }
            });
        });
    });

    // ------------------------------------------------------------
    describe('Pie Chart / Labels / Connectors / Stress test case 1', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupPieChart(plotArea, {
                series: [ {
                    data: [ 40, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 140 ],
                    labels: {
                        visible: true,
                        distance: 20
                    }
                } ]
            });
        });

        it("start point", () => {
            const points = [];
            each(pieChart._connectorLines, function() {
                const point = this.segments[0].anchor();
                points.push([ point.x, point.y ]);
            });

            arrayClose(points, [ [ 544.67, 103.514 ], [ 634.116, 231.257 ],
                           [ 636.179, 238.72 ], [ 638.005, 246.244 ],
                           [ 639.591, 253.823 ], [ 640.935, 261.448 ],
                           [ 642.037, 269.111 ], [ 642.895, 276.806 ],
                           [ 643.509, 284.525 ], [ 643.877, 292.258 ],
                           [ 644, 300 ], [ 643.877, 307.742 ],
                           [ 643.509, 315.475 ], [ 642.895, 323.194 ],
                           [ 642.037, 330.889 ], [ 640.935, 338.552 ],
                           [ 639.591, 346.177 ], [ 638.005, 353.756 ],
                           [ 636.179, 361.28 ], [ 205.834, 447.769 ] ],
                       TOLERANCE);
        });

        it("second point", () => {
            const points = [];
            each(pieChart._connectorLines, function() {
                const point = this.segments[1].anchor();
                points.push([ point.x, point.y ]);
            });

            arrayClose(points, [ [ 553.516, 91.5 ], [ 613.594, 155.5 ],
                           [ 622.651, 171.5 ], [ 630.294, 187.5 ],
                           [ 636.655, 203.5 ], [ 641.832, 219.5 ],
                           [ 645.898, 235.5 ], [ 648.905, 251.5 ],
                           [ 650.89, 267.5 ], [ 651.877, 283.5 ],
                           [ 651.877, 299.5 ], [ 651.877, 315.5 ],
                           [ 650.89, 331.5 ], [ 648.905, 347.5 ],
                           [ 645.898, 363.5 ], [ 641.832, 379.5 ],
                           [ 636.655, 395.5 ], [ 630.294, 411.5 ],
                           [ 622.651, 427.5 ], [ 196.342, 458.5 ] ],
                       TOLERANCE);
        });

        it("end point", () => {
            const points = [];
            each(pieChart._connectorLines, function() {
                const point = this.segments[2].anchor();
                points.push([ point.x, point.y ]);
            });

            arrayClose(points, [ [ 562.132, 91.5 ], [ 617.594, 155.5 ],
                           [ 626.651, 171.5 ], [ 634.294, 187.5 ],
                           [ 640.655, 203.5 ], [ 645.832, 219.5 ],
                           [ 649.898, 235.5 ], [ 652.905, 251.5 ],
                           [ 654.89, 267.5 ], [ 655.877, 283.5 ],
                           [ 655.877, 299.5 ], [ 655.877, 315.5 ],
                           [ 654.89, 331.5 ], [ 652.905, 347.5 ],
                           [ 649.898, 363.5 ], [ 645.832, 379.5 ],
                           [ 640.655, 395.5 ], [ 634.294, 411.5 ],
                           [ 626.651, 427.5 ], [ 192.342, 458.5 ] ],
                       TOLERANCE);
        });

        it("middle point Y and end point Y should be equal", () => {
            each(pieChart._connectorLines, function() {
                if (this.segments.length > 3) {
                    equal(this.segments[2].anchor().y, this.segments[3].anchor().y);
                } else {
                    equal(this.segments[1].anchor().y, this.segments[2].anchor().y);
                }
            });
        });
    });

    // ------------------------------------------------------------
    describe('Pie Chart / Labels / Connectors / Stress test case 2', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupPieChart(plotArea, {
                series: [ {
                    data: [ 70, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 40, 40, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20 ],
                    labels: {
                        visible: true,
                        distance: 20
                    }
                } ]
            });
        });

        it("start point", () => {
            const points = [];
            each(pieChart._connectorLines, function() {
                const point = this.segments[0].anchor();
                points.push([ point.x, point.y ]);
            });

            arrayClose(points, [ [ 622.251, 199.299 ], [ 580.792, 463.86 ],
                           [ 575.334, 469.688 ], [ 569.688, 475.334 ],
                           [ 563.86, 480.792 ], [ 557.857, 486.057 ],
                           [ 551.685, 491.122 ], [ 545.351, 495.983 ],
                           [ 538.86, 500.633 ], [ 532.222, 505.069 ],
                           [ 525.441, 509.286 ], [ 368.152, 541.913 ],
                           [ 158.087, 331.848 ], [ 190.714, 174.559 ],
                           [ 194.931, 167.778 ], [ 199.367, 161.14 ],
                           [ 204.017, 154.649 ], [ 208.878, 148.315 ],
                           [ 213.943, 142.143 ], [ 219.208, 136.14 ],
                           [ 224.666, 130.312 ], [ 230.312, 124.666 ],
                           [ 236.14, 119.208 ], [ 242.143, 113.943 ],
                           [ 248.315, 108.878 ], [ 321.569, 68.949 ] ],
                       TOLERANCE);
        });

        it("second point", () => {
            const points = [];
            each(pieChart._connectorLines, function() {
                const point = this.segments[1].anchor();
                points.push([ point.x, point.y ]);
            });

            arrayClose(points, [ [ 632.824, 193.5 ], [ 588.792, 463.86 ],
                           [ 583.334, 469.688 ], [ 577.688, 475.334 ],
                           [ 571.86, 480.792 ], [ 565.857, 486.057 ],
                           [ 559.685, 491.122 ], [ 551.668, 504.5 ],
                           [ 541.101, 520.5 ], [ 515.122, 536.5 ],
                           [ 479.034, 552.5 ], [ 366.495, 554.5 ],
                           [ 149.512, 335.5 ], [ 182.714, 174.559 ],
                           [ 186.931, 167.778 ], [ 191.367, 161.14 ],
                           [ 196.017, 154.649 ], [ 200.878, 148.315 ],
                           [ 205.943, 142.143 ], [ 211.882, 129.5 ],
                           [ 218.485, 113.5 ], [ 234.899, 97.5 ],
                           [ 254.703, 81.5 ], [ 279.454, 65.5 ],
                           [ 312.942, 49.5 ], [ 375.813, 33.5 ] ],
                       TOLERANCE);
        });

        it("end point", () => {
            const points = [];

            each(pieChart._connectorLines, function() {
                const point = this.segments[2].anchor();
                points.push([ point.x, point.y ]);
            });

            arrayClose(points, [ [ 636.824, 193.5 ], [ 631.581, 408.5 ],
                           [ 624.187, 424.5 ], [ 615.408, 440.5 ],
                           [ 605.07, 456.5 ], [ 592.935, 472.5 ],
                           [ 578.652, 488.5 ], [ 565.679, 504.5 ],
                           [ 545.101, 520.5 ], [ 519.122, 536.5 ],
                           [ 483.034, 552.5 ], [ 322.815, 554.5 ],
                           [ 145.512, 335.5 ], [ 156.516, 225.5 ],
                           [ 161.269, 209.5 ], [ 167.176, 193.5 ],
                           [ 174.325, 177.5 ], [ 182.833, 161.5 ],
                           [ 192.863, 145.5 ], [ 200.638, 129.5 ],
                           [ 214.485, 113.5 ], [ 230.899, 97.5 ],
                           [ 250.703, 81.5 ], [ 275.454, 65.5 ],
                           [ 308.942, 49.5 ], [ 371.813, 33.5 ] ],
                       TOLERANCE);
        });

        it("middle point Y and end point Y should be equal", () => {
            each(pieChart._connectorLines, function() {
                if (this.segments.length > 3) {
                    equal(this.segments[2].anchor().y, this.segments[3].anchor().y);
                } else {
                    equal(this.segments[1].anchor().y, this.segments[2].anchor().y);
                }
            });
        });
    });

    (function() {
        let lines;

        function createPieChart(connectorOptions) {
            setupPieChart(plotArea, {
                series: [ {
                    data: [ 1, 2 ],
                    labels: { visible: true },
                    connectors: connectorOptions
                }],
                connectors: connectorOptions
            });
            lines = pieChart._connectorLines;
        }
        // ------------------------------------------------------------
        describe('Pie Chart / Connectors options', () => {
            beforeEach(() => {
                plotArea = new PlotAreaStub();
            });

            it("sets default connectors color and width", () => {
                createPieChart();
                ok(lines[0].options.stroke.color);
                ok(lines[0].options.stroke.width);
            });

            it("sets specified connectors color and width", () => {
                createPieChart({
                    color: "red",
                    width: 5
                });

                equal(lines[0].options.stroke.color, "red");
                equal(lines[0].options.stroke.width, 5);
            });

            it("sets connectors color based on function", () => {
                createPieChart({
                    color: function(data) {
                        if (data.value === 1) {
                            return "red";
                        }
                        return "blue";
                    }
                });

                equal(lines[0].options.stroke.color, "red");
                equal(lines[1].options.stroke.color, "blue");
            });
        });

    })();

    // ------------------------------------------------------------
    describe('Pie Chart / Labels / Positions', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupPieChart(plotArea, {
                series: [ {
                    data: [ 40, 1, 140 ],
                    labels: {
                        visible: true
                    }
                } ]
            });
        });

        it("center", () => {
            plotArea = new PlotAreaStub();
            setupPieChart(plotArea, {
                series: [ {
                    data: [ 40, 1, 140 ],
                    labels: {
                        visible: true,
                        position: "center"
                    }
                } ]
            });

            closeTextPosition(false, getTexts(), [
                [ 473.898, 193.63 ],
                [ 522.264, 270.99 ],
                [ 304.407, 388.934 ] ], TOLERANCE);
        });

        it("insideEnd", () => {
            plotArea = new PlotAreaStub();
            setupPieChart(plotArea, {
                series: [{
                    data: [ 40, 1, 140 ],
                    labels: {
                        visible: true,
                        position: "insideEnd"
                    }
                }]
            });

            closeTextPosition(false, getTexts(), [
                [ 540.440, 113.704 ],
                [ 624.853, 253.918 ],
                [ 236.488, 467.693 ] ], TOLERANCE);
        });

        it("outsideEnd", () => {

            closeTextPosition(false, getTexts(), [
                [ 587.103, 82 ],
                [ 673.133, 248 ],
                [ 188.896, 502 ] ], TOLERANCE);
        });
    });

})();

(function() {
    // ------------------------------------------------------------
    let chart, labelElement, segmentElement;

    function createPieChart(options) {
        chart = createChart(deepExtend({
            series: [{
                type: "pie",
                data: [1],
                labels: {
                    visible: true,
                    distance: 20
                }
            }]
        }, options));

        const plotArea = chart._model.children[1];
        const segment = plotArea.charts[0].points[0];
        const label = segment.children[0];

        segmentElement = getChartDomElement(segment);
        labelElement = getChartDomElement(label);
    }

    describe('Pie Chart / Events / seriesClick ', () => {
        beforeEach(() => {
            createPieChart({
                seriesClick: function() { ok(true); }
            });
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when clicking points", 1, () => {
            clickChart(chart, segmentElement);
        });

        it("fires when clicking labels", 1, () => {
            clickChart(chart, labelElement);
        });
    });

    // ------------------------------------------------------------
    describe('Pie Chart / Events / seriesHover', () => {
        beforeEach(() => {
            createPieChart({
                seriesHover: function() { ok(true); }
            });
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when clicking points", 1, () => {
            triggerEvent("mouseover", segmentElement);
        });

        it("fires when clicking labels", 1, () => {
            triggerEvent("mouseover", labelElement);
        });
    });

})();

