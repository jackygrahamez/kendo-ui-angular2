import 'core-js/es6';
import { drawing as draw } from '@progress/kendo-drawing';

import { deepExtend, map } from '../../src/common';
import { RootElement, Box } from '../../src/core';

import ScatterLineChart from '../../src/chart/scatter-charts/scatter-line-chart';
import ClipAnimation from '../../src/chart/animations/clip-animation';

import { ok, equal, sameLinePath, sameBox, mapSegments, each } from '../../test/test-helpers';
import { createChart, destroyChart }  from '../test-helpers';
import '../../test/intl';

const chartBox = new Box(0, 0, 800, 600);
const TOLERANCE = 1;
let scatterLineChart, root, pointCoordinates, plotArea;

function getSegmentPath(idx) {
    return scatterLineChart._segments[idx || 0].visual;
}

function setupScatterLineChart(plotArea, options, rootOptions) {
    scatterLineChart = new ScatterLineChart(plotArea, options);

    root = new RootElement(rootOptions);
    root.append(scatterLineChart);
    root.reflow();
    root.renderVisual();

    if (scatterLineChart._segments.length) {
        pointCoordinates = mapSegments(getSegmentPath().segments);
    }
}

(function() {
    const series = { data: [[1, 1], [2, 2]], labels: {}, type: "scatterLine" };
    const sparseSeries = { 
        data: [ [1, 1], [2, 2], undefined, [2, 2], [null, 1], [1, null]], 
        labels: {}, 
        type: "scatterLine", 
        width: 0 
    };
    const VALUE_AXIS_MAX = 2;
    const CATEGORY_AXIS_Y = 2;

    function PlotAreaStub() { }

    deepExtend(PlotAreaStub.prototype, {
        axisX: {
            getSlot: function(categoryIndex) {
                return new Box(categoryIndex, CATEGORY_AXIS_Y,
                categoryIndex + 1, CATEGORY_AXIS_Y);
            }
        },
        axisY: {
            getSlot: function(value = 0) {
                const valueY = VALUE_AXIS_MAX - value;
                const slotTop = Math.min(CATEGORY_AXIS_Y, valueY);
                const slotBottom = Math.max(CATEGORY_AXIS_Y, valueY);

                return new Box(0, slotTop, 0, slotBottom);
            },
            options: {}
        },
        namedXAxes: {},
        namedYAxes: {}
    });

    // ------------------------------------------------------------
    describe('Scatter Line Chart / Series', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupScatterLineChart(plotArea, { series: [ series ] });
        });

        it("removes the series points if the visible is set to false", () => {
            const chart = createChart({
                seriesDefaults: {
                    type: "scatterLine"
                },
                series: [{
                    data: [[1,2]],
                    visible: false
                },{
                    data: [[1,2]]
                }]
            });

            const points = chart._plotArea.charts[0].points;
            ok(points.length === 1);

            destroyChart(chart);
        });

        it("Creates points for scatterLineChart data points", () => {
            equal(scatterLineChart.points.length, series.data.length);
        });

        it("Reports minimum series value for primary X axis", () => {
            equal(scatterLineChart.xAxisRanges[undefined].min, series.data[0][0]);
        });

        it("Reports minimum series value for primary Y axis", () => {
            equal(scatterLineChart.yAxisRanges[undefined].min, series.data[0][1]);
        });

        it("Reports maximum series value for primary X axis", () => {
            equal(scatterLineChart.xAxisRanges[undefined].max, series.data[1][0]);
        });

        it("Reports maximum series value for primary Y axis", () => {
            equal(scatterLineChart.yAxisRanges[undefined].max, series.data[1][1]);
        });

        it("points have set width", () => {
            each(scatterLineChart.points, function() {
                equal(this.box.width(), 1);
            });
        });

        it("points have set height according to value", () => {
            const pointHeights = map(scatterLineChart.points, function(point) {
                return point.box.height();
            });

            equal(pointHeights, [1, 2]);
        });

        it("sets point owner", () => {
            ok(scatterLineChart.points[0].owner === scatterLineChart);
        });

        it("sets point series", () => {
            ok(scatterLineChart.points[0].series === series);
        });

        it("sets point series index", () => {
            ok(scatterLineChart.points[0].seriesIx === 0);
        });

        it("sets point dataItem", () => {
            equal(typeof scatterLineChart.points[0].dataItem, "object");
        });

        it("renders empty scatter line series", 0, () => {
            setupScatterLineChart(plotArea, { series: [ { data: [] } ] });
        });

        it("renders empty and non-empty scatter line series", 0, () => {
            setupScatterLineChart(plotArea, { series: [ { data: [] }, series ] });
        });
    });

    // ------------------------------------------------------------
    describe('Scatter Line Chart / Multiple Axes', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            plotArea.namedXAxes.secondary = plotArea.axisX;
            plotArea.namedYAxes.secondary = plotArea.axisY;

            setupScatterLineChart(plotArea, {
                series: [
                    { type: "scatterLine", data: [[1, 10], [2, 20]] },
                    { type: "scatterLine", xAxis: "secondary", yAxis: "secondary", data: [[3, 30], [4, 40]] }
                ]
            });
        });

        it("Reports minimum value for primary X axis", () => {
            equal(scatterLineChart.xAxisRanges[undefined].min, 1);
        });

        it("Reports minimum value for primary Y axis", () => {
            equal(scatterLineChart.yAxisRanges[undefined].min, 10);
        });

        it("Reports maximum value for primary X axis", () => {
            equal(scatterLineChart.xAxisRanges[undefined].max, 2);
        });

        it("Reports maximum value for primary Y axis", () => {
            equal(scatterLineChart.yAxisRanges[undefined].max, 20);
        });

        it("Reports minimum value for secondary X axis", () => {
            equal(scatterLineChart.xAxisRanges.secondary.min, 3);
        });

        it("Reports minimum value for secondary Y axis", () => {
            equal(scatterLineChart.yAxisRanges.secondary.min, 30);
        });

        it("Reports maximum value for secondary X axis", () => {
            equal(scatterLineChart.xAxisRanges.secondary.max, 4);
        });

        it("Reports maximum value for secondary Y axis", () => {
            equal(scatterLineChart.yAxisRanges.secondary.max, 40);
        });

        it("Throws error when unable to locate X axis", () => {
            expect(function() {
                setupScatterLineChart(plotArea, {
                    series: [
                        { data: [[1, 10], [2, 20]], xAxis: "b" }
                    ]
                });
            }).toThrowError(/Unable to locate X axis with name b/);
        });

        it("Throws error when unable to locate Y axis", () => {
            expect(function() {
                setupScatterLineChart(plotArea, {
                    series: [
                        { data: [[1, 10], [2, 20]], yAxis: "b" }
                    ]
                });
            }).toThrowError(/Unable to locate Y axis with name b/);
        });
    });

    // ------------------------------------------------------------
    describe('Scatter Line Chart / Missing values', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupScatterLineChart(plotArea, {
                series: [ sparseSeries ]
            });
        });

        it("Reports minimum series value for primary X axis", () => {
            equal(scatterLineChart.xAxisRanges[undefined].min, 1);
        });

        it("Reports minimum series value for primary Y axis", () => {
            equal(scatterLineChart.yAxisRanges[undefined].min, 1);
        });

        it("Reports maximum series value for primary X axis", () => {
            equal(scatterLineChart.xAxisRanges[undefined].max, 2);
        });

        it("Reports maximum series value for primary Y axis", () => {
            equal(scatterLineChart.yAxisRanges[undefined].max, 2);
        });

        it("omits null points by default", () => {
            equal(scatterLineChart.points[2], undefined);
        });

        it("omits null points when interpolating", () => {
            setupScatterLineChart(plotArea, {
                series: [
                    deepExtend({ missingValues: "interpolate" }, sparseSeries)
                ]
            });

            equal(scatterLineChart.points[2], undefined);
        });

        it("point with missing X value is omitted", () => {
            equal(scatterLineChart.points[5], undefined);
        });

        it("point with missing Y value is omitted", () => {
            equal(scatterLineChart.points[6], undefined);
        });
    });

    // ------------------------------------------------------------
    describe('Scatter Line Chart / Missing values/ ZERO', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupScatterLineChart(plotArea, {
                series: [ deepExtend({ missingValues: "zero" }, sparseSeries) ]
            });
        });

        it("Reports minimum series value for primary X axis", () => {
            equal(scatterLineChart.xAxisRanges[undefined].min, 0);
        });

        it("Reports minimum series value for primary Y axis", () => {
            equal(scatterLineChart.yAxisRanges[undefined].min, 0);
        });

        it("point with missing X value is not omitted and the value is set to zero", () => {
            equal(scatterLineChart.points[4].value.x, 0);
        });

        it("point with missing Y value is not omitted and the value is set to zero", () => {
            equal(scatterLineChart.points[5].value.y, 0);
        });

        it("does not omit null points and sets the values to zero", () => {
            equal(scatterLineChart.points[2].value.x, 0);
            equal(scatterLineChart.points[2].value.y, 0);
        });
    });

    // ------------------------------------------------------------
    describe('Scatter Line Chart / Rendering', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
            setupScatterLineChart(plotArea, {
                series: [
                        deepExtend({
                            width: 4,
                            color: "#cf0",
                            opacity: 0.5,
                            dashType: "dot",
                            type: "scatterLine"
                        },
                        series
                    )
                ]
            });
        });

        it("sets line width", () => {
            equal(getSegmentPath().options.stroke.width, 4);
        });

        it("sets line color", () => {
            equal(getSegmentPath().options.stroke.color, "#cf0");
        });

        it("sets line opacity", () => {
            equal(getSegmentPath().options.stroke.opacity, 0.5);
        });

        it("sets line dashType", () => {
            equal(getSegmentPath().options.stroke.dashType, "dot");
        });

        it("creates visual", () => {
            ok(scatterLineChart.visual);
        });

        it("creates clip animation", () => {
            ok(scatterLineChart.animation);
            ok(scatterLineChart.animation instanceof ClipAnimation);
            sameBox(scatterLineChart.animation.options.box, root.box);
            sameLinePath(scatterLineChart.animation.element, draw.Path.fromRect(root.box.toRect()));
        });

        it("does not create clip animation if transitions are disabled", () => {
            setupScatterLineChart(new PlotAreaStub(), { series: series }, {
                transitions: false
            });

            ok(!scatterLineChart.animation);
            ok(!scatterLineChart.visual.clip());
        });

        it("does not set clip on points markers by default", () => {
            const points = scatterLineChart.points;
            for (let idx = 0; idx < points.length; idx++) {
                ok(!points[idx].marker.visual.clip());
            }
        });

        it("does not set clip on segments by default", () => {
            const segments = scatterLineChart._segments;
            for (let idx = 0; idx < segments.length; idx++) {
                ok(!segments[idx].visual.clip());
            }
        });

        it("sets animation clip path to points markers with zIndex", () => {
            plotArea = new PlotAreaStub();
            setupScatterLineChart(plotArea, {
                series: [{
                    type: "scatterLine",
                    data: [[0, 1]]
                }, {
                    type: "scatterLine",
                    data: [[1, 2], null],
                    zIndex: 1
                }]
            });

            const clip = scatterLineChart.seriesPoints[1][0].marker.visual.clip();
            ok(clip);
            ok(clip === scatterLineChart.animation.element);
        });

        it("sets animation clip path to segments with zIndex", () => {
            plotArea = new PlotAreaStub();
            setupScatterLineChart(plotArea, {
                series: [{
                    type: "scatterLine",
                    data: [[0, 1], [1, 2]]
                }, {
                    type: "scatterLine",
                    data: [[1, 2], [2, 3]],
                    zIndex: 1
                }]
            });

            const clip = scatterLineChart._segments[1].visual.clip();
            ok(clip);
            ok(clip === scatterLineChart.animation.element);
        });
    });

    // ------------------------------------------------------------
    describe('Scatter Line Chart / Rendering / Missing Values', () => {
        beforeEach(() => {
            plotArea = new PlotAreaStub();
        });

        it("line stops before missing value", () => {
            setupScatterLineChart(plotArea, {
                series: [
                    deepExtend({ missingValues: "gap" }, sparseSeries)
                ]
            });

            equal(pointCoordinates, [
                [ 1.5, 1 ], [ 2.5, 0 ]
            ]);
        });

        it("no line is created for isolated points", () => {
            setupScatterLineChart(plotArea, {
                series: [
                    sparseSeries
                ]
            });

            equal(scatterLineChart._segments.length, 1);
        });

        it("line continues after missing value", () => {
            setupScatterLineChart(plotArea, {
                series: [{
                    data: [ null, [1, 1], [2, 2]],
                    labels: {}, type: "scatterLine", width: 0
                }]
            });

            equal(pointCoordinates, [
                [ 1.5, 1 ], [ 2.5, 0 ]
            ]);
        });

        it("line is drawn between existing points", () => {
            setupScatterLineChart(plotArea, {
                series: [
                    sparseSeries
                ]
            });

            equal(pointCoordinates, [
                [ 1.5, 1 ], [ 2.5, 0 ], [ 2.5, 0 ]
            ]);
        });
    });

    // ------------------------------------------------------------

    describe('Scatter Line Chart / Labels', () => {
        function getPointText(idx) {
            return scatterLineChart.points[idx || 0].label.visual.children[0];
        }

        beforeEach(() => {
            plotArea = new PlotAreaStub();
        });

        it("applies full label format", () => {
            setupScatterLineChart(plotArea, {
                series: [{
                    data: [[1, 10], [2, 20]],
                    labels: { visible: true, format: "{0:C} {1:C}" },
                    type: "scatterLine"
                }]
            });

            equal(getPointText().content(), "$1.00 $10.00");
        });
    });

})();

(function() {
    const MARGIN = 5;
    const PADDING = 5;
    const BORDER = 5;
    const TEMPLATE = "template";
    const FORMAT = "format";
    let scatterLineChart, linePoint, plotArea, scatterLinePoint;

    function PlotAreaStub() { }

    deepExtend(PlotAreaStub.prototype, {
        axisX: {
            getSlot: function(value) {
                return new Box();
            }
        },
        axisY: {
            getSlot: function(categoryIndex) {
                return new Box();
            }
        }
    });

    function createScatterLineChart(options) {
        plotArea = new PlotAreaStub();
        scatterLineChart = new ScatterLineChart(plotArea, {
            series: [deepExtend({
                data: [[0, 0], [1, 1]],
                type: "scatterLine",
                color: "#f00",
                markers: {
                    visible: false,
                    size: 10,
                    type: "triangle",
                    border: {
                        width: BORDER
                    }
                },
                labels: {
                    visible: false,
                    color: "labels-color",
                    background: "labels-background",
                    border: {
                        color: "labels-border",
                        width: BORDER
                    },
                    margin: MARGIN,
                    padding: PADDING,
                    template: TEMPLATE,
                    format: FORMAT
                },
                opacity: 0.5,
                dashType: "dot"
            }, options)]
        });
        scatterLinePoint = scatterLineChart.points[0];
    }

    // ------------------------------------------------------------
    describe('Scatter Line Chart / Configuration', () => {
        beforeEach(() => {
            createScatterLineChart();
        });

        it("applies visible to point markers", () => {
            equal(scatterLinePoint.options.markers.visible, false);
        });

        it("applies series color to point markers border", () => {
            createScatterLineChart({ markers: { visible: true } });
            scatterLineChart.reflow(chartBox);
            equal(scatterLinePoint.marker.options.border.color, "#f00");
        });

        it("applies series opacity color to point markers", () => {
            equal(scatterLinePoint.options.markers.opacity, 0.5);
        });

        it("applies size to point markers", () => {
            equal(scatterLinePoint.options.markers.size, 10);
        });

        it("applies type to point markers", () => {
            equal(scatterLinePoint.options.markers.type, "triangle");
        });

        it("applies border color to point markers", () => {
            createScatterLineChart({ markers: { border: { color: "marker-border" } } });
            equal(scatterLinePoint.options.markers.border.color, "marker-border");
        });

        it("applies border width to point markers.", () => {
            equal(scatterLinePoint.options.markers.border.width, BORDER);
        });

        it("applies visible to point labels", () => {
            equal(scatterLinePoint.options.labels.visible, false);
        });

        it("applies color to point labels", () => {
            equal(scatterLinePoint.options.labels.color, "labels-color");
        });

        it("applies background to point labels", () => {
            equal(scatterLinePoint.options.labels.background, "labels-background");
        });

        it("applies border color to point labels", () => {
            equal(scatterLinePoint.options.labels.border.color, "labels-border");
        });

        it("applies border width to point labels", () => {
            equal(scatterLinePoint.options.labels.border.width, BORDER);
        });

        it("applies padding to point labels", () => {
            equal(scatterLinePoint.options.labels.padding, PADDING);
        });

        it("applies margin to point labels", () => {
            equal(scatterLinePoint.options.labels.margin, MARGIN);
        });

        it("applies dashType to point labels", () => {
            equal(scatterLinePoint.options.dashType, "dot");
        });

        it("applies template to point labels", () => {
            equal(scatterLinePoint.options.labels.template, TEMPLATE);
        });

        it("applies format to point labels", () => {
            equal(scatterLinePoint.options.labels.format, FORMAT);
        });

        it("applies color function", () => {
            createScatterLineChart({
                color: function(point) { return "#f00" }
            });

            equal(scatterLinePoint.color, "#f00");
        });

        it("applies color function for each point", 2, () => {
            createScatterLineChart({
                color: function() { ok(true); }
            });
        });

        it("color fn argument contains value", 1, () => {
            createScatterLineChart({
                data: [[1, 1]],
                color: function(point) {
                    equal(point.value, { x: 1, y: 1});
                }
            });
        });

        it("color fn argument contains series", 1, () => {
            createScatterLineChart({
                name: "series 1",
                data: [[1, 1]],
                color: function(point) { equal(point.series.name, "series 1"); }
            });
        });

        it("color fn argument contains dataItem", 1, () => {
            createScatterLineChart({
                data: [[1, 1]],
                color: function(point) { equal(point.dataItem[0], 1); }
            });
        });
    });

})();

(function() {
    const data = [{
        xValue: 3,
        yValue: 1
    }, {
        xValue: 2,
        yValue: 2
    }, {
        xValue: 2,
        yValue: 2
    }];
    let points, chart;

    // ------------------------------------------------------------
    describe('Scatter Chart / Integration', () => {
        beforeEach(() => {
            chart = createChart({
                series: [{
                    data: data,
                    type: "scatter",
                    xField: "xValue",
                    yField: "yValue"
                }]
            });

            points = chart._plotArea.charts[0].points;
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("gets data from x and y field", () => {
            equal(points.length, 3);
        });
    });

})();

(function() {
    let note, chart;

    describe('Scatter Line Chart / Note', () => {
        beforeEach(() => {
            chart = createChart({
                series: [{
                    name: "Value",
                    type: "scatter",
                    data: [{ x: 1, y: 10, noteText: "A" }]
                }]
            });

            note = chart._plotArea.charts[0].points[0].note;
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("should have text", () => {
            equal(note.text, "A");
        });
    });

    describe('Scatter Line Chart / Note Template', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        function createNote(options) {
            chart = createChart({
                series: [{
                    name: "Value",
                    type: "scatter",
                    data: [{ x: 1, y: 10, noteText: "A", test: "test" }],
                    notes: deepExtend({}, options),
                    name: "name"
                }]
            });

            note = chart._plotArea.charts[0].points[0].note;
        }

        it("dataItem", () => {
            createNote({
                label: {
                    template: "#= dataItem.test #"
                }
            });

            equal(note.label.content, "test");
        });

        it("value", () => {
            createNote({
                label: {
                    template: "x: #= value.x # y: #= value.y #"
                }
            });

            equal(note.label.content, "x: 1 y: 10");
        });

        it("series", () => {
            createNote({
                label: {
                    template: "#= series.name #"
                }
            });

            equal(note.label.content, "name");
        });
    });
})();

// ------------------------------------------------------------

(function() {
    describe('Scatter Chart / Values exceeding axis min or max options ', () => {

        it("values are not limited", 2, () => {
            const plotArea = {
                axisX: {
                    getSlot: function(a,b,limit) {
                        ok(!limit);
                        return new Box();
                    }
                },
                axisY: {
                    getSlot: function(a,b, limit) {
                        ok(!limit);
                        return new Box();
                    }
                }
            };

            setupScatterLineChart(plotArea, { series: [ {data: [[1, 2]], type: "scatterLine"} ] });
        });
    });

})();
