import 'core-js/es6';

import BulletChart from '../../src/chart/bullet-chart/bullet-chart';
import Bullet from '../../src/chart/bullet-chart/bullet';
import { RootElement, Box } from '../../src/core';
import { deepExtend } from '../../src/common';
import categoriesCount from '../../src/chart/utils/categories-count';

import { ok, equal } from '../../test/test-helpers';
import { createChart, destroyChart }  from '../test-helpers';

const chartBox = new Box(0, 0, 800, 600);
let series;

function stubPlotArea(getCategorySlot, getValueSlot, options) {
    return new function() {
        this.categoryAxis = this.primaryCategoryAxis = {
            getSlot: getCategorySlot,
            options: {
                axisCrossingValue: 0,
                categories: options.categoryAxis.categories
            }
        };

        this.valueAxis = {
            getSlot: getValueSlot,
            options: {
                axisCrossingValue: 0
            },
            startValue: function() {
                return 0;
            }
        };

        this.namedCategoryAxes = { };
        this.namedValueAxes = {};

        this.seriesCategoryAxis = function(series) {
            return series.categoryAxis ?
                this.namedCategoryAxes[series.categoryAxis] : this.primaryCategoryAxis;
        };

        this.options = options;
    };
}

(function() {
    let bulletChart;

    const plotArea = stubPlotArea(
        function(categoryIndex) {
            return new Box();
        },
        function(from, to) {
            return new Box(0, 0, to || from, 0);
        },
        {
            categoryAxis: {
                categories: ["A"]
            }
        }
    );

    // ------------------------------------------------------------
    describe('Bullet Chart / Rendering', () => {
        beforeEach(() => {
            bulletChart = new BulletChart(plotArea, {
                series: [{
                    data: [[0, 0]],
                    color: "#f00",
                    opacity: 0.5,
                    overlay: "none"
                }]
            });
        });

        it("applies series fill color to bars", () => {
            equal(bulletChart.points[0].color, "#f00");
        });

        it("applies series opacity color to bullets", () => {
            equal(bulletChart.points[0].options.opacity, 0.5);
        });

        it("applies series overlay to bullets", () => {
            equal(bulletChart.points[0].options.overlay, "none");
        });

        it("applies color function", () => {
            bulletChart = new BulletChart(plotArea, {
                series: [{
                    type: "bullet",
                    data: [[0, 0]],
                    color: function(bullet) { return "#f00" }
                }]
            });

            equal(bulletChart.points[0].color, "#f00");
        });

        it("applies color function for each point", 2, () => {
            bulletChart = new BulletChart(plotArea, {
                series: [{
                    type: "bullet",
                    data: [[0, 0], [1, 1]],
                    color: function() { ok(true); }
                }]
            });
        });

        it("color fn argument contains value", 2, () => {
            new BulletChart(plotArea, {
                series: [{
                    type: "bullet",
                    data: [[0, 1]],
                    color: function(bullet) {
                        equal(bullet.value.current, 0);
                        equal(bullet.value.target, 1);
                    }
                }]
            });
        });

        it("color fn argument contains series", 1, () => {
            new BulletChart(plotArea, {
                series: [{
                    type: "bullet",
                    name: "series 1",
                    data: [[0, 0]],
                    color: function(bubble) { equal(bubble.series.name, "series 1"); }
                }]
            });
        });

        it("applies color binding", () => {
            bulletChart = new BulletChart(plotArea, {
                series: [{
                    type: "bullet",
                    data: [{ value: [0, 0], color: "red" }],
                    colorField: "color"
                }]
            });

            equal(bulletChart.points[0].color, "red");
        });

        it("sets bar size to current value", () => {
            bulletChart = new BulletChart(plotArea, {
                series: [{
                    type: "bullet",
                    data: [[10, 15]],
                    notes: { label: { } }
                }],
                invertAxes: true
            });
            bulletChart.reflow(chartBox);

            equal(bulletChart.points[0].box.x2, 10);
        });

        it("sets target position to target value", () => {
            bulletChart = new BulletChart(plotArea, {
                series: [{
                    type: "bullet",
                    data: [[10, 15]],
                    notes: { label: { } }
                }],
                invertAxes: true
            });
            bulletChart.reflow(chartBox);

            equal(bulletChart.points[0].target.box.x2, 15);
        });
    });

})();

(function() {
    let chart;

    function createBulletChart(options) {
        chart = createChart(deepExtend({
            series: [{
                type: "bullet",
                data: [[1,2]]
            }]
        }, options));
    }

    // ------------------------------------------------------------
    describe('Bullet Chart / Configuration', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("forces categoryAxis.justified to false", () => {
            createBulletChart({
                categoryAxis: {
                    justified: true
                }
            });

            ok(!chart._plotArea.categoryAxis.options.justified);
        });

        it("with no data should not render target", () => {
            createBulletChart({
                series: [{
                    type: "bullet",
                    data: []
                }]
            });

            ok(typeof chart._plotArea.charts[0].points[0].target === "undefined");
        });
    });
})();


(function() {
    const VALUE = 1;
    const CATEGORY = "A";
    const SERIES_NAME = "series";
    const TOOLTIP_OFFSET = 5;
    let bullet, box, root;

    const AxisMock = function() {
        this.getSlot = function() {
            return new Box();
        };
    };

    function createBullet(options, clipBox) {
        box = new Box(0, 0, 100, 100);
        bullet = new Bullet({
            target: VALUE
        }, deepExtend({}, {
            notes: {
                label: {}
            }
        }, options));

        bullet.category = CATEGORY;
        bullet.dataItem = { value: VALUE };
        bullet.percentage = 0.5;
        bullet.series = { name: SERIES_NAME };
        bullet.owner = {
            pane: {
                clipBox: function(){
                    return clipBox || new Box(0, 0, 100, 100);
                }
            },
            seriesValueAxis: function() {
                return new AxisMock();
            },
            categorySlot: function() {
                return new Box();
            }
        };
        root = new RootElement();
        root.box = box;
        root.append(bullet);
        bullet.reflow(box);

        root.renderVisual();
    }

    // ------------------------------------------------------------
    describe('Bullet', () => {

        it("tooltipAnchor is top right corner / vertical / above axis", () => {
            createBullet({ vertical: true, aboveAxis: true, isStacked: false });
            const { point, align } = bullet.tooltipAnchor();

            equal([point.x, point.y], [bullet.box.x2 + TOOLTIP_OFFSET, bullet.box.y1]);
            equal(align.vertical, "top");
            equal(align.horizontal, "left");
        });

        it("tooltipAnchor is top right corner / vertical / above axis / stacked", () => {
            createBullet({ vertical: true, aboveAxis: true, isStacked: true });
            const { point, align } = bullet.tooltipAnchor();
            equal([point.x, point.y], [bullet.box.x2 + TOOLTIP_OFFSET, bullet.box.y1]);
            equal(align.vertical, "top");
            equal(align.horizontal, "left");
        });

        it("tooltipAnchor is bottom right corner / vertical / below axis", () => {
            createBullet({ vertical: true, aboveAxis: false, isStacked: false });
            const { point, align } = bullet.tooltipAnchor();
            equal([point.x, point.y], [bullet.box.x2 + TOOLTIP_OFFSET, bullet.box.y2]);
            equal(align.vertical, "bottom");
            equal(align.horizontal, "left");
        });

        it("tooltipAnchor is bottom right corner / vertical / below axis / stacked", () => {
            createBullet({ vertical: true, aboveAxis: false, isStacked: true });
            const { point, align } = bullet.tooltipAnchor();
            equal([point.x, point.y], [bullet.box.x2 + TOOLTIP_OFFSET, bullet.box.y2]);
            equal(align.vertical, "bottom");
            equal(align.horizontal, "left");
        });

        it("tooltipAnchor is top right corner / horizontal / above axis", () => {
            createBullet({ vertical: false, aboveAxis: true, isStacked: false });
            const { point, align } = bullet.tooltipAnchor();
            equal([point.x, point.y], [bullet.box.x2 + TOOLTIP_OFFSET, bullet.box.y1]);
            equal(align.vertical, "top");
            equal(align.horizontal, "left");
        });

        it("tooltipAnchor is above top right corner / horizontal / above axis / stacked", () => {
            createBullet({ vertical: false, aboveAxis: true, isStacked: true });
            const { point, align } = bullet.tooltipAnchor();
            equal([point.x, point.y], [bullet.box.x2, bullet.box.y1 - TOOLTIP_OFFSET]);
            equal(align.vertical, "bottom");
            equal(align.horizontal, "right");
        });

        it("tooltipAnchor is top left corner / horizontal / below axis", () => {
            createBullet({ vertical: false, aboveAxis: false, isStacked: false });
            const { point, align } = bullet.tooltipAnchor();
            equal([point.x, point.y], [bullet.box.x1 - TOOLTIP_OFFSET, bullet.box.y1]);
            equal(align.vertical, "top");
            equal(align.horizontal, "right");
        });

        it("tooltipAnchor is above top left corner / horizontal / below axis / stacked", () => {
            createBullet({ vertical: false, aboveAxis: false, isStacked: true });
            const { point, align } = bullet.tooltipAnchor();
            equal([point.x, point.y], [bullet.box.x1, bullet.box.y1 - TOOLTIP_OFFSET]);
            equal(align.vertical, "bottom");
            equal(align.horizontal, "left");
        });

        it("tooltipAnchor is limited to the clipbox / horizontal / above axis", () => {
            createBullet({ vertical: false, aboveAxis: true }, new Box(1, 20, 40, 100));
            const { point } = bullet.tooltipAnchor();
            equal(point.x, 40 + TOOLTIP_OFFSET);
            equal(point.y, 20);
        });

        it("tooltipAnchor is limited to the clipbox / vertical / above axis", () => {
            createBullet({ vertical: true, aboveAxis: true}, new Box(1, 40, 50, 100));
            const { point } = bullet.tooltipAnchor();
            equal(point.x, 50 + TOOLTIP_OFFSET);
            equal(point.y, 40);
        });

        it("tooltipAnchor is limited to the clipbox / horizontal / below axis", () => {
            createBullet({ vertical: false, aboveAxis: false}, new Box(40, 20, 100, 100));
            const { point } = bullet.tooltipAnchor();
            equal(point.x, 40 - TOOLTIP_OFFSET);
            equal(point.y, 20);
        });

        it("tooltipAnchor is limited to the clipbox / vertical / below axis", () => {
            createBullet({ vertical: true, aboveAxis: false}, new Box(1, 1, 50, 40));
            const { point } = bullet.tooltipAnchor();
            equal(point.x, 50 + TOOLTIP_OFFSET);
            equal(point.y, 40);
        });

        it("highlightVisual returns bodyVisual", () => {
            createBullet({});
            ok(bullet.highlightVisual() === bullet.bodyVisual);
        });

        it("highlightVisualArgs returns an object with the options, the bullet rect and the bodyVisual", () => {
            createBullet({});
            const result = bullet.highlightVisualArgs();
            equal(result.options, bullet.options);
            ok(bullet.box.toRect().equals(result.rect));
            ok(bullet.bodyVisual === result.visual);
        });
    });
})();
