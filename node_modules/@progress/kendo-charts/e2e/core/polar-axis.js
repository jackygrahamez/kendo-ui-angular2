import 'core-js/es6';

import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';

import { PolarAxis, ShapeBuilder, Box, Point } from '../../src/core';
import { deepExtend, map, last } from '../../src/common';

import { ok, equal, close, arrayClose, sameLinePath, closePaths, closeTextPosition, equalTexts } from '../../test/test-helpers';

import { clickChart, createChart, destroyChart, getChartDomElement }  from '../test-helpers';
import '../../test/text-measure';
import '../../test/intl';

const chartBox = new Box(100, 100, 500, 500);
const center = new Point(300, 300);
const TOLERANCE = 4;
let gridLines, axis, altAxis;

function getAxisTextBoxes() {
    return map(axis.labels, function(item) {
        return item.visual;
    });
}

function getAxisTextBackgrounds() {
    return map(getAxisTextBoxes(), function(item) {
        return item.children[0];
    });
}

function getAxisTexts() {
    return map(getAxisTextBoxes(), function(item) {
        return last(item.children);
    });
}

function createAxis(options) {
    altAxis = {
        options: { visible: true },
        lineBox: function() { return new Box(300, 100, 300, 300); }
    };

    axis = new PolarAxis(options);
    axis.reflow(chartBox);
    axis.plotArea = {
        options: {},
        valueAxis: altAxis
    };

    axis.renderVisual();
}

// ------------------------------------------------------------
describe('Polar Numeric Axis / Rendering', () => {
    beforeEach(() => {
        createAxis();
    });

    it("line box equals box", () => {
        equal(axis.lineBox(), axis.box);
    });

    it("creates labels", 1, () => {
        equalTexts(getAxisTexts(), ["0", "60", "120", "180", "240", "300"]);
    });

    it("applies skip and step when creating labels", () => {
        createAxis({
            labels: {
                skip: 1,
                step: 2
            }
        });
        equalTexts(getAxisTexts(), ["60", "180", "300"]);
    });

    it("creates labels with full format", 1, () => {
        createAxis({ categories: [1, 2], labels: { format: "{0:N2}"} });

        equalTexts(getAxisTexts(), ["0.00", "60.00", "120.00", "180.00", "240.00", "300.00"]);
    });

    it("creates labels with simple format", 1, () => {
        createAxis({ categories: [1, 2], labels: { format: "N2"} });

        equalTexts(getAxisTexts(), ["0.00", "60.00", "120.00", "180.00", "240.00", "300.00"]);
    });

    it("labels can be hidden", () => {
        createAxis({
            labels: {
                visible: false
            }
        });

        equal(axis.labels.length, 0);
    });

    it("labels have set template", 1, () => {
        createAxis({
            labels: {
                template: "|${ data.value }|"
            }
        });

        equal(getAxisTexts()[0].content(), "|0|");
    });

    it("labels have set color", 1, () => {
        createAxis({
            labels: {
                color: "#f00"
            }
        });

        equal(getAxisTexts()[0].options.fill.color, "#f00");
    });

    it("labels have set background", 1, () => {
        createAxis({
            labels: {
                background: "#f0f"
            }
        });

        equal(getAxisTextBackgrounds()[0].options.fill.color, "#f0f");
    });

    it("labels have set zIndex", 1, () => {
        createAxis({
            zIndex: 2
        });

        equal(getAxisTextBoxes()[0].options.zIndex, 2);
    });

    it("labels are distributed on major divisions", () => {
        closeTextPosition("", getAxisTexts(), [[510, 293], [410, 102], [169, 102],
             [69, 293], [169, 483], [410, 483]], TOLERANCE);
    });

    it("applies skip and step when distributing labels", () => {
        createAxis({
            labels: {
                skip: 1,
                step: 2
            }
        });

        closeTextPosition("", getAxisTexts(), [[410, 102], [66, 292], [410, 483]], TOLERANCE);
    });

    it("labels margin is applied", () => {
        createAxis({ labels: { margin: 5 } });

        closeTextPosition("", getAxisTexts(), [[505, 293], [405, 107], [174, 107],
             [74, 293], [174, 478], [406, 478]], TOLERANCE);
    });

    it("labels are distributed in reverse", () => {
        createAxis({ reverse: true });

        closeTextPosition("", getAxisTexts(), [[510, 293], [410, 483], [169, 483],
             [69, 293], [169, 102], [410, 102]], TOLERANCE);
    });
});

// ------------------------------------------------------------
describe('Polar Numeric Axis / Intervals', () => {
    beforeEach(() => {
        createAxis();
    });

    it("major intervals in normal order", () => {
        equal(axis.majorIntervals(), [ 0, 60, 120, 180, 240, 300 ]);
    });

    it("minor intervals in normal order", () => {
        equal(axis.minorIntervals(),
            [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330 ]);
    });
});

// ------------------------------------------------------------


describe('Polar Numeric Axis / Slots', () => {
    let slot;
    beforeEach(() => {
        createAxis();
        slot = axis.getSlot(60);
    });

    it("slot center matches box center", () => {
        equal(slot.center.x, 300);
        equal(slot.center.y, 300);
    });

    it("slot inner radius is 0", () => {
        equal(slot.innerRadius, 0);
    });

    it("slot radius is half box height", () => {
        equal(slot.radius, 200);
    });

    it("slot position", () => {
        equal(slot.startAngle, 120);
        equal(slot.angle, 0);
    });

    it("slot position with rotation", () => {
        createAxis({ startAngle: 180 });

        slot = axis.getSlot(60);
        equal(slot.startAngle, 300);
        equal(slot.angle, 0);
    });

    it("slot position in reverse", () => {
        createAxis({ reverse: true });

        slot = axis.getSlot(60);
        equal(slot.startAngle, 240);
        equal(slot.angle, 0);
    });

    it("slot position in reverse with rotation", () => {
        createAxis({ reverse: true, startAngle: 180 });

        slot = axis.getSlot(60);
        equal(slot.startAngle, 60);
        equal(slot.angle, 0);
    });

    it("slot for range", () => {
        slot = axis.getSlot(60, 120);
        equal(slot.startAngle, 60);
        equal(slot.angle, 60);
    });

    it("slot for range in reverse", () => {
        createAxis({ reverse: true });

        slot = axis.getSlot(60, 120);
        equal(slot.startAngle, 240);
        equal(slot.angle, 60);
    });

    it("from value can't be lower than 0", () => {
        slot = axis.getSlot(-1);
        equal(slot.startAngle, 180);
    });

    it("caps from value to range", () => {
        slot = axis.getSlot(1000);
        equal(slot.startAngle, 180);
    });

    it("to value equals from value when smaller", () => {
        slot = axis.getSlot(60, 30);
        equal(slot.startAngle, 120);
        equal(slot.angle, 0);
    });
});

// ------------------------------------------------------------
describe('Polar Numeric Axis / slot', () => {
    let slot;

    beforeEach(() => {
        createAxis();
        slot = axis.slot(30, 90);
    });

    it("returns geometry Arc", () => {
        ok(slot instanceof geom.Arc);
    });

    it("arc has same center and radius based as slot center and radius", () => {
        const ring = axis.getSlot(30, 90);

        equal(slot.radiusX, ring.radius);
        equal(slot.radiusY, ring.radius);
        equal(slot.center.x, ring.center.x);
        equal(slot.center.y, ring.center.y);
    });

    it("arc start and end angle are equal to the opposite angle of the max and min of the from and to values", () => {
        equal(slot.startAngle, 270);
        equal(slot.endAngle, 330);
        slot = axis.slot(90, 30);
        equal(slot.startAngle, 270);
        equal(slot.endAngle, 330);
    });

    it("arc start and end angle are equal to the min and max of the from and to values for reverse axis", () => {
        axis.options.reverse = true;

        slot = axis.slot(30, 90);
        equal(slot.startAngle, 30);
        equal(slot.endAngle, 90);

        slot = axis.slot(90, 30);
        equal(slot.startAngle, 30);
        equal(slot.endAngle, 90);
    });

    it("the opposite of the axis start angle is added to the arc start and end angles", () => {
        axis.options.startAngle = 90;
        slot = axis.slot(30, 90);
        equal(slot.startAngle, 180);
        equal(slot.endAngle, 240);
    });

});

// ------------------------------------------------------------
describe('Polar Numeric Axis / getValue', () => {
    beforeEach(() => {
        createAxis();
    });

    it("value @ 0 deg", () => {
        const p = Point.onCircle(center, 0, 100);
        equal(axis.getValue(p), 180);
    });

    it("value @ 90 deg", () => {
        const p = Point.onCircle(center, 90, 100);
        equal(axis.getValue(p), 90);
    });

    it("value @ 120 def", () => {
        const p = Point.onCircle(center, 120, 100);
        equal(axis.getValue(p), 60);
    });

    it("value @ 270 def", () => {
        const p = Point.onCircle(center, 270, 100);
        equal(axis.getValue(p), 270);
    });
});

// ------------------------------------------------------------
describe('Polar Numeric Axis / getValue / reverse', () => {
    beforeEach(() => {
        createAxis({
            reverse: true
        });
    });

    it("value @ 0 deg", () => {
        const p = Point.onCircle(center, 0, 100);
        equal(axis.getValue(p), 180);
    });

    it("value @ 90 deg", () => {
        const p = Point.onCircle(center, 90, 100);
        equal(axis.getValue(p), 270);
    });

    it("value @ 120 def", () => {
        const p = Point.onCircle(center, 120, 100);
        equal(axis.getValue(p), 300);
    });

    it("value @ 270 def", () => {
        const p = Point.onCircle(center, 270, 100);
        equal(axis.getValue(p), 90);
    });
});

// ------------------------------------------------------------
describe('Polar Numeric Axis / getValue / startAngle', () => {
    beforeEach(() => {
        createAxis({
            startAngle: 90
        });
    });

    it("value @ 0 deg", () => {
        const p = Point.onCircle(center, 0, 100);
        equal(axis.getValue(p), 90);
    });

    it("value @ 90 deg", () => {
        const p = Point.onCircle(center, 90, 100);
        equal(axis.getValue(p), 0);
    });

    it("value @ 120 def", () => {
        const p = Point.onCircle(center, 120, 100);
        equal(axis.getValue(p), 330);
    });

    it("value @ 270 def", () => {
        const p = Point.onCircle(center, 270, 100);
        equal(axis.getValue(p), 180);
    });
});

// ------------------------------------------------------------
describe('Polar Numeric Axis / getValue / startAngle / reverse', () => {
    beforeEach(() => {
        createAxis({
            startAngle: 90,
            reverse: true
        });
    });

    it("value @ 0 deg", () => {
        const p = Point.onCircle(center, 0, 100);
        equal(axis.getValue(p), 270);
    });

    it("value @ 90 deg", () => {
        const p = Point.onCircle(center, 90, 100);
        equal(axis.getValue(p), 0);
    });

    it("value @ 120 def", () => {
        const p = Point.onCircle(center, 120, 100);
        equal(axis.getValue(p), 30);
    });

    it("value @ 270 def", () => {
        const p = Point.onCircle(center, 270, 100);
        equal(axis.getValue(p), 180);
    });
});

function setupGridLines(altAxis, axisOptions) {
    createAxis(axisOptions);
    gridLines = axis.createGridLines(altAxis);
}

function closeGridLines(actual, expected, tolerance) {
    for (let idx = 0; idx < actual.length; idx++) {
        sameLinePath(actual[idx], draw.Path.fromPoints(expected[idx]), tolerance);
    }
}
// ------------------------------------------------------------
describe('Polar Numeric Axis / Grid lines', () => {

    beforeEach(() => {
        setupGridLines(altAxis);
    });

    it("renders major grid lines by default", () => {
        equal(gridLines.length, 6);
    });

    it("sets major grid lines default width", () => {
        equal(gridLines[0].options.stroke.width, 1);
    });

    it("major grid lines extend from axis center", () => {
        const anchor = gridLines[0].segments[0].anchor();
        equal(anchor.x, 300);
        equal(anchor.y, 300);
    });

    it("major grid lines extend to value axis end", () => {
        const anchor = gridLines[0].segments[1].anchor();
        close(anchor.x, 500, TOLERANCE);
        close(anchor.y, 300, 0.1);
    });

    it("renders 90 degree grid line when value axis is not visible", () => {
        setupGridLines({
            options: { visible: false },
            lineBox: altAxis.lineBox
        }, { majorUnit: 90 });
        const anchor = gridLines[1].segments[1].anchor();
        close(anchor.x, 300, 0.1);
        close(anchor.y, 100, 0.1);
    });

    it("renders 90 degree grid line when value axis line is not visible", () => {
        setupGridLines({
            options: {
            visible: true,
                line: {
                    visible: false
                }
            },
            lineBox: altAxis.lineBox
        }, { majorUnit: 90 });

        const anchor = gridLines[1].segments[1].anchor();
        close(anchor.x, 300, 0.1);
        close(anchor.y, 100, 0.1);
    });

    it("applies major grid line color", () => {
        setupGridLines(altAxis, { majorGridLines: { color: "red" } });

        equal(gridLines[0].options.stroke.color, "red");
    });

    it("applies major grid line width", () => {
        setupGridLines(altAxis, { majorGridLines: { width: 2 } });
        equal(gridLines[0].options.stroke.width, 2);
    });

    it("applies major grid lines skip and step", () => {
        setupGridLines(altAxis, { majorGridLines: { skip: 1, step: 2 } });
        equal(gridLines.length, 3);
        closeGridLines(gridLines, [[[300, 300], [400, 127]], [[300, 300], [100, 300]], [[300, 300], [400, 473]]], TOLERANCE);
    });

    it("renders minor grid lines", () => {
        setupGridLines(altAxis, {
            majorGridLines: {
                visible: false
            },
            minorGridLines: {
                visible: true
            }
        });
        equal(gridLines.length, 11);
    });

    it("applies minor grid line color", () => {
        setupGridLines(altAxis, {
            majorGridLines: {
                visible: false
            },
            minorGridLines: {
                visible: true,
                color: "red"
            }
        });

        equal(gridLines[0].options.stroke.color, "red");
    });

    it("applies minor grid line width", () => {
        setupGridLines(altAxis, {
            majorGridLines: {
                visible: false
            },
            minorGridLines: {
                visible: true,
                width: 4
            }
        });

        equal(gridLines[0].options.stroke.width, 4);
    });

    it("applies minor grid lines skip and step", () => {
        setupGridLines(altAxis, {
            majorGridLines: {
                visible: false
            },
            minorGridLines: {
                visible: true,
                skip: 2,
                step: 4
            }
        });
        equal(gridLines.length, 3);
        closeGridLines(gridLines, [[[300, 300], [400, 127]], [[300, 300], [100, 300]], [[300, 300], [400, 473]]], TOLERANCE);
    });
});

// ------------------------------------------------------------
describe('Polar Numeric Axis / Grid lines / startAngle', () => {
    const TOLERANCE = 0.1;

    beforeEach(() => {
        setupGridLines(altAxis, { startAngle: 10 });
    });

    it("major grid lines are offset with start angle", () => {
        const ref = Point.onCircle(center, 170, 200);
        const end = gridLines[0].segments[1].anchor();

        close(end.x, ref.x, TOLERANCE);
        close(end.y, ref.y, TOLERANCE);        
    });

    it("renders 90 degree grid line as it no longer overlaps the value axis", () => {
        setupGridLines(altAxis, { majorUnit: 90, startAngle: 10 });

        equal(gridLines.length, 4);
    });
});


// ------------------------------------------------------------

function getPlotBands() {
    return axis._plotbandGroup.children;
}

describe('Polar Numeric Axis / Plot Bands', () => {
    beforeEach(() => {
        createAxis({
            plotBands: [{
                from: 60,
                to: 120,
                opacity: 0.5,
                color: "red"
            }]
        });
    });

    it("renders sectors", () => {
        equal(getPlotBands().length, 1);
    });

    it("renders sectors with correct angles", () => {
        closePaths(getPlotBands()[0], ShapeBuilder.current.createRing({
            startAngle: 60,
            angle: 60,
            radius: 200,
            center: {
                x: 300,
                y: 300
            }
        }));
    });

    it("renders color", () => {
        equal(getPlotBands()[0].options.fill.color, "red");
    });

    it("renders opacity", () => {
        equal(getPlotBands()[0].options.fill.opacity, 0.5);
    });

    it("renders z index", () => {
        equal(axis._plotbandGroup.options.zIndex, -1);
    });
});

(function() {
    let chart, label, plotArea;

    function axisLabelClick(clickHandler, options) {
        chart = createChart(deepExtend({
            series: [{
                type: "polarLine",
                data: [[10, 100], [20, 200]]
            }],
            polarAxis: {
                name: "Polar Axis"
            },
            axisLabelClick: clickHandler
        }, options));

        plotArea = chart._model.children[1];
        label = getChartDomElement(plotArea.polarAxis.labels[1]);
        clickChart(chart, label);
    }

    // ------------------------------------------------------------
    describe('Polar Numeric Axis / Events / axisLabelClick', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when clicking axis labels", 1, () => {
            axisLabelClick(function() { ok(true); });
        });

        it("event arguments contain axis options", 1, () => {
            axisLabelClick(function(e) {
                equal(e.axis.type, "polar");
            });
        });

        it("event arguments contain DOM element", 1, () => {
            axisLabelClick(function(e) {
                ok(e.element === label);
            });
        });

        it("event arguments contain label index", 1, () => {
            axisLabelClick(function(e) {
                equal(e.index, 1);
            });
        });

        it("event arguments contain label text", 1, () => {
            axisLabelClick(function(e) {
                equal(e.text, 60);
            });
        });

        it("event arguments contain value", 1, () => {
            axisLabelClick(function(e) {
                equal(e.value, 60);
            });
        });
    });
})();
