import 'core-js/es6';

import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';

import { RootElement, BoxElement, Box } from '../../src/core';
import LineChart from '../../src/chart/line-chart/line-chart';
import LinePoint from '../../src/chart/line-chart/line-point';
import categoriesCount from '../../src/chart/utils/categories-count';

import baseLineChartTests from './base-line-chart';

import { deepExtend, autoFormat } from '../../src/common';

import { ok, equal, close, createSpy, mapSegments, sameBox } from '../../test/test-helpers';
import { clickChart, triggerEvent, createChart, destroyChart, getChartDomElement }  from '../test-helpers';

const chartBox = new Box(0, 0, 800, 600);
const TOLERANCE = 1;
const SANS = "Arial,Helvetica,sans-serif";
const SANS12 = "12px " + SANS;
let lineChart, root, segmentPath, pointCoordinates;

function setupLineChart(plotArea, options) {
    lineChart = new LineChart(plotArea, options);

    root = new RootElement();
    root.append(lineChart);
    root.reflow();
    root.renderVisual();
    segmentPath = lineChart._segments[0].visual;

    pointCoordinates = mapSegments(segmentPath.segments);
}

function stubPlotArea(getCategorySlot, getValueSlot, options) {
    return new function() {
        this.categoryAxis = this.primaryCategoryAxis = {
            getSlot: getCategorySlot,
            options: {
                categories: ["A", "B"]
            }
        };

        this.valueAxis = {
            getSlot: getValueSlot,
            options: {},
            startValue: function() {
                return 0;
            }
        };

        this.namedCategoryAxes = {};
        this.namedValueAxes = {};

        this.seriesCategoryAxis = function(series) {
            return series.categoryAxis ?
                this.namedCategoryAxes[series.categoryAxis] : this.primaryCategoryAxis;
        };

        this.options = options;
    };
}

baseLineChartTests("line", LineChart);

(function() {
    const positiveSeries = { type: "line", data: [1, 2], labels: {} };
    const negativeSeries = { type: "line", data: [-1, -2], labels: {} };
    const sparseSeries = { type: "line", data: [1, 2, undefined, 2], width: 0 };
    const VALUE_AXIS_MAX = 2;
    const CATEGORY_AXIS_Y = 2;

    const plotArea = stubPlotArea(
        function(categoryIndex) {
            return new Box(categoryIndex, CATEGORY_AXIS_Y,
                             categoryIndex + 1, CATEGORY_AXIS_Y);
        },
        function(value = 0) {
            const valueY = VALUE_AXIS_MAX - value;
            const slotTop = Math.min(CATEGORY_AXIS_Y, valueY);
            const slotBottom = Math.max(CATEGORY_AXIS_Y, valueY);

            return new Box(0, slotTop, 0, slotBottom);
        }
    );

    // ------------------------------------------------------------
    describe('Line Chart / Values exceeding value axis min or max options ', () => {

        it("values are not limited", () => {
            let calls = 0;
            const plotArea = stubPlotArea(
                function(categoryIndex) {
                    return new Box(categoryIndex, CATEGORY_AXIS_Y,
                                     categoryIndex + 1, CATEGORY_AXIS_Y);
                },
                function(value, axisCrossingValue, limit) {
                    calls++;
                    ok(!limit);
                    return new Box();
                }
            );

            setupLineChart(plotArea, { series: [ {data: [1, 2]} ] });
            expect(calls).toBe(2);
        });
    });

    // ------------------------------------------------------------
    describe('Line Chart / Multiple Series', () => {
        beforeEach(() => {
            setupLineChart(plotArea, { series: [ negativeSeries, positiveSeries ] });
        });

        it("Reports number of categories for two series", () => {
            setupLineChart(plotArea, {series: [ positiveSeries, negativeSeries ]});
            equal(categoriesCount(lineChart.options.series), positiveSeries.data.length);
        });

        it("getNearestPoint returns nearest series point", () => {
            const point = lineChart.points[1];
            const result = lineChart.getNearestPoint(point.box.x2, point.box.y2 + 100, 1);

            ok(result === point);
        });

        it("aboveAxis is set independently for each point", () => {
            equal(lineChart.points[0].aboveAxis, false);
            equal(lineChart.points[2].aboveAxis, false);
        });
    });

    // ------------------------------------------------------------
    describe('Line Chart / Multiple Category Axes', () => {
        let chart, series;
        beforeEach(() => {
            chart = createChart({
                series: [{
                    type: "line",
                    data: [1],
                    categoryAxis: "secondary"
                }],
                valueAxis: {
                    axisCrossingValue: [10, 0]
                },
                categoryAxis: [{
                    categories: ["A"]
                }, {
                    name: "secondary",
                    categories: ["B"]
                }]
            });

            series = chart._model._plotArea.charts[0];
        });

        afterEach(() => {
            destroyChart(chart);
        });

        it("sets category axis to first series category axis", () => {
            equal(series.categoryAxis.options.name, "secondary");
        });

        it("line is marked as above axis with respect to its category axis", () => {
            equal(series.points[0].aboveAxis, true);
        });
    });

    // ------------------------------------------------------------
    describe('Line Chart / Mismatched series', () => {
        beforeEach(() => {
            setupLineChart(plotArea, {
            series: [ { data: [1, 2, 3] },
                      positiveSeries
                ]
            });
        });

        it("getNearestPoint returns nearest series point", () => {
            const point = lineChart.points[3];
            const result = lineChart.getNearestPoint(point.box.x2 + 100, point.box.y2, 1);

            ok(result === point);
        });
    });

    // ------------------------------------------------------------
    describe('Line Chart / Missing values', () => {
        beforeEach(() => {
            setupLineChart(plotArea, {
                series: [ sparseSeries ]
            });
        });

        it("ignores null values when reporting minimum series value", () => {
            setupLineChart(plotArea, {
                series: [{ data: [1, 2, null] }]
            });
            equal(lineChart.valueAxisRanges[undefined].min, 1);
        });

        it("omits missing points by default", () => {
            equal(lineChart.points[2], null);
        });

        it("missing points are assumed to be 0", () => {
            setupLineChart(plotArea, {
                series: [
                    deepExtend({ missingValues: "zero" }, sparseSeries)
                ]
            });

            equal(lineChart.points[2].value, 0);
        });

        it("missing points are plotted at 0", () => {
            const chart = createChart({
                series: [
                    deepExtend({ missingValues: "zero" }, sparseSeries)
                ],
                valueAxis: {
                    axisCrossingValue: -1000
                }
            });

            lineChart = chart._model._plotArea.charts[0];
            equal(lineChart.plotRange(lineChart.points[2]), [0, 0]);
            destroyChart(chart);
        });

        it("getNearestPoint returns nearest series point (left)", () => {
            const point = lineChart.points[1];
            const result = lineChart.getNearestPoint(point.box.x2 + 0.1, point.box.y2, 0);

            ok(result === point);
        });

        it("getNearestPoint returns nearest series point (right)", () => {
            const point = lineChart.points[3];
            const result = lineChart.getNearestPoint(point.box.x1 - 0.1, point.box.y1, 0);

            ok(result === point);
        });
    });

    // ------------------------------------------------------------
    describe('Line Chart / Stack / Missing values', () => {
        beforeEach(() => {
            setupLineChart(plotArea, {
                series: [ sparseSeries, sparseSeries ],
                isStacked: true
            });
        });

        it("line is drawn between existing points", () => {
            setupLineChart(plotArea, {
                series: [
                    deepExtend({ missingValues: "interpolate" }, sparseSeries)
                ],
                isStacked: true
            });

            equal(pointCoordinates, [
                [ 0.5, 1 ], [ 1.5, 0 ], [ 3.5, 0 ]
            ]);
        });

        it("line stops before missing value", () => {
            setupLineChart(plotArea, {
                series: [
                    deepExtend({ missingValues: "gap" }, sparseSeries)
                ],
                isStacked: true
            });

            equal(pointCoordinates, [
                [ 0.5, 1 ], [ 1.5, 0 ]
            ]);
        });
    });

    // ------------------------------------------------------------
    describe('Line Chart / 100% Stacked / Positive Values', () => {
        beforeEach(() => {
            setupLineChart(plotArea, {
                series: [ positiveSeries, positiveSeries ],
                isStacked: true, isStacked100: true }
            );
        });

        it("reports minumum value for default axis", () => {
            equal(lineChart.valueAxisRanges[undefined].min, 0.5);
        });

        it("reports maximum value for default axis", () => {
            equal(lineChart.valueAxisRanges[undefined].max, 1);
        });
    });

    // ------------------------------------------------------------
    describe('Line Chart / 100% Stacked / Negative Values', () => {
        beforeEach(() => {
            setupLineChart(plotArea, {
                series: [ negativeSeries, negativeSeries ],
                isStacked: true, isStacked100: true }
            );
        });

        it("reports minumum value for default axis", () => {
            equal(lineChart.valueAxisRanges[undefined].min, -1);
        });

        it("reports maximum value for default axis", () => {
            equal(lineChart.valueAxisRanges[undefined].max, -0.5);
        });
    });

    // ------------------------------------------------------------
    describe('Line Chart / 100% Stacked / Fractions', () => {
        beforeEach(() => {
            setupLineChart(plotArea, {
                series: [{
                    type: "line",
                    data: [0, 0]
                },{
                    type: "line",
                    data: [100, 23.6]
                },{
                    type: "line",
                    data: [76.2, 68.9]
                },{
                    type: "line",
                    data: [16.5, 2.8]
                },{
                    type: "line",
                    data: [1.6, 1.5]
                },{
                    type: "line",
                    data: [0, 0]
                }],
                isStacked: true, isStacked100: true }
            );
        });

        it("reports minumum value for default axis", () => {
            equal(lineChart.valueAxisRanges[undefined].min, 0);
        });

        it("reports maximum value for default axis", () => {
            equal(lineChart.valueAxisRanges[undefined].max, 1);
        });
    });

    // ------------------------------------------------------------
    describe('Line Chart / 100% Stacked / Mixed Values', () => {
        beforeEach(() => {
            setupLineChart(plotArea, {
                series: [{
                    data: [2, 2],
                    labels: {}
                }, {
                    data: [-1, -1],
                    labels: {}
                }],
                isStacked: true, isStacked100: true }
            );
        });

        it("reports minumum value for default axis", () => {
            equal(lineChart.valueAxisRanges[undefined].min, 1/3);
        });

        it("reports maximum value for default axis", () => {
            close(lineChart.valueAxisRanges[undefined].max, 2/3);
        });
    });

    // ------------------------------------------------------------
    describe('Line Chart / 100% Stacked / Zero', () => {
        beforeEach(() => {
            setupLineChart(plotArea, {
                series: [{
                    data: [0, 1],
                    labels: {}
                }, {
                    data: [0, 2],
                    labels: {}
                }],
                isStacked: true, isStacked100: true }
            );
        });

        it("reports minumum value for default axis", () => {
            equal(lineChart.valueAxisRanges[undefined].min, 0);
        });

        it("reports maximum value for default axis", () => {
            equal(lineChart.valueAxisRanges[undefined].max, 1);
        });
    });

    // ------------------------------------------------------------
    describe('Line Chart / Rendering', () => {
        beforeEach(() => {
            setupLineChart(plotArea, {
                series: [
                    deepExtend({
                            width: 4,
                            color: "#cf0",
                            opacity: 0.5
                        },
                        positiveSeries
                    )
                ]
            });
        });

        it("sets line width", () => {
            equal(segmentPath.options.stroke.width, 4);
        });

        it("sets line color", () => {
            equal(segmentPath.options.stroke.color, "#cf0");
        });

        it("sets line color to default if series color is fn", () => {
            setupLineChart(plotArea, {
                series: [
                    deepExtend({
                            _defaults: { color: "#cf0" },
                            width: 4,
                            color: function() { },
                            opacity: 0.5
                        },
                        positiveSeries
                    )
                ]
            });
            equal(segmentPath.options.stroke.color, "#cf0");
        });

        it("sets line opacity", () => {
            equal(segmentPath.options.stroke.opacity, 0.5);
        });

        it("does not render points for hidden points", () => {
            const plotArea = stubPlotArea(
                function(categoryIndex) {
                    return new Box();
                },
                function(value) {
                    if (value !== 0) {
                        return new Box();
                    } else {
                        return;
                    }
                }
            );

            setupLineChart(plotArea, {
                series: [{ type: "line", data: [1, 0, 2] }]
            });

            equal(lineChart._segments[0].points().length, 2);
        });
    });

    // ------------------------------------------------------------
    describe('Line Chart / Rendering / Missing Values', () => {

        it("line stops before missing value", () => {
            setupLineChart(plotArea, {
                series: [
                    deepExtend({ missingValues: "gap" }, sparseSeries)
                ]
            });

            equal(pointCoordinates, [
                [ 0.5, 1 ], [ 1.5, 0 ]
            ]);
        });

        it("no line is created for isolated points", () => {
            setupLineChart(plotArea, {
                series: [
                    sparseSeries
                ]
            });

            equal(lineChart._segments.length, 1);
        });

        it("line continues after missing value", () => {
            setupLineChart(plotArea, {
                series: [{
                    data: [ null, 1, 2 ],
                    width: 0
                }]
            });

            equal(pointCoordinates, [
                [ 1.5, 1 ], [ 2.5, 0 ]
            ]);
        });

        it("line is drawn between existing points", () => {
            setupLineChart(plotArea, {
                series: [
                    sparseSeries
                ]
            });

            equal(pointCoordinates, [
                [ 0.5, 1 ], [ 1.5, 0 ], [ 3.5, 0 ]
            ]);
        });

        it("line goes to zero for missing point", () => {
            setupLineChart(plotArea, {
                series: [
                    deepExtend({ missingValues: "zero" }, sparseSeries)
                ]
            });

            equal(pointCoordinates, [
                [ 0.5, 1 ], [ 1.5, 0 ], [ 2.5, 2 ], [ 3.5, 0 ]
            ]);
        });
    });

})();

(function() {
    const VALUE = 1;
    const STACK_VALUE = 2;
    const TOOLTIP_OFFSET = 5;
    const CATEGORY = "A";
    const SERIES_NAME = "series";
    let point, box, marker, label, root;

    function createPoint(options, clipBox) {
        point = new LinePoint(VALUE,
            deepExtend({
                labels: { font: SANS12 }
            }, LinePoint.prototype.defaults, options)
        );

        point.stackValue = STACK_VALUE;
        point.category = CATEGORY;
        point.dataItem = { value: VALUE };
        point.series = { name: SERIES_NAME, zIndex: 100 };
        point.percentage = 0.5;

        point.owner = {
            formatPointValue: function(point, tooltipFormat) {
                return autoFormat(tooltipFormat, point.value);
            },
            pane: {
                clipBox: function(){
                    return clipBox || new Box(0, 0, 100, 100);
                }
            }
        };

        box = new Box(0, 0, 100, 100);
        point.reflow(box);

        root = new RootElement();
        root.append(point);
        root.box = box;
        root.renderVisual();

        marker = point.marker;
        label = point.label;
    }

    // ------------------------------------------------------------
    describe('Line Point', () => {
        beforeEach(() => {
            createPoint();
        });

        it("fills target box", () => {
            sameBox(point.box, box);
        });

        it("creates marker", () => {
            ok(marker instanceof BoxElement);
        });

        it("sets marker width", () => {
            createPoint({ markers: { size: 10 } });
            equal(marker.options.width, 10);
        });

        it("sets marker height", () => {
            createPoint({ markers: { size: 10 } });
            equal(marker.options.height, 10);
        });

        it("sets marker rotation", () => {
            createPoint({ markers: { rotation: 90 } });
            equal(marker.options.rotation, 90);
        });

        it("sets marker zIndex", () => {
            createPoint({ markers: { zIndex: 3 } });
            equal(marker.options.zIndex, 3);
        });

        it("sets marker zIndex from series", () => {
            createPoint({ labels: { visible: true } });
            equal(marker.options.zIndex, 100);
        });

        it("sets labels zIndex", () => {
            createPoint({ labels: { visible: true, zIndex: 3 } });
            equal(label.options.zIndex, 3);
        });

        it("sets labels zIndex from series", () => {
            createPoint({ labels: { visible: true } });
            equal(label.options.zIndex, 100);
        });

        it("doesn't create marker if size is 0", () => {
            createPoint({ markers: { size: 0 } });
            ok(!marker);
        });

        it("sets marker background color", () => {
            equal(marker.options.background, point.options.markers.background);
        });

        it("sets default marker border color based on background", () => {
            createPoint({ markers: { background: "#cf0" } });
            equal(marker.options.border.color, "#a3cc00");
        });

        it("does not change marker border color if set", () => {
            createPoint({ markers: { border: { color: "" } } });
            equal(marker.options.border.color, "");
        });

        it("sets marker border width", () => {
            createPoint({ markers: { border: { width: 4 } } });
            equal(marker.options.border.width, 4);
        });

        it("doesn't create marker", () => {
            createPoint({ markers: { visible: false }});
            ok(!marker);
        });

        it("sets marker shape type", () => {
            createPoint({ markers: { type: "triangle" }});
            equal(marker.options.type, "triangle");
        });

        it("marker is positioned at top", () => {
            createPoint({ vertical: true, aboveAxis: true });
            sameBox(marker.box, new Box(44, -6, 56, 6));
        });

        it("marker is positioned at bottom", () => {
            createPoint({ vertical: true, aboveAxis: false });
            sameBox(marker.box, new Box(44, 94, 56, 106));
        });

        it("marker is positioned at right", () => {
            createPoint({ vertical: false, aboveAxis: true });
            sameBox(marker.box, new Box(94, 44, 106, 56));
        });

        it("marker is positioned at left", () => {
            createPoint({ vertical: false, aboveAxis: false });
            sameBox(marker.box, new Box(-6, 44, 6, 56));
        });

        it("sets marker opacity", () => {
            createPoint({ markers: { opacity: 0.5 }});
            equal(marker.options.opacity, point.options.markers.opacity);
        });

        it("sets marker visual", () => {
            const visual = function() {};

            createPoint({
                markers: {
                    visual: visual
                }
            });
            ok(visual === marker.options.visual);
        });

        it("passes point data", () => {
            createPoint();
            const pointData = marker.pointData;
            equal(pointData.value, VALUE);
            ok(pointData.series === point.series);
            ok(pointData.dataItem === point.dataItem);
        });

        it("createHighlight returns marker outline", () => {
            createPoint({ markers: { type: "circle" }});
            const marker = point.marker.visual.geometry();
            const highlight = point.createHighlight().geometry();

            ok(marker.center.equals(highlight.center));
            equal(marker.radius, highlight.radius);
        });

        it("createHighlight sets default border opacity", () => {
            createPoint({ markers: { type: "circle" } });
            const highlight = point.createHighlight();

            equal(highlight.options.stroke.opacity, 1);
        });

        it("createHighlight sets user border opacity", () => {
            createPoint({
                markers: { type: "circle" },
                highlight: { markers: { border: { opacity: 0.5 } } }
            });
            const highlight = point.createHighlight();

            equal(highlight.options.stroke.opacity, 0.5);
        });

        it("createHighlight sets default opacity", () => {
            createPoint({ markers: { type: "circle" } });
            const highlight = point.createHighlight();

            equal(highlight.options.fill.opacity, 1);
        });

        it("createHighlight sets user opacity", () => {
            createPoint({
                markers: { type: "circle" },
                highlight: { markers: { opacity: 0.5 } }
            });
            const highlight = point.createHighlight();

            equal(highlight.options.fill.opacity, 0.5);
        });

        it("createHighlight returns marker when not initially visible", () => {
            createPoint({ markers: { visible: false }});

            const highlight = point.createHighlight();
            ok(highlight instanceof draw.Circle);
        });

        it("highlightVisual returns the marker visual", () => {
            createPoint({ markers: { visible: true, type: "circle" }});
            ok(point.highlightVisual() instanceof draw.Circle);
            ok(point.highlightVisual() === point.marker.visual);
        });

        it("highlightVisualArgs returns an object with the options, the point marker rect and the marker visual", () => {
            createPoint({ markers: { visible: true }});
            const result = point.highlightVisualArgs();
            equal(result.options, point.options);
            ok(point.marker.paddingBox.toRect().equals(result.rect));
            ok(point.marker.visual === result.visual);
        });

        it("highlightVisualArgs returns no visual and a rect based on the box center and marker size if markers are not visible", () => {
            createPoint({ markers: { visible: false, size: 10}});
            const result = point.highlightVisualArgs();
            const center = point.box.center();
            ok(result.rect.equals(new geom.Rect([center.x - 5, center.y - 5], [10, 10])));
            ok(result.visual === undefined );
        });

        it("tooltipAnchor is at top right of marker / above axis", () => {
            createPoint({ aboveAxis: true });
            const { point: anchor, align } = point.tooltipAnchor();
            equal([anchor.x, anchor.y], [point.marker.box.x2 + TOOLTIP_OFFSET, point.marker.box.y1]);
            equal(align.horizontal, "left");
            equal(align.vertical, "bottom");
        });

        it("tooltipAnchor is at bottom right of marker / below axis", () => {
            createPoint({ aboveAxis: false });
            const { point: anchor, align } = point.tooltipAnchor();
            equal([anchor.x, anchor.y], [point.marker.box.x2 + TOOLTIP_OFFSET, point.marker.box.y2]);
            equal(align.horizontal, "left");
            equal(align.vertical, "top");
        });

        it("tooltipAnchor returns undefined if the marker box is after the clipbox", () => {
            createPoint({ aboveAxis: true }, new Box(1,1, 40, 100));
            const anchor = point.tooltipAnchor();
            equal(anchor, undefined);
        });

        it("tooltipAnchor returns undefined if the marker box is before the clipbox", () => {
            createPoint({ aboveAxis: true}, new Box(57,1, 100, 100));
            const anchor = point.tooltipAnchor();
            equal(anchor, undefined);
        });

        it("tooltipAnchor returns undefined if the marker box is below the clipbox", () => {
            createPoint({ aboveAxis: true}, new Box(1,-10, 100, -7));
            const anchor = point.tooltipAnchor();
            equal(anchor, undefined);
        });

        it("tooltipAnchor returns undefined if the marker box is above the clipbox", () => {
            createPoint({ aboveAxis: true}, new Box(1, 10, 100, 20));
            const anchor = point.tooltipAnchor();
            equal(anchor, undefined);
        });
    });

    // ------------------------------------------------------------
    describe('Line Point / Labels', () => {
        beforeEach(() => {
            createPoint({ labels: { visible: true } });
        });

        it("sets label text", () => {
            equal(label.content, VALUE);
        });

        it("applies full label format", () => {
            createPoint({ labels: { visible: true, format: "{0:c}" }});
            equal(label.content, "$" + VALUE.toFixed(2));
        });

        it("applies simple label format", () => {
            createPoint({ labels: { visible: true, format: "c" }});
            equal(label.content, "$" + VALUE.toFixed(2));
        });

        it("sets label color", () => {
            createPoint({ labels: { visible: true, color: "#cf0" }});
            equal(label.options.color, "#cf0");
        });

        it("sets label background", () => {
            createPoint({ labels: { visible: true, background: "#cf0" }});
            equal(label.options.background, "#cf0");
        });

        it("sets label border color", () => {
            createPoint({ labels: { visible: true, border: { color: "#cf0" } }});
            equal(label.options.border.color, "#cf0");
        });

        it("sets label border width", () => {
            createPoint({ labels: { visible: true, border: { width: 4 } }});
            equal(label.options.border.width, 4);
        });

        it("sets label font", () => {
            createPoint({ labels: { visible: true, font: "12px comic-sans" }});
            equal(label.options.font, "12px comic-sans");
        });

        it("sets default left margin", () => {
            equal(label.options.margin.left, 3);
        });

        it("sets default right margin", () => {
            equal(label.options.margin.right, 3);
        });

        it("labels are not visible by default", () => {
            createPoint();
            equal(typeof label, "undefined");
        });

        it("sets label visibility", () => {
            equal(label.options.visible, true);
        });

        it("label is positioned above marker", () => {
            createPoint({ labels: { visible: true, position: "above" } });
            sameBox(label.box, new Box(39, -35, 60, -6), TOLERANCE);
        });

        it("label is positioned below marker", () => {
            createPoint({ labels: { visible: true, position: "below" } });
            sameBox(marker.box, new Box(44, -6, 56, 6), TOLERANCE);
        });

        it("label is positioned right of marker", () => {
            createPoint({ labels: { visible: true, position: "right" } });
            sameBox(marker.box, new Box(44, -6, 56, 6), TOLERANCE);
        });

        it("label is positioned left of marker", () => {
            createPoint({ labels: { visible: true, position: "left" } });
            sameBox(marker.box, new Box(44, -6, 56, 6), TOLERANCE);
        });
    });

    // ------------------------------------------------------------
    describe('Line Point / Labels / Template', () => {

        function assertTemplate(template, value, format) {
            createPoint({ labels: { visible: true, template: template, format: format } });
            equal(label.content, value);
        }

        it("renders template", () => {
            assertTemplate("${value}%", VALUE + "%");
        });

        it("renders template even when format is set", () => {
            assertTemplate("${value}%", VALUE + "%", "{0:C}");
        });

        it("template has category", () => {
            assertTemplate("${category}", CATEGORY);
        });

        it("template has percentage", () => {
            assertTemplate("${percentage}", "0.5");
        });

        it("template has stackValue", () => {
            assertTemplate("${stackValue}", String(STACK_VALUE));
        });

        it("template has dataItem", () => {
            assertTemplate("${dataItem.value}", String(VALUE));
        });

        it("template has series", () => {
            assertTemplate("${series.name}", SERIES_NAME);
        });
    });
})();

(function() {
    let chart,
        label,
        lineChart,
        marker,
        point,
        segment;

    function createLineChart(options) {
        chart = createChart(deepExtend({
            series: [{
                type: "line",
                data: [1, 2]
            }],
            categoryAxis: {
                categories: ["A"]
            },
            chartArea: {
                width: 600,
                height: 400
            }
        }, options));

        const plotArea = chart._model.children[1];

        lineChart = plotArea.charts[0];
        point = lineChart.points[0];
        marker = getChartDomElement(point.children[0]);
        if (point.children[1]) {
            label = getChartDomElement(point.children[1]);
        } else {
            label = undefined;
        }
        if (lineChart._segments[0]) {
            segment = getChartDomElement(lineChart._segments[0]);
        } else {
            segment = undefined;
        }
    }

    function triggerElement(eventName, element, x, y) {
        let domElement;
        if (element === "segment") {
            domElement = segment;
        } else if (element === "label") {
            domElement = label;
        } else {
            domElement = marker;
        }
        triggerEvent(eventName, domElement, x, y);
    }

    function lineHover(options, element, x = 0, y = 0) {
        const spy = createSpy(options, "seriesHover");
        createLineChart(spy);

        triggerElement("mouseover", element, x, y);

        expect(spy.seriesHover).toHaveBeenCalledTimes(1);
        return spy;
    }

    function lineClick(options, element, x = 0, y = 0) {
        const spy = createSpy(options, "seriesClick");
        createLineChart(spy);
        triggerElement("mousedown", element, x, y);
        triggerElement("mouseup", element, x, y);
        expect(spy.seriesClick).toHaveBeenCalledTimes(1);
        return spy;
    }

    // ------------------------------------------------------------
    describe('Line Chart / Events / seriesClick', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when clicking line points", () => {
            lineClick({
                seriesClick: function() { ok(true); }
            });
        });

        it("fires when clicking line point labels", () => {
            lineClick({
                seriesDefaults: {
                    line: {
                        labels: {
                            visible: true
                        }
                    }
                },
                seriesClick: function(e) { ok(true); }
            }, "label");
        });

        it("event arguments contain value", () => {
            lineClick({
                seriesClick: function(e) { equal(e.value, 1); }
            });
        });

        it("event arguments contain category", () => {
            lineClick({
                seriesClick: function(e) { equal(e.category, "A"); }
            });
        });

        it("event arguments contain percentage and stackValue (100% stacked series)", () => {
            lineClick({
                seriesDefaults: {
                    type: "line",
                    stack: { type: "100%" }
                },
                series: [{ data: [1] }, { data: [2] }],
                seriesClick: function(e) {
                    equal(e.percentage, 1/3);
                    equal(e.stackValue, 1/3);
                }
            });
        });

        it("event arguments contain stackValue (stacked series)", () => {
            createLineChart({
                seriesDefaults: {
                    type: "line",
                    stack: true
                },
                series: [{ data: [1] }, { data: [2] }],
                seriesClick: function(e) {
                    equal(e.stackValue, 3);
                }
            });
            point = lineChart.points[1];
            marker = getChartDomElement(point.children[0]);
            clickChart(chart, marker);
        });

        it("event arguments contain series", () => {
            lineClick({
                seriesClick: function(e) {
                    equal(e.series, chart.options.series[0]);
                }
            });
        });

        it("event arguments contain dataItem", () => {
            lineClick({
                seriesClick: function(e) {
                    equal(e.value, e.value);
                }
            });
        });

        it("event arguments contain element", () => {
            lineClick({
                seriesClick: function(e) {
                    ok(e.element === marker);
                }
            });
        });

        it("fires when clicking line", () => {
            lineClick({
                seriesClick: function() { ok(true); }
            }, "segment");
        });

        it("fires for closest point when clicking line (1)", () => {
            lineClick({
                seriesClick: function(e) { equal(e.value, 1); }
            }, "segment");
        });

        it("fires for closest point when clicking line (2)", () => {
            lineClick({
                seriesClick: function(e) { equal(e.value, 2); }
            }, "segment", 1000);
        });
    });

    // ------------------------------------------------------------
    describe('Line Chart / Events / seriesHover', () => {
        afterEach(() => {
            destroyChart(chart);
        });

        it("fires when hovering line points", () => {
            lineHover({
                seriesHover: function() { ok(true); }
            });
        });

        it("fires when hovering line point labels", () => {
            lineHover({
                seriesDefaults: {
                    line: {
                        labels: {
                            visible: true
                        }
                    }
                },
                seriesHover: function(e) { ok(true); }
            }, "label");
        });

        it("event arguments contain value", () => {
            lineHover({
                seriesHover: function(e) { equal(e.value, 1); }
            });
        });

        it("event arguments contain percentage", () => {
            lineHover({
                seriesDefaults: {
                    type: "line",
                    stack: { type: "100%" }
                },
                series: [{ data: [1] }, { data: [2] }],
                seriesHover: function(e) { equal(e.percentage, 1/3); }
            });
        });

        it("event arguments contain category", () => {
            lineHover({
                seriesHover: function(e) { equal(e.category, "A"); }
            });
        });

        it("event arguments contain series", () => {
            lineHover({
                seriesHover: function(e) {
                    equal(e.series, chart.options.series[0]);
                }
            });
        });

        it("event arguments contain dataItem", () => {
            lineHover({
                seriesHover: function(e) {
                    equal(e.dataItem, e.value);
                }
            });
        });

        it("event arguments contain element", () => {
            lineHover({
                seriesHover: function(e) {
                    ok(e.element === marker);
                }
            });
        });

        it("fires when hovering line", () => {
            lineHover({
                seriesHover: function() { ok(true); }
            }, "segment");
        });

        it("fires for closest point when hovering line (1)", () => {
            lineHover({
                seriesHover: function(e) { equal(e.value, 1); }
            }, "segment");
        });

        it("fires for closest point when hovering line (2)", () => {
            lineHover({
                seriesHover: function(e) { equal(e.value, 2); }
            }, "segment", 1000);
        });

        it("fires when moving over neighbor", () => {
            const spy = lineHover({
                seriesHover: function() { ok(true); }
            }, "segment");

            triggerEvent("mouseover", segment, 500, 100);
            expect(spy.seriesHover).toHaveBeenCalledTimes(2);
       });
    });

   // ------------------------------------------------------------
   describe('Line Chart / API', () => {
        afterEach(() => {
            destroyChart(chart);
        });

       it("ignores null values when series have zIndex", () => {
           createLineChart({
               series: [{
                    field: "value",
                    zIndex: 0,
                    type: "line",
                    data: [
                       {
                           "country": "United States",
                           "year": "1994",
                           "value": 4.9
                       },
                       {
                           "country": "United States",
                           "year": "1995",
                           "value": 9.2
                       },
                       {
                           "country": "United States",
                           "year": "1996",
                           "value": null
                       },
                       {
                           "country": "United States",
                           "year": "1997",
                           "value": 21.6
                       }
                   ]
                }]
           });

           ok(true);
        });
   });
})();
