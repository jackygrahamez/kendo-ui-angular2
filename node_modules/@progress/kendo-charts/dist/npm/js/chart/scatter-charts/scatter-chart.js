module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(295);


/***/ },

/***/ 43:
/***/ function(module, exports) {

	module.exports = require("../line-chart/line-point");

/***/ },

/***/ 55:
/***/ function(module, exports) {

	module.exports = require("../../core");

/***/ },

/***/ 72:
/***/ function(module, exports) {

	module.exports = require("../categorical-chart");

/***/ },

/***/ 102:
/***/ function(module, exports) {

	module.exports = require("../mixins/clip-animation-mixin");

/***/ },

/***/ 147:
/***/ function(module, exports) {

	module.exports = require("../../common");

/***/ },

/***/ 165:
/***/ function(module, exports) {

	module.exports = require("../utils/eval-options");

/***/ },

/***/ 261:
/***/ function(module, exports) {

	module.exports = require("../utils/has-value");

/***/ },

/***/ 295:
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _core = __webpack_require__(55);

	var _clipAnimationMixin = __webpack_require__(102);

	var _clipAnimationMixin2 = _interopRequireDefault(_clipAnimationMixin);

	var _errorRangeCalculator = __webpack_require__(296);

	var _errorRangeCalculator2 = _interopRequireDefault(_errorRangeCalculator);

	var _scatterErrorBar = __webpack_require__(297);

	var _scatterErrorBar2 = _interopRequireDefault(_scatterErrorBar);

	var _linePoint = __webpack_require__(43);

	var _linePoint2 = _interopRequireDefault(_linePoint);

	var _categoricalChart = __webpack_require__(72);

	var _categoricalChart2 = _interopRequireDefault(_categoricalChart);

	var _hasValue = __webpack_require__(261);

	var _hasValue2 = _interopRequireDefault(_hasValue);

	var _evalOptions = __webpack_require__(165);

	var _evalOptions2 = _interopRequireDefault(_evalOptions);

	var _toDate = __webpack_require__(298);

	var _toDate2 = _interopRequireDefault(_toDate);

	var _common = __webpack_require__(147);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var X = _common.constants.X;
	var Y = _common.constants.Y;
	var MIN_VALUE = _common.constants.MIN_VALUE;
	var MAX_VALUE = _common.constants.MAX_VALUE;

	var ScatterChart = function (_ChartElement) {
	    _inherits(ScatterChart, _ChartElement);

	    function ScatterChart(plotArea, options) {
	        _classCallCheck(this, ScatterChart);

	        var _this = _possibleConstructorReturn(this, (ScatterChart.__proto__ || Object.getPrototypeOf(ScatterChart)).call(this, options));

	        _this.plotArea = plotArea;
	        _this._initFields();

	        _this.render();
	        return _this;
	    }

	    _createClass(ScatterChart, [{
	        key: '_initFields',
	        value: function _initFields() {
	            // X and Y axis ranges grouped by name, e.g.:
	            // primary: { min: 0, max: 1 }
	            this.xAxisRanges = {};
	            this.yAxisRanges = {};

	            this.points = [];
	            this.seriesPoints = [];
	            this.seriesOptions = [];
	            this._evalSeries = [];
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            this.traverseDataPoints(this.addValue.bind(this));
	        }
	    }, {
	        key: 'addErrorBar',
	        value: function addErrorBar(point, field, fields) {
	            var value = point.value[field];
	            var valueErrorField = field + "Value";
	            var lowField = field + "ErrorLow";
	            var highField = field + "ErrorHigh";
	            var seriesIx = fields.seriesIx;
	            var series = fields.series;

	            var errorBars = point.options.errorBars;
	            var lowValue = fields[lowField];
	            var highValue = fields[highField];

	            if ((0, _common.isNumber)(value)) {
	                var errorRange = void 0;
	                if ((0, _common.isNumber)(lowValue) && (0, _common.isNumber)(highValue)) {
	                    errorRange = { low: lowValue, high: highValue };
	                }

	                if (errorBars && (0, _common.defined)(errorBars[valueErrorField])) {
	                    this.seriesErrorRanges = this.seriesErrorRanges || { x: [], y: [] };
	                    this.seriesErrorRanges[field][seriesIx] = this.seriesErrorRanges[field][seriesIx] || new _errorRangeCalculator2.default(errorBars[valueErrorField], series, field);

	                    errorRange = this.seriesErrorRanges[field][seriesIx].getErrorRange(value, errorBars[valueErrorField]);
	                }

	                if (errorRange) {
	                    this.addPointErrorBar(errorRange, point, field);
	                }
	            }
	        }
	    }, {
	        key: 'addPointErrorBar',
	        value: function addPointErrorBar(errorRange, point, field) {
	            var low = errorRange.low;
	            var high = errorRange.high;
	            var series = point.series;
	            var options = point.options.errorBars;

	            var isVertical = field === Y;
	            var item = {};

	            point[field + "Low"] = low;
	            point[field + "High"] = high;

	            point.errorBars = point.errorBars || [];
	            var errorBar = new _scatterErrorBar2.default(low, high, isVertical, this, series, options);
	            point.errorBars.push(errorBar);
	            point.append(errorBar);

	            item[field] = low;
	            this.updateRange(item, series);
	            item[field] = high;
	            this.updateRange(item, series);
	        }
	    }, {
	        key: 'addValue',
	        value: function addValue(value, fields) {
	            var x = value.x;
	            var y = value.y;

	            var seriesIx = fields.seriesIx;
	            var series = this.options.series[seriesIx];
	            var missingValues = this.seriesMissingValues(series);
	            var seriesPoints = this.seriesPoints[seriesIx];

	            var pointValue = value;
	            if (!((0, _hasValue2.default)(x) && (0, _hasValue2.default)(y))) {
	                pointValue = this.createMissingValue(pointValue, missingValues);
	            }

	            var point = void 0;
	            if (pointValue) {
	                point = this.createPoint(pointValue, fields);
	                if (point) {
	                    Object.assign(point, fields);
	                    this.addErrorBar(point, X, fields);
	                    this.addErrorBar(point, Y, fields);
	                }
	                this.updateRange(pointValue, fields.series);
	            }

	            this.points.push(point);
	            seriesPoints.push(point);
	        }
	    }, {
	        key: 'seriesMissingValues',
	        value: function seriesMissingValues(series) {
	            return series.missingValues;
	        }
	    }, {
	        key: 'createMissingValue',
	        value: function createMissingValue() {}
	    }, {
	        key: 'updateRange',
	        value: function updateRange(value, series) {
	            var xAxisName = series.xAxis;
	            var yAxisName = series.yAxis;
	            var x = value.x;
	            var y = value.y;

	            var xAxisRange = this.xAxisRanges[xAxisName];
	            var yAxisRange = this.yAxisRanges[yAxisName];

	            if ((0, _hasValue2.default)(x)) {
	                xAxisRange = this.xAxisRanges[xAxisName] = xAxisRange || { min: MAX_VALUE, max: MIN_VALUE };

	                if ((0, _common.isString)(x)) {
	                    x = (0, _toDate2.default)(x);
	                }

	                xAxisRange.min = Math.min(xAxisRange.min, x);
	                xAxisRange.max = Math.max(xAxisRange.max, x);
	            }

	            if ((0, _hasValue2.default)(y)) {
	                yAxisRange = this.yAxisRanges[yAxisName] = yAxisRange || { min: MAX_VALUE, max: MIN_VALUE };

	                if ((0, _common.isString)(y)) {
	                    y = (0, _toDate2.default)(y);
	                }

	                yAxisRange.min = Math.min(yAxisRange.min, y);
	                yAxisRange.max = Math.max(yAxisRange.max, y);
	            }
	        }
	    }, {
	        key: 'evalPointOptions',
	        value: function evalPointOptions(options, value, fields) {
	            var series = fields.series;
	            var seriesIx = fields.seriesIx;

	            var state = { defaults: series._defaults, excluded: ["data", "tooltip", "tempate", "visual", "toggle", "_outOfRangeMinPoint", "_outOfRangeMaxPoint"] };

	            var doEval = this._evalSeries[seriesIx];
	            if (!(0, _common.defined)(doEval)) {
	                this._evalSeries[seriesIx] = doEval = (0, _evalOptions2.default)(options, {}, state, true);
	            }

	            var pointOptions = options;
	            if (doEval) {
	                pointOptions = (0, _common.deepExtend)({}, options);
	                (0, _evalOptions2.default)(pointOptions, {
	                    value: value,
	                    series: series,
	                    dataItem: fields.dataItem
	                }, state);
	            }

	            return pointOptions;
	        }
	    }, {
	        key: 'pointType',
	        value: function pointType() {
	            return _linePoint2.default;
	        }
	    }, {
	        key: 'pointOptions',
	        value: function pointOptions(series, seriesIx) {
	            var options = this.seriesOptions[seriesIx];
	            if (!options) {
	                var defaults = this.pointType().prototype.defaults;
	                this.seriesOptions[seriesIx] = options = (0, _common.deepExtend)({}, defaults, {
	                    markers: {
	                        opacity: series.opacity
	                    },
	                    tooltip: {
	                        format: this.options.tooltip.format
	                    },
	                    labels: {
	                        format: this.options.labels.format
	                    }
	                }, series);
	            }

	            return options;
	        }
	    }, {
	        key: 'createPoint',
	        value: function createPoint(value, fields) {
	            var series = fields.series;
	            var pointOptions = this.pointOptions(series, fields.seriesIx);
	            var color = fields.color || series.color;

	            pointOptions = this.evalPointOptions(pointOptions, value, fields);

	            if ((0, _common.isFunction)(series.color)) {
	                color = pointOptions.color;
	            }

	            var point = new _linePoint2.default(value, pointOptions);
	            point.color = color;

	            this.append(point);

	            return point;
	        }
	    }, {
	        key: 'seriesAxes',
	        value: function seriesAxes(series) {
	            var xAxisName = series.xAxis;
	            var yAxisName = series.yAxis;

	            var plotArea = this.plotArea;
	            var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;
	            var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;

	            if (!xAxis) {
	                throw new Error("Unable to locate X axis with name " + xAxisName);
	            }

	            if (!yAxis) {
	                throw new Error("Unable to locate Y axis with name " + yAxisName);
	            }

	            return {
	                x: xAxis,
	                y: yAxis
	            };
	        }
	    }, {
	        key: 'reflow',
	        value: function reflow(targetBox) {
	            var _this2 = this;

	            var chartPoints = this.points;
	            var limit = !this.options.clip;
	            var pointIx = 0;

	            this.traverseDataPoints(function (value, fields) {
	                var point = chartPoints[pointIx++];
	                var seriesAxes = _this2.seriesAxes(fields.series);
	                var slotX = seriesAxes.x.getSlot(value.x, value.x, limit);
	                var slotY = seriesAxes.y.getSlot(value.y, value.y, limit);

	                if (point) {
	                    if (slotX && slotY) {
	                        var pointSlot = _this2.pointSlot(slotX, slotY);
	                        point.reflow(pointSlot);
	                    } else {
	                        point.visible = false;
	                    }
	                }
	            });

	            this.box = targetBox;
	        }
	    }, {
	        key: 'pointSlot',
	        value: function pointSlot(slotX, slotY) {
	            return new _core.Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
	        }
	    }, {
	        key: 'traverseDataPoints',
	        value: function traverseDataPoints(callback) {
	            var series = this.options.series;
	            var seriesPoints = this.seriesPoints;


	            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
	                var currentSeries = series[seriesIx];
	                var currentSeriesPoints = seriesPoints[seriesIx];
	                if (!currentSeriesPoints) {
	                    seriesPoints[seriesIx] = [];
	                }

	                for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
	                    var _bindPoint = this._bindPoint(currentSeries, seriesIx, pointIx);

	                    var value = _bindPoint.valueFields;
	                    var fields = _bindPoint.fields;


	                    callback(value, (0, _common.deepExtend)({
	                        pointIx: pointIx,
	                        series: currentSeries,
	                        seriesIx: seriesIx,
	                        dataItem: currentSeries.data[pointIx],
	                        owner: this
	                    }, fields));
	                }
	            }
	        }
	    }, {
	        key: 'formatPointValue',
	        value: function formatPointValue(point, format) {
	            var value = point.value;
	            return (0, _common.autoFormat)(format, value.x, value.y);
	        }
	    }, {
	        key: 'animationPoints',
	        value: function animationPoints() {
	            var points = this.points;
	            var result = [];
	            for (var idx = 0; idx < points.length; idx++) {
	                result.push((points[idx] || {}).marker);
	            }
	            return result;
	        }
	    }]);

	    return ScatterChart;
	}(_core.ChartElement);

	(0, _common.setDefaultOptions)(ScatterChart.prototype, {
	    series: [],
	    tooltip: {
	        format: "{0}, {1}"
	    },
	    labels: {
	        format: "{0}, {1}"
	    },
	    clip: true
	});
	(0, _common.deepExtend)(ScatterChart.prototype, _clipAnimationMixin2.default, {
	    _bindPoint: _categoricalChart2.default.prototype._bindPoint
	});

	exports.default = ScatterChart;

/***/ },

/***/ 296:
/***/ function(module, exports) {

	module.exports = require("../error-bars/error-range-calculator");

/***/ },

/***/ 297:
/***/ function(module, exports) {

	module.exports = require("../error-bars/scatter-error-bar");

/***/ },

/***/ 298:
/***/ function(module, exports) {

	module.exports = require("../../date-utils/to-date");

/***/ }

/******/ });